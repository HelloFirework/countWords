LiveSketch: Query Perturbations for Guided Sketch-based Visual Search

John Collomosse1 2, Tu Bui1, and Hailin Jin2

1Centre for Vision Speech and Signal Processing, University of Surrey

2Creative Intelligence Lab, Adobe Research

Abstract

LiveSketch is a novel algorithm for searching large image
collections using hand-sketched queries. LiveSketch tackles
the inherent ambiguity of sketch search by creating visual
suggestions that augment the query as it is drawn, making
query speciﬁcation an iterative rather than one-shot process
that helps disambiguate users’ search intent. Our technical
contributions are: a triplet convnet architecture that incor-
porates an RNN based variational autoencoder to search
for images using vector (stroke-based) queries; real-time
clustering to identify likely search intents (and so, targets
within the search embedding); and the use of backpropaga-
tion from those targets to perturb the input stroke sequence,
so suggesting alterations to the query in order to guide the
search. We show improvements in accuracy and time-to-task
over contemporary baselines using a 67M image corpus.

1. Introduction

Determining user intent from a visual search query re-
mains an open challenge, particularly in sketch based image
retrieval (SBIR) over millions of images where a sketched
shape can yield plausible yet unexpected matches. For exam-
ple, a user’s sketch of a dog might return a map of the United
States that ostensibly resembles the shape (structure) drawn,
but is not relevant. Free-hand sketches are often incomplete
and ambiguous descriptions of desired image content [8].
This limits the ability of sketch to communicate search in-
tent, particularly over large image datasets.

This paper proposes LiveSketch; a novel interactive SBIR
technique in which users iterate to reﬁne their sketched
query, selecting and integrating sketch embellishments sug-
gested by the system in order to disambiguate search in-
tent and so improve the relevance of results (Fig. 1). A core
novelty of our approach lies within the method by which
visual suggestions are generated, exploiting the reversibility
of deep neural networks (DNNs) that are commonly used
to encode image features to create the search index in vi-
sual search systems [26, 13, 7, 6]. By identifying clusters
of likely target intents for the user’s search, we reverse the
DNN encoder to explain how such clusters could be gen-

Figure 1. LiveSketch helps disambiguate SBIR for large datasets,
where a shape sketched from scratch (top left) can yield results
that do not match the users’ search intent. LiveSketch iteratively
suggests reﬁnements to users’ sketched queries to guide the search
(Iter.1-3), based on the user indicating relevant clusters of results
(right). This interaction disambiguates and quickly guides the
search towards results that match users’ search intent (subsec. 4.3).

erated by adapting the query. We are inspired by adversar-
ial perturbations (APs); that use backpropagation to gen-
erate ‘adversarial’ image examples [12] that induce object
mis-classiﬁcation [24, 2, 23] to a targeted category. In our
context of visual search, we similarly backpropagate to per-
turb the sketched query from its current state toward one (or
more) targets identiﬁed in the search embedding by the user.
As such, the query becomes a ‘living sketch’ on the can-
vas that reacts interactively to intents expressed by the user,
forming the basis for subsequent search iterations. The use
of a single, live sketch to collaboratively guide the search dif-
fers from prior approaches such as ShadowDraw [22] that
ghost hundreds of top results on the canvas. We propose
three technical contributions:
1) Vector Queries for Sketch based Image Retrieval. We
learn a joint search embedding that uniﬁes vector graphic
and raster representations of visual structure, encoded by
recurrent (RNN) and convnet (CNN) branches of a novel
triplet DNN architecture. Uniquely, this embedding enables

2879

the retrieval of raster (e.g. photo) content using sketched
queries encoded as a sequence of strokes. This higher level
representation is shown to not only enhance search accuracy
(subsec. 4.1) but also enables perturbation of the query to
form suggestions, without need for pixel regularization.
2) Guided Discovery of Search Intent. We make use of an
auxiliary (semantic) embedding to cluster search results into
pools, each representing a candidate search intent. For exam-
ple, a circle on a stick might return clusters corresponding
to balloons, signs, mushrooms. Deriving query suggestions
from sketches drawn from these pools guides the user toward
relevant content, clarifying intent by supplying contextual
information not present in the query.
3) Query Perturbation. We propose an iterative strategy
for SBIR query reﬁnement in which the users’ query sketch
is perturbed to incorporate the appearance of search intent(s)
indicated by the user. We cast this as a search for a query
perturbation that shifts the encoded query within the search
embedding closer toward those selected intent(s), encoding
that vector as a loss (in the spirit of APs) that is backpropa-
gated through the DNN to update the sketch.

2. Related Work

Visual search is a long-standing problem within the com-
puter vision and information retrieval communities, where
the iterative presentation and reﬁnement of results has been
studied extensively as relevance feedback (RF) [29, 21, 20]
although only sparsely for SBIR [16]. RF is driven by in-
teractive markup of results at each search iteration. Users
tag results as relevant or irrelevant, so tuning internal search
parameters to improve results. Our work differs in that we
modify the query itself to affect subsequent search iterations;
queries may be further augmented by the user at each itera-
tion. Recognizing the ambiguity present in sketched queries
we group putative results into semantic clusters and propose
edits to the search query for each object class present.

Query expansion (QE) is a automated technique to im-
prove search accuracy from a single, one-off visual query
[19, 39, 33, 27] by recursively submitting search results as
queries. LiveSketch contrasts with QE as it is an interactive
system in which query reﬁnements are suggested, and op-
tionally incorporated by the user to help disambiguate search
intent; so communicating more information than present in
a single, initial sketched query.

Deep learning, speciﬁcally CNNs (convnets), have been
rapidly adopted for SBIR and more broadly for visual search
outperforming classical dictionary learning based models
(e.g. bag of words) [30, 3]. Wang et al [34] were arguably
the ﬁrst to explore CNNs for sketched 3D model retrieval
via a contrastive loss network mapping sketches to ren-
dered 2D views. Qi et al. [25] similarly learned correspon-
dence between sketches and edge maps. Fine-grained SBIR
was explored by Yu et al. [38] and Sangkloy et al. [28]
who used a three-branch CNN with triplet loss for learn-
ing the cross-domain embedding. Triplet loss models have
been used more broadly for visual search e.g. using pho-
tographic queries [35, 26, 13]. Bui et al. [4, 6] perform

cross-category retrieval using a triplet model and currently
lead the Flickr15k [15] benchmark for SBIR. Their system
was combined with a learned model of visual aesthetics [36]
to constrain SBIR using stylistic cues in [7]. All of these
prior techniques learn a deep encoder function that maps
an image into a point in a metric search embedding where
the distance between an image pair correlates to its similar-
ity. Such embeddings can be binarized (e.g. via PQ [18])
for scalable search. In prior work search embeddings were
learned using rasterized sketches i.e. images, rather than vec-
tor representations of sketched strokes. In our approach we
adopt the a vector representation for sketches, building upon
the SketchRNN variational auto-encoder of Eck et al. pre-
viously applied to blend [14] and match [37] sketches with
sketches. Here we adapt SketchRNN in a more general form
for both our interactive search of photographs, and for gener-
ating search suggestions, training with the Quickdraw50M
dataset [1].

Our work is aligned to ShadowDraw [22] in which ghosts
(edge-maps derived from top search results) are averaged
and overlaid onto the sketch canvas (similarly, [40] for photo
search). However our system differs both in intent and in
method. ShadowDraw is intended to teach unskilled users
to sketch rather than as a search system in its own right [22].
The technical method also differs - our system uses deep neu-
ral networks (DNNs) both for search and for query guidance,
and hallucinates a single manipulable sketch rather than a
non-edittable cloud of averaged suggestions. This declut-
ters presentation of the suggestions and does not constrain
suggestions to the space of existing images in the dataset.
Our method produces query suggestions by identifying des-
tination points within the search embedding and employing
backpropagation through the deep network (with network
weights ﬁxed) in order to update the input query so that it
maps to those destination points. The manipulation of in-
put imagery with the goal of affecting change in the output
embedding is common in the context of adversarial perturba-
tions (APs) where image pixels are altered to change the clas-
siﬁcation (softmax) output of a CNN [24, 2]. We are inspired
by FGSM [12] which directly backpropagates from classiﬁ-
cation loss to input pixels in order to induce noise that, whilst
near-imperceptible, causes mis-classiﬁcation with high con-
ﬁdence. Although we also backpropagate, our goal differs in
that we aim for observable changes to the query that guide
the user in reﬁning their input. Our reimagining of APs for
interactive query reﬁnement in visual search is unique.

3. Methodology

LiveSketch accepts a query sketch Q in vector graphics
form (as a variable length sequence of strokes), and searches
a large (∼ 108) dataset of raster images I = {I1, ..., IN }.
Our two-stream network architecture (Fig. 2) uniﬁes both
vector and raster modalities via a common search embedding
(S). Sketch and image content are encoded via RNN and
CNN branches respectively, uniﬁed via 4 fully connected
(fc) layers; ﬁnal layer activations yield S ∈ ℜ256. The end-
to-end RNN and CNN paths through the network describe

2880

R ∈ ℜ256
V ∈ ℜ512
S ∈ ℜ256
Z ∈ ℜ2048 Auxiliary embedding (semantic)

Raster embedding [6]*
Vector graphics embedding*
Joint search embedding (structure)

Table 1. Summary of the feature embeddings used in LiveSketch;
* indicates intermediate embeddings not used in the search index.

sketch query. Q′ may be further augmented by the user, and
submitted for a further iteration of search.

3.1. Cross modal Search Embedding (S)

We wish to learn a cross-modal search embedding in
which a sketched query expressed as a variable length se-
quence of strokes, and an image indexed by the system (e.g.
a photograph) containing similar visual structure, map to
similar points within that embedding. We learn this repre-
sentation using a triplet network (Fig. 4) comprising an RNN
anchor (a) and siamese (i.e. identical, shared weights) posi-
tive and negative CNN branches (p/n). The RNN and CNN
branches encode vector and raster content to intermediate
embeddings V and R respectively; we describe how these
are learned in subsecs 3.1.1-3.1.2. The branches are uniﬁed
by 4 fully-connected (fc) layers, with weight-sharing across
all but the ﬁrst layer to yield the common search embedding
S. Thus the fc layers encode two functions mapping V 7→ S
and R 7→ S respectively; we write these FV (.) and FR(.)
and in subsec. 3.1.3 describe incorporation of these into the
pair of end-to-end encoding functions SQ(.) and SI (.) for
our network (Fig. 2).

3.1.1 Sketch Variational Autoencoder

The RNN branch is a forward-backward LSTM encoder
comprising the front half of a variational autoencoder (v.a.e.)
for sketch encoding-decoding, adapted from the SketchRNN
network of Eck et al. [14]. In the SketchRNN v.a.e., a de-
terministic latent representation (z0) is learned, alongside
parameters of multi-variate Gaussian from which a non-
deterministic (n.d.) representation (batchz) is sampled to
drive the decoder and reconstruct the sketch through recur-
rence conditioned on batchz. The representation is learned
via a combination of reconstruction loss (and a regulariza-
tion ‘KL loss’ [17] over the multi-variate parameters), but as
proposed [14] can represent only up to a few object classes
making it unsuitable for web-scale SBIR.

Figure 3. Modiﬁed SketchRNN [14] (changes, blue) used to en-
code/decode stroke sequences via addition of 512-D latent repre-
sentation and classiﬁcation loss. Integrates with Fig. 2 (anchor).

2881

Figure 2. Overview of the proposed SBIR framework. A query
sketch (Q, vector graphics form) and images (I, raster form) are
encoded into the search embedding S via RNN and CNN branches,
uniﬁed via four inner product layers. Images are encoded via SI (.);
the image branch of [6]. Query sketches are encoded via SQ(.);
the encoder stage of Fig. 3. An auxiliary semantic embedding Z
clusters results to help the user pick search target(s) T in the search
embedding. In the spirit of adversarial perturbation, the strokes Q
are adjusted to minimize ||SQ(Q) − Ti||2 and so evolve the sketch
toward the selected target(s).

the pair of encoding functions SQ(Q) and SI (Ii) for encod-
ing the visual structure of sketches, and of images, respec-
tively; the process for learning these functions is described
in subsec. 3.1. Once learned, the image dataset is indexed
(ofﬂine) by feeding forward all Ii ∈ I through SI (.). At
query time, results for a given Q are obtained by ranking on
||SQ(Q) − SI (Ii)||2 where ||.||2 is the L2 norm.

Fig. 2 provides an overview of our interactive search.
Given an initial query Q, images embedded in S proximate
to SQ(Q) are returned. Whilst these images share the visual
structure of Q, the inherent ambiguity of sketch typically re-
sults in semantically diverse content, only a subset of which
is relevant to the user’s search intent. We therefore invite
the user to disambiguate their sketch intent via interaction.
Search results are clustered within an ‘auxiliary’ semantic
embedding Z. The user assigns relevance weights to a few
(m = 3) dominant clusters. For each cluster {C1, ..., Cm} in
Z, a search target {T1, ..., Tm} is identiﬁed in S (process de-
scribed in subsec. 3.3). The targets receiving high weighting
from the user represent visual structures that we will evolve
the existing query sketch Q toward, in order to form a query
suggestion (Q′) to guide the next search iteration.

Our query is represented in vector graphics form to en-
able suggestions to be generated via direct modiﬁcation of
the stroke sequence encoded by Q, avoiding the need for
complex pixel-domain regularization. LiveSketch updates
Q 7→ Q′ such that SQ(Q′) is closer to targets {T1, ..., Tm}
than SQ(Q). Treating the weighted distances between those
targets and SQ(Q′) as a loss, we ﬁx SQ(.) and propagate
gradients back via the RNN branch to perturb the input se-
quence of strokes (subsec. 3.4) and so suggest the modiﬁed

We adapt SketchRNN as follows (Fig. 3). We retrain from
scratch using 3.5M sketches from Quickdraw50M (QD-
3.5M; see Sec. 4) adding a low-dimensional (512-D) bot-
tleneck after z0 from which batchz is sampled. We add soft-
max classiﬁcation loss to that bottleneck, weighted equally
with the original reconstruction and KL loss terms. Dur-
ing training we reduce below 10−2 the covariance of the
n.d. variate. A query sketch (Q) is coded as a sequence of
3-tuples Q = [q1, q2, ..., qn] where qi = (δx, δy, l) repre-
senting relative pen movements in x, y ∈ ℜ2 and whether
the pen is lifted l = [0, 1]; an abbreviated form of the 5-
tuple coding in [14]. The intermediate embedding available
at the bottleneck (V ∈ ℜ512) is capable of reconstructing
sketches across diverse object classes (c.f. Sec.4.2). The
encoder forms the anchor of the proposed triplet network
(Fig. 4); we denote the encoding and decoding functions as
VE(Q) 7→ V and VD(V) 7→ Q.

3.1.2 Raster Structure Encoder

To encode raster content, we adopt the architecture of Bui et
al. [6] for the CNN branch. Their work employs a triplet net-
work with GoogLeNet Inception backbone [32] that uniﬁes
sketches (in raster form) and images within a joint search
embedding. One important property is the partial sharing of
weights between the sketch CNN branch (anchor) and the
siamese image CNN (+/-) branches of their triplet network.
Once trained, these branches yield two functions: RS(.) and
RI (.), that map sketched and image content to a joint search
embedding. Full details on the multi-stage training of this
model are available in [6]; we use their pre-trained model
in our work and incorporate their joint embedding as the in-
termediate embedding R ∈ ℜ256 in our work. Speciﬁcally,
RS(.) is used to train our model (Fig. 4, p/n).

3.1.3 Training the Joint Search Embedding

The end-to-end triplet network (Fig. 4) is trained using
sketches only; 3.5M sketches (10K ×345 object classes)
sampled from the public Quickdraw50M dataset [1] (sim-
pliﬁed via RDP [9], as in [14]) and rasterized by rendering
pen movements as anti-aliased lines of width 1 pixel on a
256 × 256px canvas. The stroke sequence and the rendering
of that sequence are fed through the anchor (a) and positive
(p) branches, and a randomly selected rasterized sketch of
differing object class to negative branch (n). Weights are
optimized via ADAM using triplet loss computed over acti-
vations available from the ﬁnal shared fc layer (the search
embedding S):

Ltrain(a,p,n) = [m + ||SQ(a) − FR(RS(p))| |2

2 −

||SQ(a) − FR(RS(n))| |2

2]+

(1)

where m = 0.2 is a margin promoting convergence, and [x]+
indicates the non-negative part of x. Training yields weights
for the fully connected (fc) layers – recall these are partially
shared across the vector (a) and raster (p/n) branches, yield-
ing FV (.) and FR(.). The end-to-end functions mapping a

Figure 4. Training the LiveSketch network; an encoder that maps
raster and vector content to a common search embedding. The
search embedding is trained using raster and vector (stroke se-
quence) content sampled from QD-3.5M. During training, the CNN
branches (p/n) are RS(.) i.e. the sketch branch of [6]. However
branch RI (.) is used at inference time (Fig. 2).

sketched query Q to our common search embedding S is:

SQ(Q) = FV (VE(Q)).

(2)

Fig. 5a shows the resulting embedding; raster and vector
content representing similar visual structures mix within S
but distinct visual structures form discriminative clusters.

3.2. Search Implementation

Once trained, SQ(.) forms the RNN path within our
search framework (Fig. 2, green) for encoding a vector
sketch query Q. The CNN path SI (.) (Fig. 2, blue) used
to index images for search, adopts the image branch of [6]
(subsec. 3.1.2):

SI (I) = FR(RI (I)).

(3)

Note substitution of the sketch branch RS(.) that was used
during training (eq.1) for the image branch RI (.). Both func-
tions map to the same intermediate embedding R, however
we index images rather than sketches for SBIR.

3.3. Disambiguating Search Intent

Given a search query Q, a k-NN lookup within S is per-
formed to identify a set of results J = [I1, ..., Ik] where
J ⊆ I minimising ||SQ(Q) − SI (Ii)||2; in practice, ||.||2
is approximated via product quantization (PQ) [18] for scal-
ability and up to k = 500 results are returned. The results
are clustered into candidate search intents, and presented to
the user for feedback. Clustering is performed within an aux-
iliary embedding (Z) available from ﬁnal layer activations
of a ResNet50/ImageNet pre-trained CNN. We write this
function Z(Ii), pre-computed ∀Ii ∈ I during indexing.

2882

(a)
Figure 5. (a) Visualizing the search embedding (S) (for 20/345 random classes sampled from QuickDraw50M); sketches in vector (red) and
raster (blue) modalities have been encoded via SQ(.) and SI (.) respectively. The learned representation is discriminative on visual structure
but invariant to modality. (b) A k-NN search (L2, k = 500) yield search results in S local to encoded sketch query SQ(Q); results share
similar structure but span diverse semantics e.g. a box with a cross atop returns boats, churches, windmills. Results are clustered in auxiliary
(semantic) embedding Z and presented to user for ranking.

(b)

3.3.1 Clustering

Images local to SQ(Q) within the search embedding S
may be semantically diverse; a single visual structure e.g.
a cross atop a box, may return churches, boats, windmills,
etc. However these results will form distinct clusters within
Z (Fig. 5b). We apply afﬁnity propagation [11] to identify
the dominant m = 3 clusters C = [c1, ..., cm] in Z. The
algorithm constructs an afﬁnity graph for all image pairs in
(Ia, Ib) ∈ J × J scoring these:

d(Ia, Ib) = ||Z(Ia) − Z(Ib)||2.

(4)

Clustering is a greedy process that iteratively constructs C,
selecting a best cluster ci = I1, ..., Ik from the graph, mini-
mizing ρ(ci):

ρ(ci) = X

(Ia,Ib)∈ci×ci

d(Ia, Ib) + W (ci, C).

(5)

Where W (C) is a penalty term that encourages semantic
diversity by discouraging selection of ci containing images
similar to those already in C:

W (ci, C) ∝ −log 

 X

(Ia,Ib)∈ci×χ(C)

d(Ia, Ib)

 (6)

where χ(ci) represents the set of images already present
within clusters in set C.

3.3.2

Identifying Search Targets

The set of these sketches T = {T1, ..., Tm}, where
Ti = Q∗
i , represent the set of search targets and the basis
for perturbing the user’s query (Q) to suggest a new sketch
Q′ that guides subsequent iterations of search.

3.4. Sketch Perturbations for User Guidance

The search targets T are presented to the user, alongside
sliders that enable the relevance of each to be interactively
expressed as a set of weights Ω = {ω1, ..., ωm}. We seek
a new sketch query Q′ that updates the original query Q to
resemble the visual structure of those targets, in proportion
to these user supplied weights.

For brevity we introduce the following notation. QV ∗

i =
VE(Q∗
i ) describes each search target within the RNN em-
bedding V. Similarly QS∗
i ) describes each target
within the search embedding S. We similarly use QV =
VE(Q) and QS = SQ(Q) to denote the user’s sketch Q
in V and S respectively. To perturb the sketch we seek Q′
(similarly written QV ′
within those embeddings).

i = SQ(Q∗

and QS ′

The availability of the v.a.e. decoder (subsec. 3.1.1) en-
ables generation of new sketches (sequences of strokes) con-
ditioned on any point within V. Our approach is to seek QV ′
such that Q′ = VD(QV ′
) may be generated. The task of
updating Q 7→ Q′ is therefore one of obtaining QV ′
via in-
terpolation between QV and targets QV ∗
, as a function of
user supplied weights and targets.

i

QV ′

= f (QV ; Ω, T ).

(9)

We describe two strategies (instances of f ) for computing
QV ′

from query QV (evaluating these in subsec. 4.2).

For each cluster i = [1, m] we identify a representative im-
age I ∗

i closest to the visual structure of the query:

3.4.1 Linear Interpolation

I ∗
i = arg min

Ij

||SQ(Q) − SI (Ij)||2; ∀Ij ∈ Ci.

(7)

Leveraging the Quickdraw50M dataset (QD-3.5M) of
i to each rep-

sketches (H), we identify the closest sketch Q∗
resentative image:

Q∗

i = min
q∈H

||SQ(q) − SI (I ∗

i )||2.

(8)

A na¨ıve solution is to linearly interpolate within the RNN
embedding V, i.e.:

flinear(QV ; Ω, T ) = QV +

m

X

i=1

ωj(QV ∗

i − QV )

(10)

yielding QV ′

Q′ is generated via RNN decoder Q′ = VD(QV ′

via eq. 9, from which the sketch suggestion
). However,

2883

Method

Class-level

Instance-level

S-I

S-S

LS (Ours)

LS-R

LS-R-I [6]
Sketchy [28]
Bui et al. [5]

V-R
R-V

V-R-shufﬂe
R-V-shufﬂe

38.40
35.26
35.15
33.21
12.59

34.88
29.31
35.94
29.61

30.81
29.48
27.48
27.06
8.76

18.80
18.29
15.71
18.57

Table 2. Accuracy for sketch based recall of sketches (S-S) and
images (S-I); evaluated using class and instance level mAP (%)
over 345 vector queries (QD-345). Top: S-I ablations; raster query
(LS-R) and raster intermediate embedding (LS-R-I) [6]. Bot. S-S
retrieval across query modalities; raster querying vector (R-V) and
vector querying raster (V-R); also variants stroke order (-shufﬂe).

4. Experiments and Discussion

We evaluate the performance of the LiveSketch using the
QuickDraw50M dataset [1] and a corpus of 67M stock photo
and artwork images (Stock67M) from Adobe Stock1.

QuickDraw50M is a dataset of 50M hand-drawn
sketches crowdsourced via a gamiﬁed classiﬁcation exer-
cise (Quick, Draw!) [1]. Quickdraw50M is well suited to
our work due to its class diversity (345 object classes), vec-
tor graphics (stroke sequence) format, and the casual/fast,
throwaway act of the sketching encouraged in the exercise
that reﬂects typical SBIR user behaviour [8] (vs. smaller,
less category-diverse datasets such as TUBerlin/Sketchy that
contain higher ﬁdelity sketches drawn with reference to a
target photograph [28, 10]). We sample 3.5M sketches ran-
domly with even class distribution from the Quickdraw50M
training partition to create training set (QD-3.5M; detail in
subsec 3.1.3). For sketch retrieval and interpolation exper-
iments we sample 500 sketches per class (173K total) at
random from the Quickdraw50M test partition to create an
evaluation set QD-173K). A query set of sketches (QD-345)
is sampled from QD-173K, one sketch per object class, to
serve as queries for our non-interactive experiments.

Stock67M is a diverse, unannotated corpus of images
used to evaluate large-scale SBIR retrieval performance. The
dataset was created by scraping harvesting every public,
unwatermarked image thumbnails from the Adobe Stock
website in late 2016 yielding approximately 67M images at
QVGA resolution.

4.1. Evaluating cross modal search

We evaluate the performance of our cross-modal embed-

ding (S) for sketch based retrieval of sketches and images.
Sketch2Sketch (S-S) Matching. We evaluate the ability of
our embedding trained in subsec. 3.1.3 to discriminate be-
tween sketched visual structure, invariant to input modality
(vector vs. raster). We train our model on QD-3.5M and re-
trieve sketches from the QD-173K corpus, using QD-345 as

1Downloaded from https://stock.adobe.com in late 2016

2884

Figure 6. Generating Q′: Linear (top) vs. non-linear (bottom) in-
terpolation in RNN space (V); the latter due to backpropagation of
loss eq. 12 that updates Q 7→ Q′ s.t. QS ′
tends toward the search
targets identiﬁed local to QS by the user. See Fig. 8 for examples.

although QS and QS∗
are local by construction, it is unlikely
that QV and QV ∗
i will be local; nor is the manifold of plau-
sible sketches within V linear. This can lead to generation
of implausible sketches (c.f. Sec. 4.2, Fig. 8).

i

3.4.2 Back-propagation

We therefore perform a non-linear interpolation in V, min-
imizing an objective that updates QV 7→ QV ′
closer to
search target(s) QV ∗
via backprop through the fc layers
FV (.) (eq.2) to reduce the distance between QS and QS∗

.

i

i

D(QV ′

) =

1
m

m

X

j=1

ωj||QS ′

− QS∗

j ||2
2.

(11)

This is analogous to FGSM adversarial perturbation (AP)
of images in object recognition [12], where the input the
network is modiﬁed via backprop to inﬂuence its mapping
to a classiﬁcation embedding. In our context, we deﬁne a
loss based on this distance in S regularized by the constraint
that the original and updated sketch should be nearby in V:

LAP(Q′) = D(QV ′

) + α||QV ′

− QV ||2.

(12)

Weight α = 0.1 was emperically set. An optimal QV ′
sought by backpropagation through the fc layer FV (.):

is

fAP(Q′; Ω, T ) = arg min

LAP(VE(q′)).

(13)

q′

Equipped with sliders to control relevance weights Ω on
each of the targets, the user in effect performs a linear in-
terpolation (between SQ(Q) and T ) within S that causes a
′V , and
non-linear extrapolation from QV to output point Q
ultimately the sketch suggestion via RNN decoder Q′ =
′V ). Fig. 6 contrasts the linear and non-linear (back-
FD(Q
prop) approaches; visual examples in Fig. 8.

Figure 8. Comparison of sketch interpolation via our backprop
(fAP ) approach and linear interpolation (flinear) within V, for
ﬁne-grain variations of a boat and a bag (c.f. Tbl. 3).

Figure 7. Performance of joint search embedding for retrieval. Top:
Sketch2Image (S-I) Precision@k curve for SBIR – see Tbl. 2 for
mAP% and key to ablation notation. Bottom: Sketch2Sketch (S-S)
cross-modal matching. Class-level (solid) and instance level (dash)
mAP-recall curves for Vector-Raster (V-R), Raster-Vector (R-V),
and stroke shufﬂing experiments (-shufﬂe).

queries. Both vector queries retrieving raster content (V-R)
and vice versa (R-V) are explored, using category (class-
level) and ﬁne-grain (instance-level) metrics. For the for-
mer we consider a retrieved record a match if it matches the
sketched object class. For the latter, the exact same sketch
must be returned. To run raster variants, a rasterized version
of QD-173K is produced by rendering strokes to a 256×256
pixel canvas (see method of subsec. 3.1.3). Sketches from
QD-173K are encoded to the search embedding S from their
vector and raster form respectively via functions SQ(.) and
FR(RS(.)). Fig. 5 visualizes the sketches within the search
embedding; similar structures cluster together whilst the vec-
tor/raster modalities mix. Tbl. 2 (bot.) and Fig. 7 (bot.) char-
acterize performance; vector queries (∼ 35% mAP) out-
perform raster (∼ 29% mAP) by a ∼ 5% margin. To ex-
plore this gain further, we shufﬂed the ordering of the vector
strokes retraining the model from scratch. We were surprised
to see comparable performance at class-level, suggesting this
gain is due to the spatial continuity inherent to the stroke rep-
resentation, rather than temporal information. The fractional
increase may be due to the shufﬂing acting as data augmen-
tation enhancing invariance to stroke order. However when
at instance level, ordering appears more signiﬁcant (∼ 3%
gain; V-R vs. V-R-shufﬂe).
Sketch2Image (S-I) Matching. We evaluate the perfor-
mance of the search embedding for SBIR over Stock67M,
using all QD-345 sketch queries (without user interaction
in this experiment). Annotation of 67M images for every

Table 3. Perturbation method user study (MTurk) comparing the
proposed query perturbation scheme inspired by adversarial pertur-
bations (fAP ) vs. linear interpolation variants (flinear, fSLERP ).

query is impractical; we instead crowd-source per-query an-
notation via Mechanical Turk (MTurk) for the top-k (k=15)
results and compute both mAP% and precision@k curve
averaged across all 345 queries for each experiment. The
annotation is crowd-source with 5 repetitions. Results are
summarized in Tbl. 2 (S-I) and Fig. 7 (top). We perform
two ablations to our proposed LiveSketch (LS) system: 1)
querying with rasterized versions of the QD-345 queries
(-R) using the proposed embedding S; 2) querying with
rasterized queries in the intermediate embedding R (-R-I)
which degenerates to [6]; we also baseline against two fur-
ther recent SBIR techniques: the unshared triplet GoogleNet-
V1 architecture proposed by Sangkloy et al. [28], and the
triplet edgemap approach of Bui et al. [5]. We compute
class- and instance- level precision for all queries result-
ing in 345 × 15 × 5 =∼ 26K MTurk annotations. Our
embedding (LS) outperforms all ablations and baselines,
with vector query alone contributing signiﬁcant margin over
raster. The addition of fc layers to create cross-modal em-
bedding (-R) slightly improves (importantly, does not de-
grade) the intermediate raster embedding R available via [6].
The method signiﬁcantly outperforms recent triplet SBIR
approaches [28, 5]. Note that the S-I and S-S ﬁgures are
non-comparable; they search different datasets.

2885

Method

Ablations: seconds(missed)

Baselines seconds(missed)

LS (Ours)

LS-NI

LS-NI-R

LS-NI-R-I [6]

Sketchy [28] Bui et al. [5]

Class-level T-T
24.90 (1.33)
Instance-level T-T 30.74 (2.00)

38.33 (1.33)
45.43 (1.67)

31.74 (0.33)
66.46 (3.67)

19.12 (0.00)
95.27 (3.67)

46.20 (1.00)
80.28 (2.67)

40.13 (1.33)
75.02 (1.33)

Mean Avg. T-T

27.67 (3.33)

41.72 (3.00)

45.92 (4.00)

42.69 (3.67)

60.90 (3.67)

54.88 (2.67)

Table 4. Time-to-task user study. Average time to retrieve 20 class- and instance-level search targets (18 participants, 3 per method).
Comparing LiveSketch (LS) interactive method with ablations (-NI) non-interactive/one-shot; (-R) raster substitutes vector query; (-I)
intermediate structure embedding, and with the three baselines [6, 28, 5]. Times in seconds; parentheses total the averaged missed queries.

4.2. Evaluating Search Suggestions

MTurk was used to evaluate the relative performance of
sketch interpolation techniques used to form query sugges-
tions (Q′). We benchmark linear (flinear) and spherical lin-
ear (SLERP, [14] fSLERP ) interpolation[14] in our RNN
embedding V with the proposed approach fAP inspired by
adversarial perturbations, in which the sketch is perturbed
via non-linear interpolation in V due to backpropagation.
We also compare to linear and SLERP embedding within
the embedding of the original SketchRNN network of Eck
et al. [14] trained using the same data (QD-3.5M).

MTurkers were presented with a pair of sketches Q and
Q′ sampled from QD-173K and shown a sequence of 10
sketches produced by each of the 5 interpolation methods.
MTurkers were asked to indicate which interpolation looked
most natural / human drawn. Each experiment run sampled
300 intra- and 300 inter-category pairs (Q, Q′) picked at
random from QD-173K. The experiment was repeated 5
times yielding 3k annotations from 25 unique MTurkers.

Tbl. 3 summarizes user study results; an un-paired t-test
[31] was run to determine signiﬁcance (p). Backpropaga-
tion (fAP , proposed) outperformed direct linear interpola-
tion (flinear) in V for inter- (18.0% vs. 26.7%, p < 0.002)
and intra-category (18.7% vs. 25.3, p < 0.030) cases (see
Fig. 8 for visual examples). Statistically signiﬁcant results
were obtained for fSLERP at p < 0.03. In both cases prefer-
ence was stronger for inter-category interpolation, likely due
to non-local nature of (Q, Q′) causing linear interpolation to
deviate from the manifold of plausible sketches (enforced
by fAP ). Even linear interpolation in V enabled more natu-
ral interpolations in both inter- and intra-category cases vs.
original SketchRNN [14]; but this was signiﬁcant only for
the former.

4.3. Evaluating Iterative Retrieval

We evaluate the efﬁcacy of LiveSketch via a time-to-task
experiment in which 18 participants were timed searching
for 20 targets using 6 methods. We perform 3 ablations
to our method (LS): 1) non-interactive (-NI), users are not
offered sketch suggestions; 2) sketches are rasterized (-R)
rather than processed as vector queries; 3) as -R but search-
ing within intermediate embedding R which degenerates to
[6] (-R-I). We also baseline against [28, 5].

Fig. 1 provides a representative query, suggestions and
clustered results sampled from the study. Tbl. 4 summa-
rizes the results, partitioning across class- and instance- level
queries (10 each). Class-level (category) queries prompted

the user to search for a speciﬁc object (‘cruise ship sailing
on the ocean’). Instance-level (ﬁne-grain) queries prompted
the user to search for a speciﬁc object with speciﬁc pose
or visual attributes (‘church with three spires’,‘side view of
a shark swimming left’). Timing began on the ﬁrst stroke
drawn and ended when the user was satisﬁed that the tar-
get had been found (self-assessed). If a user took longer
than three minutes to ﬁnd a target, then the search time was
capped and noted as a miss (bracketed in Tbl. 4).

Signiﬁcant decrease in time-to-task (∼ 15s) was ob-
served with the interactive method (LS) over non-interactive
variants using vector (LS-NI, LS-NI-R, LS-NI-R) although
query modality had negligible effect on mean time to task
for non-interactive cases. Baselines performed ∼ 10 − 20s
slower onexplainable via lower retrieval performance in sub-
sec. 4.1. In all cases, ﬁne-grain queries took longer to iden-
tify with greater instances of missed searches – however the
margin over class-level searches was only ∼ 6s vs. inter-
active. Whilst category level search time was not enhanced
by the proposed method, time taken to produce successful
ﬁne-grain sketch queries was signiﬁcantly reduced by up
to 15s over non-interactive ablations and by a factor of 3
over baselines. All 6 methods used a PQ [18] index and took
30 − 40ms to run each query over the Stock67M corpus.

5. Conclusion

We presented an novel architecture that, for the ﬁrst time,
enables search of large image collections using sketched
queries expressed as a variable length sequence of strokes
(i.e.
in ’vector’ form). The vector modality enables a
seocnd contribution; live perturbation of the sketched query
strokes to guide the user’s search. The search is guided
towards likely search intents — interactively speciﬁed by
user weights attributed to clusters of results returned at each
search iteration. Perturbations were generated via backprop-
agation through the feature encoder network, inspired by ad-
versarial perturbations (FGSM [12]) typically used to attack
object classiﬁcation systems, and applied for the ﬁrst time
here in the context of relevance feedback for visual search.
We showed that our interactive system signiﬁcantly reduces
search time over a large (67M) image corpus, particularly
for instance-level (ﬁne-grain) SBIR, and that our search em-
bedding (unifying vector/RNN and image/CNN modalities)
performs competitively against three baselines [6, 28, 5]. Fu-
ture work could focus on improvement of the RNN embed-
ding which can still produce implausible sketches for very
detailed (high stroke count) drawings.

2886

References

[1] The Quick, Draw! Dataset.

googlecreativelab/quickdraw-dataset.
cessed: 2018-10-11. 2, 4, 6

https://github.com/
Ac-

[2] A. Athalye, L. Engstrom, A. Ilyas, and K. Kwok. Syn-
CoRR Abs,

thesizing robust adversarial examples.
arXiv:1707.07397v2, 2017. 1, 2

[3] Tu Bui and John Collomosse. Scalable sketch-based image
retrieval using color gradient features. In Proc. ICCV Work-
shops, pages 1–8, 2015. 2

[4] T. Bui, L. Ribeiro, M. Ponti, and J. Collomosse. Generali-
sation and sharing in triplet convnets for sketch based visual
search. CoRR Abs, arXiv:1611.05301, 2016. 2

[5] T. Bui, L. Ribeiro, M. Ponti, and J. Collomosse. Compact de-
scriptors for sketch-based image retrieval using a triplet loss
convolutional neural network. Computer Vision and Image
Understanding (CVIU), 2017. 6, 7, 8

[6] T. Bui, L. Ribeiro, M. Ponti, and J. Collomosse. Sketching
out the details: Sketch-based image retrieval using convolu-
tional neural networks with multi-stage regression. Elsevier
Computers & Graphics, 2018. 1, 2, 3, 4, 6, 7, 8

[7] J. Collomosse, T. Bui, M. Wilber, C. Fang, and H. Jin. Sketch-
ing with style: Visual search with sketches and aesthetic con-
text. In Proc. ICCV, 2017. 1, 2

[8] J P Collomosse, G McNeill, and L Watts. Free-hand sketch

grouping for video retrieval. In Proc. ICPR, 2008. 1, 6

[9] D. H. Douglas and T. K. Peucker. Algorithms for the reduc-
tion of the number of points required to represent a digitized
line or its caricature. Cartographica: The International Jour-
nal for Geographic Information and Geovisualization, pages
112–122, 1973. 4

[10] Mathias Eitz, James Hays, and Marc Alexa. How do humans
sketch objects? In Proc. ACM SIGGRAPH, volume 31, pages
44:1–44:10, 2012. 6

[11] B. J. Frey and D. Dueck. Clustering by passing messages

between data points. Science, 315:972–976, 2007. 5

[12] I. Goodfellow, J. Shlens, and C. Szegedy. Explaining and har-
nessing adversarial examples. CoRR Abs, arXiv:1412.6572,
2015. 1, 2, 6, 8

[13] Albert Gordo, Jon Almaz´an, Jerome Revaud, and Diane Lar-
lus. Deep image retrieval: Learning global representations
for image search. In Proc. ECCV, pages 241–257, 2016. 1, 2
[14] D. Ha and D. Eck. A neural representation of sketch drawings.

In Proc. ICLR. IEEE, 2018. 2, 3, 4, 8

[15] Rui Hu and John Collomosse. A performance evaluation
of gradient ﬁeld HOG descriptor for sketch based image re-
trieval. Computer Vision and Image Understanding (CVIU),
117(7):790–806, 2013. 2

[16] S. James and J. Collomosse. Interactive video asset retrieval

using sketched queries. In Proc. CVMP, 2014. 2

[17] N. Jaques, S. Gu, D. Bahdanau, J. Hernandez-Lobato, R.
Turner, and D. Eck. Sequence tutor: Conservative ﬁne-tuning
of sequence generation models with kl-control.
In Proc.
ICML. IEEE, 2017. 3

[18] H. Jegou, M. Douze, C. Schmid, and P. Perez. Aggregating
In

local descriptors into a compact image representation.
Proc. CVPR, 2010. 2, 4, 8

[19] J.Philbin, O. Chum, M. Isard, J. Sivic, and A. Zisserman. Ob-
ject retrieval with large vocabularies and fast spatial matching.
In Proc. CVPR, 2007. 2

[20] A. Kovashka and K. Grauman. Attribute pivots for guiding
relevance feedback in image search. In Proc. ICCV, 2013. 2
[21] A. Kovashka, D. Pariks, and K. Grauman. Whittlesearch:
Image search with relative attribute feedback. In Proc. CVPR,
2012. 2

[22] Y. Lee, C. Zitnick, and M. Cohen. Shadowdraw: real-time
user guidance for freehand drawing. In Proc. SIGGRAPH,
2011. 1, 2

[23] J. Lu, H. Sibai, E. Fabry, and D. Forsyth. No need to
worry about adversarial examples in object detection for au-
tonomous vehicles. CoRR Abs, arXiv:1707.03501, 2017. 1

[24] S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and P. Frossard.
Universal adversarial perturbations. In Proc. CVPR, 2017. 1,
2

[25] Yonggang Qi, Yi-Zhe Song, Honggang Zhang, and Jun Liu.
Sketch-based image retrieval via siamese convolutional neu-
ral network. In Proc. ICIP, pages 2460–2464. IEEE, 2016.
2

[26] Filip Radenovi´c, Giorgos Tolias, and Ondˇrej Chum. CNN
image retrieval learns from BoW: Unsupervised ﬁne-tuning
with hard examples. In Proc. ECCV, pages 3–20, 2016. 1, 2
[27] F. Radenovic, G. Tolias, and O. Chum. Deep shape matching.

In Proc. ECCV, 2018. 2

[28] Patsorn Sangkloy, Nathan Burnell, Cusuh Ham, and James
Hays. The sketchy database: Learning to retrieve badly drawn
bunnies. In Proc. ACM SIGGRAPH, 2016. 2, 6, 7, 8

[29] L. Setia, J. Ick, H. Burkhardt, and A. I. Features. Svm-based
relevance feedback in image retrieval using invariant feature
histograms. In Proc. ACM Multimedia, 2005. 2

[30] J. Sivic and A. Zisserman. Video google: A text retrieval
approach to object matching in videos. In Proc. ICCV, 2003.
2

[31] W. Student. The probable error of a mean. Biometrika, 6:1–

25, 1908. 8

[32] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet,
Scott Reed, Dragomir Anguelov, Vincent Vanhoucke, and An-
drew Rabinovich. Going deeper with convolutions. In Proc.
CVPR, 2015. 4

[33] G. Tolias and O. Chum. Asymmetric feature maps with ap-

plication to sketch based retrieval. In Proc. CVPR, 2017. 2

[34] Fang Wang, Le Kang, and Yi Li. Sketch-based 3d shape
retrieval using convolutional neural networks. In Proc. CVPR,
pages 1875–1883, 2015. 2

[35] Jiang Wang, Yang Song, Thomas Leung, Chuck Rosenberg,
Jingbin Wang, James Philbin, Bo Chen, and Ying Wu. Learn-
ing ﬁne-grained image similarity with deep ranking. In Proc.
CVPR, pages 1386–1393, 2014. 2

[36] M. Wilber, C. Fang, H. Jin, A. Hertzmann, J. Collomosse,
and S. Belongie. Bam! the behance artistic media dataset for
recognition beyond photography. In Proc. ICCV, 2017. 2

[37] P. Xu, Y. Huang, T. Yuan, K. Pang, Y-Z. Song, T. Xiang, and
T. Hospedales. Sketchmate: Deep hashing for million-scale
human sketch retrieval. In Proc. CVPR, 2018. 2

[38] Qian Yu, Feng Liu, Yi-Zhe Song, Tao Xiang, Timothy M
Hospedales, and Chen-Change Loy. Sketch me that shoe.
In Proc. CVPR, pages 799–807, 2016. 2

[39] J. Yuan, S. Bhattacharjee, W. Hong, and X. Ruan. Query
adaptive instance search using object sketches. In Proc. ACM
Multimedia, 2016. 2

[40] J-Y. Zhu, Y-J. Lee, and A. Efros. Averageexplorer: Interactive
exploration and alignment of visual data collections. In Proc.
SIGGRAPH, 2014. 2

2887

