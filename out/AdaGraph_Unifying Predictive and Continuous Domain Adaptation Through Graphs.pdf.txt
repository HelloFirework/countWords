AdaGraph: Unifying Predictive and Continuous

Domain Adaptation through Graphs

Massimiliano Mancini1
1Sapienza University of Rome, 2Fondazione Bruno Kessler, 3Mapillary Research,

2, Samuel Rota Bul`o3, Barbara Caputo4

5, Elisa Ricci2

6

,

,

,

4Politecnico di Torino,5Italian Institute of Technology, 6University of Trento

mancini@diag.uniroma1.it,samuel@mapillary.com,barbara.caputo@polito.it,eliricci@fbk.eu

Abstract

The ability to categorize is a cornerstone of visual intel-
ligence, and a key functionality for artiﬁcial, autonomous
visual machines. This problem will never be solved without
algorithms able to adapt and generalize across visual do-
mains. Within the context of domain adaptation and gener-
alization, this paper focuses on the predictive domain adap-
tation scenario, namely the case where no target data are
available and the system has to learn to generalize from
annotated source images plus unlabeled samples with asso-
ciated metadata from auxiliary domains. Our contribution
is the ﬁrst deep architecture that tackles predictive domain
adaptation and is able to leverage information brought
by the auxiliary domains through a graph. Moreover, we
present a simple yet effective strategy that allows us to take
advantage of the incoming target data at test time, in a con-
tinuous domain adaptation scenario. Experiments on three
benchmark databases support the value of our approach.

1. Introduction

Over the past years, deep learning has enabled rapid
progress in many visual recognition tasks, even surpass-
ing human performance [30]. While deep networks exhibit
excellent generalization capabilities, previous studies [8]
demonstrated that their performance drops when test data
signiﬁcantly differ from training samples. In other words
deep models suffer from the domain shift problem, i.e. clas-
siﬁers trained on source data do not perform well when
tested on samples in the target domain. In practice, domain
shift arises in many computer vision tasks, as many factors
(e.g. lighting changes, different view-points, etc.) determine
appearance variations in visual data.

To cope with this, several efforts focused on develop-
ing Domain Adaptation (DA) techniques [33], attempting
to reduce the mismatch between source and target data dis-
tributions to learn accurate prediction models for the tar-
get domain. In the challenging case of unsupervised DA,
only source data are labelled while no annotation is pro-

Figure 1. Predictive Domain Adaptation. During training we have
access to a labeled source domain (yellow block) and a set of un-
labeled auxiliary domains (blue blocks), all with associated meta-
data. At test time, given the metadata corresponding to the un-
known target domain, we predict the parameters associated to
the target model. This predicted model is further reﬁned during
test, while continuously receiving data of the target domain. Best
viewed in color.

vided for target samples. Although it might be reasonable
for some applications to have target samples available dur-
ing training, it is hard to imagine that we can collect data
for every possible target. More realistically, we aim for pre-
diction models which can generalize to new, previously un-
seen target domains. Following this idea, previous studies
proposed the Predictive Domain Adaptation (PDA) scenario
[36], where neither the data, nor the labels from the target
are available during training. Only annotated source sam-
ples are available, together with additional information from
a set of auxiliary domains, in form of unlabeled samples and
associated metadata (e.g. corresponding to the image times-
tamp or to camera pose, etc).

In this paper we introduce a deep architecture for PDA.
Following recent advances in DA [3, 20, 23], we propose
to learn a set of domain-speciﬁc models by considering
a common backbone network with domain-speciﬁc align-
ment layers embedded into it. We also propose to ex-
ploit metadata and auxiliary samples by building a graph
which explicitly describes the dependencies among do-

6568

Target Deep Model Prediction“Rear view”Target MetadataTarget Stream...Target Deep Model RefinementLabeled Source DomainUnlabeled Auxiliar DomainsFront-side view...Rear-side viewFront viewmains. Within the graph, nodes represent domains, while
edges encode relations between domains, imposed by their
metadata. Thanks to this construction, when metadata for
the target domain are available at test time, the domain-
speciﬁc model can be recovered. We further exploit tar-
get data directly at test time by devising an approach for
continuously updating the deep network parameters once
target samples are made available (Figure 1). We demon-
strate the effectiveness of our method with experiments on
three datasets: the Comprehensive Cars (CompCars) [35],
the Century of Portraits [12] and the CarEvolution datasets
[28], showing that our method outperforms state of the art
PDA approaches. Finally, we show that the proposed ap-
proach for continuous updating of the network parameters
can be used for continuous domain adaptation, producing
more accurate predictions than previous methods [14, 19].
Contributions. To summarize, the contributions of this
work are: (i) we propose the ﬁrst deep architecture for ad-
dressing the problem of PDA; (ii) we present a strategy for
injecting metadata information within a deep network archi-
tecture by encoding the relation between different domains
through a graph; (iii) we propose a simple strategy for reﬁn-
ing the predicted target model which exploits the incoming
stream of target data directly at test time.

2. Related Works

Unsupervised Deep Domain Adaptation. Previous
works on deep DA learn domain invariant representations
by exploiting different architectures, such as Convolutional
Neural Networks [21, 32, 10, 3, 20, 9, 1], deep autoencoders
[37] or GANs [31, 15]. Some methods describe source and
target features distributions considering their ﬁrst and sec-
ond order statistics and minimize their distance either deﬁn-
ing an appropriate loss function [21] or deriving some do-
main alignment layers [20, 3, 9]. Other approaches rely on
adversarial loss functions [32, 11] to learn domain agnos-
tic representations. GAN-based techniques [2, 15, 31] for
unsupervised DA focus directly on images and aim at gen-
erating either target-like source images or source-like target
images. Recent works also showed that considering both
the transformation directions is highly beneﬁcial [31].

In many applications multiple source domains may be
available. This fact has motivated the study of multi-source
DA algorithms [34, 23].
In [34] an adversarial learning
framework for multi-source DA is proposed, inspired by
[10]. A similar adversarial strategy is also exploited in [38].
In [23] a deep architecture is proposed to discover multiple
latent source domains in order to improve the classiﬁcation
accuracy on target data.

Our work performs domain adaptation by embedding
into a deep network domain-speciﬁc normalization layers
as in [20, 3, 9, 29]. However, the design of our layers is dif-
ferent as they are required to guarantee a continuous update

of parameters and to exploit information from the domain
graph. Our approach considers information from multiple
domains at training time. However, instead of having la-
beled data from all source domains, we do not have annota-
tions for samples of auxiliary data.

Finally, our work is linked to graph-based domain adap-
tation methods [6, 5]. Differently from these works how-
ever, in our approach a node does not represent a single
sample but a whole domain and edges do not link seman-
tically related samples but domains with related metadata.

Domain Adaptation without Target Data. In some appli-
cations, the assumption that target data are available during
training does not hold. This calls for DA methods able to
cope with the domain shift by exploiting either the stream
of incoming target samples, or side information describing
possible future target domains.

The ﬁrst scenario is typically referred to as continuous
[14] or online DA [22]. To address this problem, in [14]
a manifold-based DA technique is employed to model an
evolving target data distribution. In [19] Li et al. propose
to sequentially update a low-rank exemplar SVM classiﬁer
as data of the target domain becomes available.
In [17],
the authors propose to extrapolate the target data dynamics
within a reproducing kernel Hilbert space.

The second scenario corresponds to the problem of pre-
dictive DA tackled in this paper. PDA is introduced in [36],
where a multivariate regression approach is described for
learning a mapping between domain metadata and points
in a Grassmanian manifold. Given this mapping and the
metadata for the target domain, two different strategies are
proposed to infer the target classiﬁer.

Other closely related tasks are the problems of zero shot
domain adaptation and domain generalization. In zero-shot
domain adaptation (ZDDA) [27] the task is to learn a predic-
tion model in the target domain under the assumption that
task-relevant source-domain data and task-irrelevant dual-
domain paired data are available. We highlight that the PDA
problem is related, but different, from ZDDA. ZDDA as-
sumes that the domain shift is known during training from
the presence of data of a different task but with the same
visual appearance of source and target domains, while in
PDA metadata of auxiliary domains is the only available in-
formation, and the target metadata is received only at test
time. For this reason, ZDDA is not applicable to a PDA
scenario, and it cannot predict the classiﬁcation model for a
target domain given only the metadata.

Domain generalization methods [25, 18, 7, 24] attempt to
learn domain-agnostic classiﬁcation models by exploiting
labeled source samples from multiple domains but without
having access to target data. Similarly to Predictive DA in
domain generalization, multiple datasets are available dur-
ing training. However, in PDA data from auxiliary source
domains are not labeled.

6569

3. Method

3.1. Problem Formulation

Our goal is to produce a model that is able to accomplish
a task in a target domain T for which no data are available
during training, neither labeled nor unlabeled. The only in-
formation we can exploit is a characterization of the content
of the target domain in the form of metadata mT plus a set
of known domains K, each of them having associated meta-
data. All domains in K carry information about the task we
want to accomplish in the target domain. In particular, since
in this work we focus on classiﬁcation tasks, we assume that
images from the domains in K and T can be classiﬁed with
semantic labels from a same set Y. As opposed to standard
DA scenarios, the target domain T does not necessarily be-
long to the set of known domains K. Also, we assume that
K can be partitioned into a labeled source domain S and N
unlabeled auxiliary domains A = {A1, · · · , AN }.

In the speciﬁc,

this paper focuses on predictive DA
(PDA) problems aimed at regressing the target model pa-
rameters using data from the domains in K. We achieve
this objective by (i) interconnecting each domain in K using
the given domain metadata; (ii) building domain-speciﬁc
models from the data available in each domain in K; (iii)
exploiting the connection between the target domain and
the domains in K, inferred from the respective metadata,
to regress the model for T .

A schematic representation of the method is shown in
Figure 2. We propose to use a graph because of its seamless
ability to encode relationships within a set of elements (do-
mains in our case). Moreover, it can be easily manipulated
to include novel elements (such as the target domain T ).

3.2. AdaGraph: Graph based Predictive DA

We model the dependencies between the various do-
mains by instantiating a graph composed of nodes and
edges. Each node represents a different domain and each
edge measures the relatedness of two domains. Each edge
of the graph is weighted, and the strength of the connec-
tion is computed as a function of the domain-speciﬁc meta-
data. At the same time, in order to extract one model for
each available domain, we employ recent advances in do-
main adaptation involving the use of domain-speciﬁc batch-
normalization layers [20, 4]. With the domain-speciﬁc
models and the graph we are able to predict the parameters
for a novel domain that lacks data by simply (i) instantiating
a new node in the graph and (ii) propagating the parameters
from nearby nodes, exploiting the graph connections.

Connecting domains through a graph. Let us denote the
space of domains as D and the space of metadata as M. As
stated in Section 3.1, in the PDA scenario, we have a set
of known domains K = {k1, · · · , kn} ⊂ D and a bijective
mapping φ : D 7→ M relating domains and metadata. For
simplicity, we regard as unknown some metadata m that is

not associated to domains in K, i.e. such that φ−1(m) /∈ K.
In this work we structure the domains as a graph G =
(V, E), where V ⊂ D represents the set of vertices corre-
sponding to domains and E ⊆ V × V the set of edges, i.e.
relations between domains. Initially the graph contains only
the known domains so V = K. In addition, we deﬁne an
edge weight ω : E → R that measures the relation strength
between two domains (v1, v2) ∈ E by computing a distance
between the respective metadata, i.e.

ω(v1, v2) = e−d(φ(v1),φ(v2)) ,

(1)

where d : M2 → R is a distance function on M.

Let Θ be the space of possible model parameters and
assume we have properly exploited the domain data from
each domain in k ∈ K to learn a set of domain-speciﬁc
models (we will detail this procedure in the next subsec-
tion). We can then deﬁne a mapping ψ : K 7→ Θ, relating
each domain to its set of domain-speciﬁc parameters. Given
some metadata m ∈ M we can recover an associated set
of parameters via the mapping ψ ◦ φ−1(m) provided that
φ−1(m) ∈ K. In order to deal with metadata that is un-
known, we introduce the concept of virtual node. Basically,
a virtual node ˜v ∈ V is a domain for which no data are
available but we have metadata ˜m associated to it, namely
˜m = φ(˜v). For simplicity, let us directly consider the target
domain T . We have T ∈ D and we know φ(T ) = mT .
Since no data of T are available, we have no parameters
that can be directly assigned to the domain. However, we
can estimate parameters for T by using the domain graph
G. Indeed, we can relate T to other domains v ∈ V using
ω(T , v) deﬁned in (1) by opportunely extending E with new
edges (T , v) for all or some v ∈ V (e.g. we could connect
all v that satisfy ω(T , v) > τ for some τ ). The extended
graph G′ = (V ∪ {T }, E ′) with the additional node T and
the new edge set E ′ can then be exploited to estimate pa-
rameters for T by propagating the model parameters from
nearby domains. Formally we regress the parameters ˆθT
through

ˆθT = ψ(T ) = P(T ,v)∈E ′ ω(T , v)ψ(v)

P(T ,v)∈E ′ ω(T , v)

,

(2)

where we normalize the contribution of each edge by the
sum of the weights of the edges connecting node T . With
this formula we are able to provide model parameters for the
target domain T and, in general, for any unknown domain
by just exploiting the corresponding metadata.

We want to highlight that this strategy simply requires
extending the graph with a virtual node ˜v and computing the
relative edges. While the relations of ˜v with other domains
can be inferred from given metadata, as in (1), there could
be cases in which no metadata are available for the target
domain. In such situations, we can still exploit the incom-
ing target image x to build a probability distribution over

6570

nodes in V, in order to assign the new data point to a mix-
ture of known domains. To this end, let use deﬁne p(v|x)
the conditional probability of an image x ∈ X , where X
is the image space, to be associated with a domain v ∈ V.
From this probability distribution, we can infer the parame-
ters of a classiﬁcation model for x through:

ˆθx = X

v∈V

p(v|x) · ψ(v)

(3)

where ψ(v) is well-deﬁned for each node linked to a known
domain, while it must be estimated with (2) for each virtual
domain ˜v ∈ V for which p(˜v|x) > 0.

In practice, the probability p(v|x) is constructed from a
metadata classiﬁer f m, trained on the available data, that
provides a probability distribution over M given x, which
can be turned into a probability over D through the inverse
mapping φ−1.

Extracting node speciﬁc models. We have described how
to regress model parameters for an unknown domain by
exploiting the domain graph. Now, we focus on the ac-
tual problem of training domain-speciﬁc models using data
available from the known domains K. Since K entails a la-
beled source domain S and a set of auxiliary domains A,
we cannot simply train independent models with data from
each available domain due to the lack of supervision on do-
mains in A for the target classiﬁcation task. For this reason,
we need to estimate the model parameters for the unlabeled
domains A by exploiting DA techniques.

Recent works [20, 3, 4] have shown the effectiveness of
applying domain-speciﬁc batch-normalization (DABN) lay-
ers to address domain adaptation tasks. In particular, these
works rewrite each batch-normalization layer [16] (BN) of
the network in order to take into account domain-speciﬁc
statistics. Given a domain k, a DABN layer differs from
standard BN by including domain-speciﬁc information:

DABN(x, k) = γ ·

x − µk
pσ2
k + ǫ

+ β ,

(4)

where the mean and variance statistics {µk, σk} are esti-
mated from x conditioned on domain k, γ and β are learn-
able scale and bias parameters, respectively, and ǫ is a small
constant used to avoid numerical instabilities. Notice that
we have dropped the dependencies on spatial location and
channel dimension for simplicity. The effectiveness of this
simple DA approach is due to the fact that features of source
and target domains are forced to be aligned to the same ref-
erence distribution, and this allows to implicitly address the
domain shift problem.

In this work we exploit the same ideas to provide each
node in the graph with its own BN statistics. At the same
time, we depart from [20, 4] since we do not keep scale and
bias parameters shared across the domains, but we include
also them within the set of domain-speciﬁc parameters.

In this scenario, the set of parameters for a domain k
ψ(k) = θk is composed of different parts. Formally for
each domain we have ψ(k) = {θa, θs
k}, where θa holds the
domain-agnostic components and θs
k the domain-speciﬁc
ones. In our case θa comprises parameters from standard
layers (i.e. the convolutional and fully connected layers of
the architecture), while θs
k comprises parameters and statis-
tics of the domain-speciﬁc BN layers.

We start by using the labeled source domain S to esti-
S . In particular, we obtain θS by

mate θa and initialize θs
minimizing the standard cross-entropy loss:

L(θS ) = −

1
|S| X

(x,y)∈S

log(fθS (y; x)) ,

(5)

where fθS is the classiﬁcation model relative to the source
domain, with parameters θS .

To extract the domain-speciﬁc parameters θs

k for each
k ∈ K, we employ 2 steps: the ﬁrst is a selective forward
pass for estimating the domain-speciﬁc statistics while the
second is the application of a loss to further reﬁne the scale
and bias parameters. Formally, we replace each BN layer in
the network with a GraphBN counterpart (GBN), where the
forward pass is deﬁned as follows:

GBN(x, v) = γv ·

x − µv
pσ2
v + ǫ

+ βv .

(6)

Basically in a GBN layer, the set of BN parameters and
statistics to apply is conditioned on the node/domain to
which x belongs. During training, as for standard BN, we
update the statistics by leveraging their estimate obtained
from the current batch B:

ˆµv =

1
|Bv| X

x∈Bv

x and

ˆσ2
v =

1
|Bv| X

x∈Bv

(x − µv)2 , (7)

where Bv is the set of elements in the batch belonging to
domain v. As for the scale and bias parameters, we opti-
mize them by means of a loss on the model output. For
the auxiliary domains, since the data are unlabeled, we use
an entropy loss, while a cross-entropy loss is used for the
source domain:

L(Θs) = −

−λ · X

Ai∈A

(x,y)∈S

1
|S| X
1
|Ai| X

x∈Ai

y∈Y

log(fθS (y; x))

(8)

X

fθAi (y; x) log (cid:0)fθAi (y; x)(cid:1) ,

where Θs = {θs
k | k ∈ K} represents the whole set of
domain-speciﬁc parameters and λ is the trade off between
the cross-entropy and the entropy loss.

While (8) allows to optimize the domain-speciﬁc scale
and bias parameters, it does not take into account the pres-
ence of the relationship between the domains, as imposed

6571

Figure 2. AdaGraph framework (Best viewed in color). Each BN layer is replaced by its GBN counterpart. The parameters used in a GBN
layer are computed from a given metadata and the graph. Each domain in the graph (circles) contains its speciﬁc parameters (rectangular
blocks). During the training phase (blue part), a metadata (i.e. mz, blue block) is mapped to its domain (z). While the statistics of GBN are
determined only by the one of z (θz), scale and bias are computed considering also the graph edges. During test, we receive the metadata
for the target domain (mT , red block) to which no node is linked. Thus we initialize T and we compute its parameters and statistics
exploiting the connection with the other nodes in the graph (θT ).

by the graph. A way to include the graph within the opti-
mization procedure is to modify (6) as follows:

3.3. Model Reﬁnement through Joint Prediction

and Adaptation

GBN(x, v, G) = γG

v ·

x − µv
pσ2
v + ǫ

+ βG
v ,

(9)

where we have

v = Pk∈K ω(v, k) · νk
ν G
Pk∈K ω(v, k)

,

(10)

for ν ∈ {β, γ}. Basically, we use scale and bias parameters
during the forward pass which are inﬂuenced by the graph
edges, as described in (10).

Taking into account the presence of G during the forward
pass is beneﬁcial for mainly two reasons. First, it allows to
keep a consistency between how those parameters are com-
puted at test time and how they are used at training time.
Second, it allows to regularize the optimization of γv and
βv, which may be beneﬁcial in cases where a domain con-
tains few data. While the same procedure may be applied
also for µv, σv, in our current design we avoid mixing them
during training. This choice is related to the fact that each
image belongs to a single domain and keeping the statistics
separate allows to estimate them more precisely.

At test time, we initialize the domain-speciﬁc statistics
and parameters of T given metadata mT using (2), com-
puting the forward pass of each GBN through (9).
If no
metadata are available, we compute the statistics and pa-
rameters through (3), performing the forward pass through
(6).
In Figure 2, we sketch the behaviour of our method
given mT both at training and test time.

The approach described in the previous section allows
to instantiate GBN parameters and statistics for a novel do-
main T given the target metadata mT . However, without
any sample of T , we have no way to assess how well the es-
timated statistics and parameters approximate the real ones
of the target domain. This implies that we do not have the
possibility to correct the parameters from a wrong initial es-
timates, a problem which may occur e.g. if we have noisy
metadata. A possible strategy to solve this issue is to exploit
the images we receive at test time to reﬁne the GBN layers.
To this extent, we propose a simple strategy for performing
continuous domain adaptation [14] within AdaGraph.

Formally, let us deﬁne as XT = {x1, · · · , xT } the set
of images of T that we receive at test time. Without loss
of generality, we assume that the images of XT are pro-
cessed sequentially, one by one. Given the sequence XT ,
our goal is to reﬁne the statistics {µT , σT } and the pa-
rameters {γT , βT } of each GBN layer as new data arrives.
Following recent works [22, 20], we continuously adapt a
model to the target domain by feeding as input to the net-
work batches of target images, updating the statistics as in
standard BN. In order to achieve this, we store target sam-
ples in a buffer M . The buffer M has a ﬁxed size and stores
the samples one by one. Exploiting the buffer, we update
the target statistics as follows:

µT ←− (1 − α) · µT + α · µM

σ2
T ←− (1 − α) · σ2

T + α ·

|M |

|M | − 1

· σ2

M ,

(11)

where {µM , σM } are computed through (7), replacing Bv

6572

ConvGBNFCConvGBNConvGBNConvGBNAdaGraphmzm𝓣Known Metadata (Training)UnknownMetadata (Test)φ-1(ṽ)φ-1(z)Domain Specific ParamsConvGBNwith M :

µM =

1
|M | X

x∈M

x and σ2

M =

1
|M | X

x∈M

(x−µM )2. (12)

While this allows to update the statistics, using (11) does
not produce any reﬁnement on {γT , βT }. To this extent, we
can easily employ the entropy term in (8):

L(θT ) = −

1
|M | X

x∈M

X

y∈Y

fθT (y; x) log (cid:0)fθT (y; x)(cid:1). (13)

To summarize, with (11) and (13) we deﬁne a simple
reﬁnement procedure for AdaGraph which allows to re-
cover from bad initialization of the predicted parameters
and statistics. The update of statistics and parameters is
performed together, each time the buffer is full. To avoid
producing a bias during the reﬁnement, we clear the buffer
after each update step.

4. Experiments

4.1. Experimental setting

Datasets. We analyze the performance of our approach on
three datasets: the Comprehensive Cars (CompCars) [35],
the Century of Portraits [12] and the CarEvolution [28].

The Comprehensive Cars (CompCars) [35] dataset is
a large-scale database composed of 136,726 images span-
ning a time range between 2004 and 2015. As in [36], we
use a subset of 24,151 images with 4 types of cars (MPV,
SUV, sedan and hatchback) produced between 2009
and 2014 and taken under 5 different view points (front,
front-side, side, rear, rear-side). Considering each view
point and each manufacturing year as a separate domain
we have a total of 30 domains. As in [36] we use a PDA
setting where 1 domain is considered as source, 1 as target
and the remaining 28 as auxiliary sets, for a total of 870 ex-
periments. In this scenario, the metadata are represented as
vectors of two elements, one corresponding to the year and
the other to the view point, encoding the latter as in [36].

Century of Portraits (Portraits) [12] is a large scale col-
lection of images taken from American high school year-
books. The portraits are taken over 108 years (1905-2013)
across 26 states. We employ this dataset in a gender clas-
siﬁcation task, in two different settings. In the ﬁrst setting
we test our PDA model in a leave-one-out scenario, with a
similar protocol to the tests on the CompCars dataset. In
particular, to deﬁne domains we consider spatio-temporal
information and we cluster images according to decades
and to spatial regions (we use 6 USA regions, as deﬁned
in [12]). Filtering out the sets where there are less than 150
images, we obtain 40 domains, corresponding to 8 decades
(from 1934 on) and 5 regions (New England, Mid Atlantic,
Mid West, Paciﬁc, Southern). We follow the same experi-
mental protocol of the CompCars experiments, i.e. we use

one domain as source, one as target and the remaining 38 as
auxiliaries. We encode the domain metadata as a vector of
3 elements, denoting the decade, the latitude (0 or 1, indi-
cating north/south) and the east-west location (from 0 to 3),
respectively. Additional details can be found in the supple-
mentary material. In a second scenario, we use this dataset
for assessing the performance of our continuous reﬁnement
strategy. In this case we employ all the portraits before 1950
as source samples and those after 1950 as target data.

CarEvolution [35] is composed of car images collected
between 1972 and 2013. It contains 1008 images of cars
produced by three different manufacturers with two car
models each, following the evolution of the production of
those models during the years. We choose this dataset in
order to assess the effectiveness of our continuous domain
adaptation strategy. A similar evaluation has been employed
in recent works considering online DA [19]. As in [19], we
consider the task of manufacturer prediction where there are
three categories: Mercedes, BMW and Volkswagen. Im-
ages of cars before 1980 are considered as the source set and
the remaining are used as target samples.

Networks and Training Protocols. To analyze the im-
pact on performance of our main contributions we consider
the ResNet-18 architecture [13] and perform experiments
on the Portraits dataset. In particular, we apply our model
by replacing each BN layer with its AdaGraph counterpart.
We start with the network pretrained on ImageNet, training
it for 1 epoch on the source dataset, employing Adam as
optimizer with a weight decay of 10−6 and a batch-size of
16. We choose a learning rate of 10−3 for the classiﬁer and
10−4 for the rest of the architecture. We train the network
for 1 epoch on the union of source and auxiliary domains to
extract domain-speciﬁc parameters. We keep the same op-
timizer and hyper-parameters except for the learning rates,
decayed by a factor of 10. The batch size is kept to 16,
but each batch is composed by elements of a single pair
year-region belonging to one of the available domains (ei-
ther auxiliary or source). The order of the pairs is randomly
sampled within the set of allowed ones.

In order to fairly compare with previous methods we
also consider Decaf features [8]. In particular, in the ex-
periments on the CompCars dataset, we use Decaf features
extracted at the fc7 layer. Similarly, for the experiments
on CarEvolution, we follow [19] and use Decaf features ex-
tracted at the fc6 layer. In both cases, we apply our model
by adding either a BN layer or our AdaGraph approach di-
rectly to the features, followed by a ReLU activation and a
linear classiﬁer. For these experiments we train the model
on the source domain for 10 epochs using Adam as opti-
mizer with a learning rate of 10−3, a batch-size of 16 and
a weight decay of 10−6. The learning rate is decayed by a
factor of 10 after 7 epochs. For CompCars, when training
with the auxiliary set, we use the same optimizer, batch size

6573

and weight decay, with a learning rate 10−4 for 1 epoch.
Domain-speciﬁc batches are randomly sampled, as for the
experiments on Portraits.

2·σ ·||x−y||2

For all the experiments we use as distance measure
d(x, y) = 1
2 with σ = 0.1 and set λ equal to 1.0,
both in the training and in the reﬁnement stage. At test time,
we classify each input image as it arrives, performing the
reﬁnement step after the classiﬁcation. The buffer size in
the reﬁnement phase is equal to 16 and we set α = 0.1, the
same used for updating the GBN components while training
with the auxiliar domains.

We implemented1 our method with the PyTorch [26]
framework and our evaluation is performed using a
NVIDIA GeForce 1080 Ti GTX GPU.

4.2. Results

In this section we report the results of our evaluation,
showing both an empirical analysis of the proposed contri-
butions and a comparison with state of the art approaches.
Analysis of AdaGraph. We ﬁrst analyze the performance
of our approach by employing the Portraits dataset. In par-
ticular, we evaluate the impact of (i) introducing a graph
to predict the target domain BN statistics (AdaGraph BN),
(ii) adding scale and bias parameters trained in isolation
(AdaGraph SB) or jointly (AdaGraph Full) and (iii) adopt-
ing the proposed reﬁnement strategy (AdaGraph + Reﬁne-
ment). As baseline2 we consider the model trained only on
the source domain and, as an upper bound, a corresponding
DA method which is allowed to use target data during train-
ing. In our case, the upper bound corresponds to a model
similar to the method proposed in [3].

The results of our ablation are reported in Table 1, where
we report the average classiﬁcation accuracy correspond-
ing to two scenarios: across decades (considering the same
region for source and target domains) and across regions
(considering the same decade for source and target dataset).
The ﬁrst scenario corresponds to 280 experiments, while
the second to 160 tests. As shown in the table, by simply
replacing the statistics of BN layers of the source model
with those predicted through our graph a large boost in ac-
curacy is achieved (+4% in the across decades scenario and
+2.4% in the across regions one). At the same time, esti-
mating the scale and bias parameters without considering
the graph is suboptimal. In fact there is a misalignment be-
tween the forward pass of the training phase (i.e. consider-
ing only domain-speciﬁc parameters) and how these param-
eters will be combined at test time (i.e. considering also the
connection with the other nodes of the graph). Interestingly,
in the across regions setting, our full model slightly drops in
performance with respect to predicting only the BN statis-

1The

at
mancinimassimiliano/adagraph

available

code

is

https://github.com/

2We do not report the results of previous approaches [36] since the code

is not publicly available.

Table 1. Portraits dataset. Ablation study.

Method
Baseline
AdaGraph BN
AdaGraph SB
AdaGraph Full
Baseline + Reﬁnement
AdaGraph + Reﬁnement

DA upper bound

Across Decades Across Regions

82.3
86.3
86.0
87.0
86.2
88.6

89.1

89.2
91.6
90.5
91.0
91.3
91.9

92.1

tics. This is probably due to how regions are encoded in the
metadata (i.e. considering geographical location), making
it difﬁcult to capture factors (e.g. cultural, historical) which
can be more discriminative to characterize the population of
a region or a state. However, as stated in Section 3.3, em-
ploying a continuous reﬁnement strategy allows the method
to compensate for prediction errors. As shown in Table 1,
with a reﬁnement step (AdaGraph + Reﬁnement) the accu-
racy constantly increases, ﬁlling the gap between the per-
formance of the initial model and our DA upper bound.

It is worth noting that applying the reﬁnement procedure
to the source model (Baseline + Reﬁnement) leads to bet-
ter performance (about +4% in the across decades scenario
and +2.1% for across regions one). More importantly, the
performance of the Baseline + Reﬁnement method is always
worse than what obtained by AdaGraph + Reﬁnement, be-
cause our model provides, on average, a better starting point
for the reﬁnement procedure.

Figure 3 shows the results associated to the across
decades scenario. Each bar plot corresponds to experiments
where the target domain is associated to a speciﬁc year. As
shown in the ﬁgure, on average, our full model outperforms
both AdaGraph BN and AdaGraph SB, showing the bene-
ﬁt of the proposed graph strategy. The results in the ﬁgure
clearly also show that our reﬁnement strategy always leads
to a boost in performance.
Comparison with the state of the art. Here we compare
the performances of our model with state of the art PDA
approaches. We use the CompCars dataset and we bench-
mark against the Multivariate Regression (MRG) methods
proposed in [36].

We apply our model in the same setting as [36] and per-
form 870 different experiments, computing the average ac-
curacy (Table 2). Our model outperforms the two meth-
ods proposed in [36] by improving the performances of the
Baseline network by 4%. AdaGraph alone outperforms the
Baseline model when it is updated with our reﬁnement strat-
egy and target data (Baseline + Reﬁnement). When coupled
with a reﬁnement strategy, our graph-based model further
improves the performances, ﬁlling the gap between Ada-
Graph and our DA upper bound. It is interesting to note that
our model is also effective when there are no metadata avail-
able in the target domain. In the table, AdaGraph (images)
corresponds to our approach when, instead of initializing
the BN layer for the target exploiting metadata, we employ

6574

Figure 3. Portraits dataset: comparison of different models in the PDA scenario with respect to the average accuracy on a target decade,
ﬁxed the same region of source and target domains. The models are based on ResNet-18.

Table 2. CompCars dataset [35]. Comparison with state of the art.

Table 3. CarEvolution [28]: comparison with state of the art.

Method
Baseline [36]
Baseline + BN
MRG-Direct [36]
MRG-Indirect [36]
AdaGraph (metadata)
AdaGraph (images)
Baseline + Reﬁnement
AdaGraph + Reﬁnement

DA upper bound

Avg. Accuracy

54.0
56.1
58.1
58.2
60.1
60.8
59.5
60.9

60.9

the current input image and a domain classiﬁer to obtain a
probability distribution over the graph nodes, as described
in Section 3.2. The results in the Table show that AdaGraph
(images) is more accurate than AdaGraph (metadata).

Exploiting AdaGraph Reﬁnement for Continous Do-
main Adaptation. In Section 3.3, we have shown a way
to boost the performances of our model by leveraging the
stream of incoming target data and reﬁne the estimates of
the target BN statistics and parameters. Throughout the
experimental section, we have also demonstrated how this
strategy improves the target classiﬁcation model, with per-
formances close to DA methods which exploit target data
during training.

In this section we show how this approach can be em-
ployed as a competitive method in the case of continu-
ous domain adaptation [14]. We consider the CarEvolu-
tion dataset and compare the performances of our proposed
strategy with two state of the art algorithms: the manifold-
based adaptation method in [14] and the low-rank SVM
strategy presented in [19]. As in [19] and [14], we apply
our adaptation strategy after classifying each novel image
and compute the overall accuracy. The images of the target
domain are presented to the network in a chronological or-
der i.e. from 1980 to 2013. The results are shown in Table
3. While the integration of a BN layer alone leads to bet-
ter performances over the baseline, our reﬁnement strategy
produces an additional boost of about 3%. If scale and bias
parameters are reﬁned considering the entropy loss, accu-
racy further increases.

We also test the proposed model on a similar task con-

Method
Baseline SVM [19]
Baseline + BN
CMA+GFK [14]
CMA+SA [14]
LLRESVM [19]
LLRESVM+EDA[19]
Baseline + Reﬁnement Stats
Baseline + Reﬁnement Full

Accuracy

39.7
43.7
43.0
42.7
43.6
44.3
46.5
47.3

Table 4. Portraits dataset [35]: performances of the reﬁnement
strategy on the continuous adaptation scenario

Method
Accuracy

Baseline Reﬁnement Stats Reﬁnement Full

81.9

87.3

88.1

sidering the Portraits dataset. The results of our experiments
are shown in Table 4. Similarly to what observed on the pre-
vious experiments, continuously adapting our deep model
as target data become available leads to better performance
with respect to the baseline. The reﬁnement of scale and
bias parameters contributes to a further boost in accuracy.

5. Conclusions

We present the ﬁrst deep architecture for Predictive Do-
main Adaptation. We leverage metadata information to
build a graph where each node represents a domain, while
the strength of an edge models the similarity among two do-
mains according to their metadata. We then propose to ex-
ploit the graph for the purpose of DA and we design novel
domain-alignment layers. This framework yields the new
state of the art on standard PDA benchmarks. We further
present an approach to exploit the stream of incoming tar-
get data such as to reﬁne the target model. We show that
this strategy itself is also an effective method for continu-
ous DA, outperforming state of the art approaches. Future
works will explore methodologies to incrementally update
the graph and to automatically infer relations among do-
mains, even in the absence of metadata.

Acknowledgements. We acknowledge ﬁnancial support from
ERC grant 637076 - RoboExNovo and project DIGIMAP, grant
860375, funded by the Austrian Research Promotion Agency
(FFG). This work was carried out under the ”Vision and Learn-
ing joint Laboratory” between FBK and UNITN.

6575

References

[1] Gabriele Angeletti, Barbara Caputo, and Tatiana Tommasi.
Adaptive deep learning through visual domain localization.
In ICRA, 2018. 2

[2] Konstantinos Bousmalis, George Trigeorgis, Nathan Silber-
man, Dilip Krishnan, and Dumitru Erhan. Domain separa-
tion networks. In NIPS, 2016. 2

[3] Fabio Maria Carlucci, Lorenzo Porzi, Barbara Caputo, Elisa
Ricci, and Samuel Rota Bul`o. Autodial: Automatic domain
alignment layers. In ICCV, 2017. 1, 2, 4, 7

[4] Fabio Maria Carlucci, Lorenzo Porzi, Barbara Caputo, Elisa
Ricci, and Samuel Rota Bul`o. Just dial: Domain alignment
layers for unsupervised domain adaptation. In ICIAP, 2017.
3, 4

[5] Debasmit Das and C. S. George Lee. Graph matching and
pseudo-label guided deep unsupervised domain adaptation.
In ICANN, 2018. 2

[6] Zhengming Ding, Sheng Li, Ming Shao, and Yun Fu. Graph
adaptive knowledge transfer for unsupervised domain adap-
tation. In ECCV, 2018. 2

[7] Antonio D’Innocente and Barbara Caputo. Domain general-
ization with domain-speciﬁc aggregation modules. In GCPR,
2018. 2

[8] Jeff Donahue, Yangqing Jia, Oriol Vinyals, Judy Hoffman,
Ning Zhang, Eric Tzeng, and Trevor Darrell. Decaf: A deep
convolutional activation feature for generic visual recogni-
tion. In ICML, 2014. 1, 6

[9] Geoff French, Michal Mackiewicz, and Mark Fisher. Self-

ensembling for visual domain adaptation. ICLR, 2018. 2

[10] Yaroslav Ganin and Victor Lempitsky. Unsupervised domain

adaptation by backpropagation. ICML, 2015. 2

[11] Yaroslav Ganin, Evgeniya Ustinova, Hana Ajakan, Pas-
cal Germain, Hugo Larochelle, Franc¸ois Laviolette, Mario
Marchand, and Victor Lempitsky. Domain-adversarial train-
ing of neural networks. JMLR, 17(59):1–35, 2016. 2

[12] Shiry Ginosar, Kate Rakelly, Sarah Sachs, Brian Yin, and
Alexei A Efros. A century of portraits: A visual histori-
cal record of american high school yearbooks. In ICCV-WS,
2015. 2, 6

[13] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
In CVPR,

Deep residual learning for image recognition.
2016. 6

[14] Judy Hoffman, Trevor Darrell, and Kate Saenko. Continuous
manifold based adaptation for evolving visual domains. In
CVPR, 2014. 2, 5, 8

[15] Judy Hoffman, Eric Tzeng, Taesung Park, Jun-Yan Zhu,
Phillip Isola, Kate Saenko, Alexei A Efros, and Trevor Dar-
rell. Cycada: Cycle-consistent adversarial domain adapta-
tion. In ICML, 2018. 2

[16] Sergey Ioffe and Christian Szegedy. Batch normalization:
Accelerating deep network training by reducing internal co-
variate shift. In ICML, 2015. 4

[17] Christoph H Lampert. Predicting the future behavior of a

time-varying probability distribution. In CVPR, 2015. 2

[19] Wen Li, Zheng Xu, Dong Xu, Dengxin Dai, and Luc
Van Gool. Domain generalization and adaptation using low
rank exemplar svms. IEEE T-PAMI, 40(5):1114–1127, 2018.
2, 6, 8

[20] Yanghao Li, Naiyan Wang, Jianping Shi, Xiaodi Hou, and
Jiaying Liu. Adaptive batch normalization for practical do-
main adaptation. Pattern Recognition, 80:109–117, 2018. 1,
2, 3, 4, 5

[21] Mingsheng Long and Jianmin Wang. Learning transferable

features with deep adaptation networks. In ICML, 2015. 2

[22] Massimiliano Mancini, Hakan Karaoguz, Elisa Ricci, Patric
Jensfelt, and Barbara Caputo. Kitting in the wild through
online domain adaptation. IROS, 2018. 2, 5

[23] Massimiliano Mancini, Lorenzo Porzi, Samuel Rota Bul`o,
Barbara Caputo, and Elisa Ricci. Boosting domain adapta-
tion by discovering latent domains. CVPR, 2018. 1, 2

[24] Saeid Motiian, Marco Piccirilli, Donald A. Adjeroh, and Gi-
anfranco Doretto. Uniﬁed deep supervised domain adapta-
tion and generalization. In ICCV, 2017. 2
[25] Krikamol Muandet, David Balduzzi,

and Bernhard
Sch¨olkopf. Domain generalization via invariant feature
representation. In ICML, 2013. 2

[26] Adam Paszke, Sam Gross, Soumith Chintala, Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Al-
ban Desmaison, Luca Antiga, and Adam Lerer. Automatic
differentiation in pytorch. In NIPS-WS, 2017. 7

[27] Kuan-Chuan Peng, Ziyan Wu, and Jan Ernst. Zero-shot deep

domain adaptation. In ECCV, 2018. 2

[28] Konstantinos Rematas, Basura Fernando, Tatiana Tommasi,
and Tinne Tuytelaars. Does evolution cause a domain shift?,
2013. 2, 6, 8

[29] Subhankar Roy, Aliaksandr Siarohin, Enver Sangineto,
Samuel Rota Bulo, Nicu Sebe, and Elisa Ricci. Unsuper-
vised domain adaptation using feature-whitening and con-
sensus loss. In CVPR, June 2019. 2

[30] Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, San-
jeev Satheesh, Sean Ma, Zhiheng Huang, Andrej Karpathy,
Aditya Khosla, Michael Bernstein, Alexander C. Berg, and
Li Fei-Fei. ImageNet Large Scale Visual Recognition Chal-
lenge. IJCV, 115(3):211–252, 2015. 1

[31] Paolo Russo, Fabio Maria Carlucci, Tatiana Tommasi, and
Barbara Caputo. From source to target and back: symmetric
bi-directional adaptive gan. In CVPR, 2018. 2

[32] Eric Tzeng, Judy Hoffman, Trevor Darrell, and Kate Saenko.
In

Simultaneous deep transfer across domains and tasks.
ICCV, 2015. 2

[33] Mei Wang and Weihong Deng. Deep visual domain adapta-

tion: A survey. Neurocomputing, 2018. 1

[34] Ruijia Xu, Ziliang Chen, Wangmeng Zuo, Junjie Yan, and
Liang Lin. Deep cocktail network: Multi-source unsuper-
vised domain adaptation with category shift. In CVPR, 2018.
2

[35] Linjie Yang, Ping Luo, Chen Change Loy, and Xiaoou Tang.
A large-scale car dataset for ﬁne-grained categorization and
veriﬁcation. In CVPR, 2015. 2, 6, 8

[18] Da Li, Yongxin Yang, Yi-Zhe Song, and Timothy M
Hospedales. Deeper, broader and artier domain generaliza-
tion. In ICCV, 2017. 2

[36] Yongxin Yang and Timothy M Hospedales. Multivariate re-
gression on the grassmannian for predicting novel domains.
In CVPR, 2016. 1, 2, 6, 7, 8

6576

[37] Xingyu Zeng, Wanli Ouyang, Meng Wang, and Xiaogang
Wang. Deep learning of scene-speciﬁc classiﬁer for pedes-
trian detection. In ECCV, 2014. 2

[38] Han Zhao, Shanghang Zhang, Guanhang Wu,

Jo ao
P. Costeira, Jos´e M. F. Moura, and Geoffrey J. Gordon. Mul-
tiple source domain adaptation with adversarial learning. In
ICLR-WS, 2018. 2

6577

