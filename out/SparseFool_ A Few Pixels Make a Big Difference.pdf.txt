SparseFool: a few pixels make a big difference

Apostolos Modas, Seyed-Mohsen Moosavi-Dezfooli, Pascal Frossard

´Ecole Polytechnique F´ed´erale de Lausanne

{apostolos.modas, seyed.moosavi, pascal.frossard}@epfl.ch

Abstract

Deep Neural Networks have achieved extraordinary re-
sults on image classiﬁcation tasks, but have been shown to
be vulnerable to attacks with carefully crafted perturbations
of the input data. Although most attacks usually change val-
ues of many image’s pixels, it has been shown that deep net-
works are also vulnerable to sparse alterations of the input.
However, no computationally efﬁcient method has been pro-
posed to compute sparse perturbations. In this paper, we
exploit the low mean curvature of the decision boundary,
and propose SparseFool, a geometry inspired sparse attack
that controls the sparsity of the perturbations. Extensive
evaluations show that our approach computes sparse per-
turbations very fast, and scales efﬁciently to high dimen-
sional data. We further analyze the transferability and the
visual effects of the perturbations, and show the existence
of shared semantic information across the images and the
networks. Finally, we show that adversarial training can
only slightly improve the robustness against sparse additive
perturbations computed with SparseFool. 1

1. Introduction

Deep neural networks (DNNs) are powerful learning
models that achieve state-of-the-art performance in many
different classiﬁcation tasks [27, 49, 1, 22, 9], but have been
shown to be vulnerable to very small, and often impercepti-
ble, adversarial manipulations of their input data [46]. In-
terestingly, the existence of such adversarial perturbations
is not only limited to additive perturbations [21, 12, 48] or
classiﬁcation tasks [8], but can be found in many other ap-
plications [47, 7, 28, 31, 39, 41, 42].

For image classiﬁcation tasks, the most common type
of adversarial perturbations are the `p minimization ones,
since they are easier to analyze and optimize. Formally, for
a given classiﬁer and an image x 2 Rn, we deﬁne as adver-
sarial perturbation the minimal perturbation r that changes

1The code of SparseFool is available at https://github.com/

LTS4/SparseFool.

cockroach

palace

bathtub

sandal

wine bottle

bubble

Figure 1: Adversarial examples for ImageNet, as computed
by SparseFool on a ResNet-101 architecture. Each column
corresponds to different level of perturbed pixels. The fool-
ing labels are shown below the images.

the classiﬁer’s estimated label k(x):

min

r

krkp s.t. k(x + r) 6= k(x),

(1)

Several methods (attacks) have been proposed for com-
puting `2 and `∞ adversarial perturbations [46, 15, 24, 33,
6, 32]. However, understanding the vulnerabilities of deep
neural networks in other perturbation regimes remains im-
portant. In particular, it has been shown [38, 44, 35, 2, 18]
that DNNs can misclassify an image, when only a small
fraction of the input is altered (sparse perturbations).
In
practice, sparse perturbations could correspond to some
raindrops that reﬂect the sun on a “STOP” sign, but that
are sufﬁcient to fool an autonomous vehicle; or a crop-ﬁeld
with some sparse colorful ﬂowers that force a UAV to spray
pesticide on non affected areas. Understanding the vulnera-
bility of deep networks to such a simple perturbation regime
can further help to design methods to improve the robust-
ness of deep classiﬁers.

Some prior work on sparse perturbations have been de-
veloped recently. The authors in [38] proposed the JSMA

9087

method, which perturbs the pixels based on their saliency
score. Furthermore, the authors in [44] exploit Evolution-
ary Algorithms (EAs) to achieve extremely sparse perturba-
tions, while the authors in [35] ﬁnally proposed a black-box
attack that computes sparse adversarial perturbations using
a greedy local search algorithm.

However, solving the optimization problem in Eq. (1) in
an `0 sense is NP-hard, and current algorithms are all char-
acterized by high complexity. The resulting perturbations
usually consist of high magnitude noise, concentrated over
a small number of pixels. This makes them quite perceptible
and in many cases, the perturbed pixels might even exceed
the dynamic range of the image.

Therefore, we propose in this paper an efﬁcient and prin-
cipled way to compute sparse perturbations, while at the
same time ensuring the validity of the perturbed pixels.

Our main contributions are the following:

• We propose SparseFool, a geometry inspired sparse at-
tack that exploits the boundaries’ low mean curvature
to compute adversarial perturbations efﬁciently.

• We show through extensive evaluations that (a) our
method computes sparse perturbations much faster
than the existing methods, and (b) it can scale efﬁ-
ciently to high dimensional data.

• We further propose a method to control the percepti-
bility of the resulted perturbations, while retaining the
levels of sparsity and complexity.

• We analyze the visual features affected by our attack,
and show the existence of some shared semantic infor-
mation across different images and networks.

• We ﬁnally show that adversarial training using slightly
lowers the vulnerability against sparse perturbations,
but not enough to lead to more robust classiﬁers yet.

The rest of the paper is organized as follows: in Section 2,
we describe the challenges and the problems for computing
sparse adversarial perturbations. In Section 3, we provide
an efﬁcient method for computing sparse adversarial per-
turbations, by linearizing and solving the initial optimiza-
tion problem. Finally, the evaluation and analysis of the
computed sparse perturbations is provided in Section 4.

2. Problem description

2.1. Finding sparse perturbations

Most of the existing adversarial attack algorithms solve
the optimization problem of Eq. (1) for p = 2 or 1, result-
ing in dense but imperceptible perturbations. For the case
of sparse perturbations, the goal is to minimize the num-
ber of perturbed pixels required to fool the network, which

corresponds to minimizing krk0 in Eq. (1). Unfortunately,
this leads to NP-hard problems, for which reaching a global
minimum cannot be guaranteed in general [3, 37, 40]. There
exist different methods [34, 40] to avoid the computational
burden of this problem, with the `1 relaxation being the
most common; the minimization of krk0 under linear con-
straints can be approximated by solving the corresponding
convex `1 problem [5, 10, 36]2. Thus, we are looking for an
efﬁcient way to exploit such a relaxation to solve the opti-
mization problem in Eq. (1).

DeepFool [33] is an algorithm that exploits such a re-
laxation, by adopting an iterative procedure that includes a
linearization of the classiﬁer at each iteration, in order to es-
timate the minimal adversarial perturbation r. Speciﬁcally,
assuming f is a classiﬁer, at each iteration i, f is linearized
around the current point x(i), the minimal perturbation r(i)
(in an `2 sense) is computed as the projection of x(i) onto
the linearized hyperplane, and the next iterate x(i+1) is up-
dated. One can use such a linearization procedure to solve
Eq. (1) for p = 1, so as to obtain an approximation to the `0
solution. Thus, by generalizing the projection to `p norms
(p 2 [1, 1)) and setting p = 1, `1-DeepFool provides an
efﬁcient way for computing sparse adversarial perturbations
using the `1 projection.

2.2. Validity of perturbations

Although the `1-DeepFool efﬁciently computes sparse
perturbations, it does not explicitly respect the constraint
on the validity of the adversarial image values. When com-
puting adversarial perturbations, it is very important to en-
sure that the pixel values of the adversarial image x + r lie
within the valid range of color images (e.g., [0, 255]). For
`2 and `∞ perturbations, almost every pixel of the image is
distorted with noise of small magnitude, so that most com-
mon algorithms usually ignore such constraints [33, 15]. In
such cases, it is unlikely that many pixels will be out of their
valid range; and even then, clipping the invalid values after
the computation of such adversarial images have a minor
impact.

This is unfortunately not the case for sparse perturba-
tions however; solving the `1 optimization problem results
in a few distorted pixels of high magnitude noise, and clip-
ping the values after computing the adversarial image can
have a signiﬁcant impact on the success of the attack. In
other words, as the perturbation becomes sparser, the con-
tribution of each pixel is typically much stronger compared
to `2 or `∞ perturbations.

We demonstrate the effect of such clipping operation on
the quality of adversarial perturbations generated by `1-
DeepFool. For example, with perturbations computed for
a VGG-16 [43] network trained on ImageNet [9], we ob-

2Under some conditions, the solution of such approximation is indeed

optimal [4, 11, 16].

9088

k(x) = 1

Algorithm 1: LinearSolver

k(x) = 1

w

xB

B

v

x

Figure 2: The approximated decision boundary B in the
vicinity of the datapoint x that belongs to class 1. B can be
seen as a one-vs-all linear classiﬁer for class 1.

served that `1-DeepFool achieves almost 100% of fooling
rate by perturbing only 0.037% of the pixels on average.
However, clipping the pixel values of adversarial images to
[0, 255] results in a fooling rate of merely 13%. Further-
more, incorporating the clipping operator inside the itera-
tive procedure of the algorithm does not improve the re-
sults. In other words, `1-DeepFool fails to properly com-
pute sparse perturbations. This underlies the need for an
improved attack algorithm that natively takes into account
the validity of generated adversarial images, as proposed in
the next sections.

2.3. Problem formulation

Based on the above discussion, sparse adversarial pertur-
bations are obtained by solving the following general form
optimization problem:

Input: image x, normal w, boundary point xB,

projection operator Q.
Output: perturbed point x(i)

1 Initialize: x(0)   x, i   0, S = {}
2 while wT (x(i)   xB) 6= 0 do
3

r   0

· sign(wd)

4

5

6

7

8

d   arg max

|wj|

j /∈S
|wT (x(i)   xB)|

|wd|

rd  

x(i+1)   Q(x(i) + r)
S   S [ {d}

i   i + 1

9 end
10 return x(i)

constrained optimization problem:

minimize

r

krk1

subject to wT (x + r)   wT xB = 0

(3)

l 4 x + r 4 u.

In the following section, we provide a method for solving
the optimization problem (3), and introduce SparseFool, a
fast yet efﬁcient algorithm for computing sparse adversarial
perturbations, which linearizes the constraints by approxi-
mating the decision boundary as an afﬁne hyperplane.

minimize

r

krk1

subject to

ˆk(x + r) 6= ˆk(x)
l 4 x + r 4 u,

3. Sparse adversarial perturbations

(2)

3.1. Linearized problem solution

where l, u 2 Rn denote the lower and upper bounds of the
values of x + r, such that li  xi + ri  ui, i = 1 . . . n.
To ﬁnd an efﬁcient relaxation to problem (2), we focus
on the geometric characteristics of the decision boundary,
and speciﬁcally on its curvature.
It has been shown [13,
14, 20] that the decision boundaries of state-of-the-art deep
networks have a quite low mean curvature in the neighbor-
In other words, for a datapoint x
hood of data samples.
and its corresponding minimal `2 adversarial perturbation
v, the decision boundary at the vicinity of x can be locally
well approximated by a hyperplane passing through the dat-
apoint xB = x + v, and a normal vector w (see Fig. 2).

Hence, we exploit this property and linearize the op-
timization problem (2), so that sparse adversarial pertur-
bations can be computed by solving the following box-

In solving the optimization problem (3), the computation
of the `1 projection of x onto the approximated hyperplane
does not guarantee a solution. For a perturbed image, con-
sider the case where some of its values exceed the bounds
deﬁned by l and u. Thus, by readjusting the invalid values
to match the constraints, the resulted adversarial image may
eventually not lie onto the approximated hyperplane.

For this reason, we propose an iterative procedure, where
at each iteration we project only towards one single coordi-
nate of the normal vector w at a time. If projecting x to-
wards a speciﬁc direction does not provide a solution, then
the perturbed image at this coordinate has reached its ex-
trema value. Therefore, at the next iteration, this direction
should be ignored, since it cannot contribute any further to
ﬁnding a better solution.

Formally, let S be a set containing all the directions of
w that cannot contribute to the minimal perturbation. Then,

9089

(2)

x

(1)
B

x

(1)

x

(0)
B

x

(0)

x

Figure 3: Illustration of SparseFool algorithm. With green
we denote the `2-DeepFool adversarial perturbations com-
puted at each iteration.
In this example, the algorithm
converges after 2 iterations, and the total perturbation is
r = x(2)   x(0).

the minimal perturbation r is updated through the `1 pro-
jection of the current datapoint x(i) onto the estimated hy-
perplane as:

rd  

|wT (x(i)   xB)|

|wd|

· sign(wd),

(4)

where d is the index of the maximum absolute value of w
that has not already been used

d   arg max |wj|

.

j /∈S

(5)

Before proceeding to the next iteration, we must ensure
the validity of the values of the next iterate x(i+1). For
this reason, we use a projection operator Q(·) that read-
justs the values of the updated point that are out of bounds,
by projecting x(i) + r onto the box-constraints deﬁned
by l and u. Hence, the new iterate x(i+1) is updated as
x(i+1)   Q(x(i) + r). Note here that the bounds l, u are
not limited to only represent the dynamic range of an image,
but can be generalized to satisfy any similar restriction. For
example, as we will describe later in Section 4.2, they can
be used to control the perceptibility of the computed adver-
sarial images.

The next step is to check if the new iterate x(i+1) has
reached the approximated hyperplane. Otherwise, it means
that the perturbed image at the coordinate d has reached
its extrema value, and thus we cannot change it any further;
perturbing towards the corresponding direction will have no
effect. Thus, we reduce the search space, by adding to the
forbidden set S the direction d, and repeat the procedure
until we reach the approximated hyperplane. The algorithm
for solving the linearized problem is summarized in Algo-
rithm 1.

Algorithm 2: SparseFool

Input: image x, projection operator Q, classiﬁer f .
Output: perturbation r

1 Initialize: x(0)   x, i   0
2 while ˆk(x(i)) = ˆk(x(0)) do

3

4

5

6

7

x

radv = DeepFool(x(i))
(i)
B = x(i) + radv
w(i) = rfk(x
B )(x
x(i+1) = LinearSolver(x(i), w(i), x
i   i + 1

(i)
B )   rfk(x(i))(x

(i)
B )

(i)

(i)
B , Q)

8 end
9 return r = x(i)   x(0)

3.2. Finding the point xB and the normal w

In order to complete our solution to the optimization
problem (3), we now focus on the linear approximation of
the decision boundary. Recall from Section 2.3 that we need
to ﬁnd the boundary point xB, along with the corresponding
normal vector w.

Finding xB is analogous to computing (in a `2 sense)
an adversarial example of x, so it can be approximated by
applying one of the existing `2 attack algorithms. How-
ever, not all of these attacks are proper for our task; we
need a fast method that ﬁnds adversarial examples that are
as close to the original image x as possible. Recall that
DeepFool [33] iteratively moves x towards the decision
boundary, and stops as soon as the perturbed data point
reaches the other side of the boundary. Therefore, the re-
sulting perturbed sample usually lies very close to the deci-
sion boundary, and thus, xB can be very well approximated
by x+ radv, with radv being the corresponding `2-DeepFool
perturbation of x. Then, if we denote the network’s classi-
ﬁcation function as f , one can estimate the normal vector to
the decision boundary at the datapoint xB as:

w := rfk(xB )(xB)   rfk(x)(xB).

(6)

Hence, the decision boundary can now be approximated by
the afﬁne hyperplane B ,  x : wT (x   xB) = 0 , and
sparse adversarial perturbations are computed by applying
Algorithm 1.

3.3. SparseFool

However, although we expected to have a one-step solu-
tion, in many cases the algorithm does not converge. The
reason behind this behavior lies on the fact that the decision
boundaries of the networks are only locally ﬂat [13, 14, 20].
Thus, if the `1 perturbation moves the datapoint x away

9090

Figure 4: The fooling rate, the sparsity of the perturbations, and the average iterations of SparseFool for different values of
 , on 4000 images from ImageNet dataset using an Inception-v3 [45] model.

from the ﬂat area, then the perturbed point will not reach
the other side of the decision boundary.

4. Experimental results

4.1. Setup

We mitigate the convergence issue with an iterative
method, namely SparseFool, where each iteration includes
the linear approximation of the decision boundary. Specif-
(i)
ically, at iteration i, the boundary point x
B and the nor-
mal vector w(i) are estimated using `2-DeepFool based on
the current iterate x(i). Then, the next iterate x(i+1) is up-
dated through the solution of Algorithm 1, having though
x(i) as the initial point, and the algorithm terminates when
x(i) changes the label of the network. An illustration of
SparseFool is given in Fig. 3, and the algorithm is summa-
rized in Algorithm 2.

However, we observed that instead of using the bound-
(i)
B at the step 6 of SparseFool, better conver-
ary point x
gence can be achieved by going further into the other side of
the boundary, and ﬁnd a solution for the hyperplane passing
(i)
through the datapoint x(i) +  (x
B   x(i)), where     1.
Speciﬁcally, as shown in Fig. 4, this parameter is used to
control the trade-off between the fooling rate, the sparsity,
and the complexity. Values close to 1, lead to sparser per-
turbations, but also to lower fooling rate and increased com-
plexity. On the contrary, higher values of   lead to fast
convergence – even one step solutions –, but the resulted
perturbations are less sparse. Since   is the only parame-
ter of the algorithm, it can be easily adjusted to meet the
corresponding needs in terms of fooling rate, sparsity, and
complexity.

Finally, note that B corresponds to the boundary be-
tween the adversarial and the estimated true class, and thus
it can be seen as an afﬁne binary classiﬁer. Since at each
iteration the adversarial class is computed as the closest (in
an `2 sense) to the true one, we can say that SparseFool op-
erates as an untargeted attack. Even though, it can be easily
transformed to a targeted one, by simply computing at each
iteration the adversarial example – and thus approximating
the decision boundary – of a speciﬁc category.

We test SparseFool on deep convolutional neural
network architectures with the 10000 images of
the
MNIST [26] test set, 10000 images of the CIFAR-10 [23]
test set, and 4000 randomly selected images from the
ILSVRC2012 validation set.
In order to evaluate our al-
gorithm and compare with related works, we compute the
fooling rate, the median perturbation percentage, and the
average execution time. Given a dataset D , the fooling rate
measures the efﬁciency of the algorithm, using the formula:
 
x 2 D : f (x + rx) 6= f (x) 
 / 
 , where rx is the per-
 
 
turbation that corresponds to the image x. The median per-
turbation percentage corresponds to the median percentage
of the pixels that are perturbed per fooling sample, while
the average execution time measures the average execution
time of the algorithm per sample3.

D 

We compare SparseFool with the implementation of
JSMA attack [38]. Since JSMA is a targeted attack, we
evaluate it on its “untargeted” version, where the target class
is chosen at random. We also make one more modiﬁcation
at the success condition; instead of checking if the predicted
class is equal to the target one, we simply check if it is dif-
ferent from the source one. Let us note that JSMA is not
evaluated on ImageNet dataset, due to its huge computa-
tional cost for searching over all pairs of candidates [6]. We
also compare SparseFool with the “one-pixel attack” pro-
posed in [44]. Since “one-pixel attack” perturbs exactly k
pixels, for every image we start with k = 1 and increase it
till “one-pixel attack” ﬁnds an adversarial example. Again,
we do not evaluate the “one-pixel attack” on the ImageNet
dataset, due to its high computational cost for high dimen-
sional images.

4.2. Results

Overall performance. We ﬁrst evaluate the performance
of SparseFool, JSMA, and “one-pixel attack” on differ-

3All the experiments were conducted on a GTX TITAN X GPU.

9091

Fooling rate %75808590951001.02.03.04.05.06.0λMedian number of perturbed pixels1.02.03.04.05.06.0λ406080100120Average number of iterations4681012141.02.03.04.05.06.0λent datasets and architectures. The control parameter   in
SparseFool was set to 1 and 3 for the MNIST and CIFAR-
10 datasets respectively. We observe in Table 1 that Sparse-
Fool computes 2.9x sparser perturbations, and is 4.7x faster
compared to JSMA for the MNIST dataset. This behavior
remains similar for the CIFAR-10 dataset, where Sparse-
Fool computes on average, perturbations of 2.4x higher
sparsity, and is 15.5x faster. Notice here the difference in
the execution time: JSMA becomes much slower as the
dimension of the input data increases, while SparseFool’s
time complexity remains at very low levels.

Then, in comparison to “one-pixel attack”, we observe
that for the MNIST dataset, our method computes 5.5x
sparser perturbations, and is more than 3 orders of mag-
nitude faster. For the CIFAR-10 dataset, SparseFool still
manages to ﬁnd very sparse perturbations, but less so than
the “one-pixel attack” in this case. The reason is that our
method does not solve the original `0 optimization prob-
lem, but it rather computes sparse perturbations through the
`1 solution of the linearized one. The resulting solution is
often suboptimal, and may be optimal when the datapoint is
very close to the boundary, where the linear approximation
is more accurate. However, solving our linearized problem
is fast, and enables our method to efﬁciently scale to high
dimensional data, which is not the case for the “one-pixel at-
tack”. Considering the tradeoff between the sparsity of the
solutions and the required complexity, we choose to sacri-
ﬁce the former, rather than following a complex exhaustive
approach like [44]. In fact, our method is able to compute
sparse perturbations 270x faster, and by requiring 2 orders
of magnitude less queries to the network, than the “one-
pixel attack” algorithm.

Finally, due to the huge computational cost of both
JSMA and “one-pixel attack”, we do not use it for the large
ImageNet dataset. In this case, we instead compare Sparse-
Fool with an algorithm that randomly selects a subset of ele-
ments from each color channel (RGB), and replaces their in-
tensity with a random value from the set V = {0, 255}. The
cardinality of each channel subset is constrained to match
SparseFool’s per-channel median number of perturbed el-
ements; for each channel, we select as many elements as
the median, across all images, of SparseFool’s perturbed el-
ements for this channel. The performance of SparseFool
for the ImageNet dataset is reported in Table 2, while the
corresponding fooling rates for the random algorithm were
18.2%, 13.2%, 14.5%, and 9.6% respectively. Observe that
the fooling rates obtained for the random algorithm are far
from comparable with SparseFool’s, indicating that the pro-
posed algorithm cleverly ﬁnds very sparse solutions.
In-
deed, our method is consistent among different architec-
tures, perturbing on average 0.21% of the pixels, with an
average execution time of 7 seconds per sample.

(a) MNIST

(b) CIFAR-10

Figure 5: Adversarial examples for (a) MNIST and (b)
CIFAR-10 datasets, as computed by SparseFool on LeNet
and ResNet-18 architectures respectively. Each column cor-
responds to different level of perturbed pixels.

an adequate sparse attack that efﬁciently achieves such fool-
ing rates and sparsity, and at the same time scales to high
dimensional data. “One-pixel attack” does not necessarily
ﬁnd good solutions for all the studied datasets, however,
SparseFool – as it relies on the high dimensional geome-
try of the classiﬁers – successfully computes sparse enough
perturbations for all three datasets.

Perceptibility.

In this section, we illustrate some ad-
versarial examples generated by SparseFool, for three dif-
ferent levels of sparsity; highly sparse perturbations, sparse
perturbations, and somewhere in the middle.
For the
MNIST and CIFAR-10 datasets (Figures 5a and 5b respec-
tively), we observe that for highly sparse cases, the pertur-
bation is either imperceptible or so sparse (i.e., 1 pixel) that
it can be easily ignored. However, as the number of per-
turbed pixels increases, the distortion becomes even more
perceptible, and in some cases the noise is detectable and
far from imperceptible. The same behavior is observed for
the ImageNet dataset (Fig. 1). For highly sparse perturba-
tions, the noise is again either imperceptible or negligible,
but as the density increases, it becomes more and more vis-
ible.

To eliminate this perceptibility effect, we focus on the
lower and upper bounds of the values of an adversarial im-
age ˆx. Recall from Section 2.3 that the bounds l, u are
deﬁned in way such that li  ˆxi  ui, i = 1 . . . n. If these
bounds represent the dynamic range of the image, then ˆxi
can take every possible value from this range, and the mag-
nitude of the noise at the element i can reach some visible
levels. However, if the perturbed values of each element lie
close to the original values xi, then we might prevent the
magnitude from reaching very high levels. For this reason,
assuming a dynamic range of [0, 255], we explicitly con-
strain the values of ˆxi to lie in a small interval ±  around
xi, such that 0  xi      ˆxi  xi +    255.

To the best of our knowledge, we are the ﬁrst to provide

The resulted sparsity for different values of   is depicted

9092

779632882dogdogcatcarcartruckbirddeertruckDataset

Network

Acc. (%)

MNIST

LeNet [25]

CIFAR-10

VGG-19

ResNet18 [17]

99.14
92.71
92.74

Fooling rate (%)

Perturbation (%)

Time (sec)

SF

99.93
100
100

JSMA 1-PA
95.73
100
100
98.12
100
100

SF
1.66
1.07
1.27

JSMA 1-PA
4.85
9.43
0.15
2.25
3.91
0.2

SF
0.14
0.34
0.69

JSMA 1-PA
0.66
310.2
102.7
6.28
8.73
167.4

Table 1: The performance of SparseFool (SF), JSMA [38], and “one-pixel attack” (1-PA) [44] on the MNIST and the CIFAR-
10 datasets.3 Note that due to its high complexity, “one-pixel attack” was evaluated on only 100 samples.

Network

Acc. (%)

VGG-16

ResNet-101

DenseNet-161
Inception-v3

71.59
77.37
77.65
77.45

Fooling
rate (%)

100
100
100
100

Pert.
(%)
0.18
0.23
0.29
0.14

Time
(sec)
5.09
8.07
10.07
4.94

xi ± 255

xi ± 30

xi ± 10

Table 2: The performance of SparseFool on the ImageNet
dataset, using the pre-trained models provided by PyTorch.3

amphibian
(0.227%)

amphibian
(1.058%)

amphibian
(4.296%)

Figure 6: The resulted sparsity of SparseFool perturbations
for ±  around the values of x, for 100 samples from Ima-
geNet on a ResNet-101 architecture.

in Fig. 6. The higher the value, the more freedom we give
to the perturbations, and for   = 255 we exploit the whole
dynamic range. Observe though that after   ⇡ 25, the spar-
sity levels seem to remain almost constant, which indicates
that we do not need to use the whole dynamic range. Fur-
thermore, we observed that the average execution time per
sample of SparseFool from this value onward seems to re-
main constant as well, while the fooling rate is always 100%
regardless  . Thus, by selecting appropriate values for  , we
can control the perceptibility of the resulted perturbations,
retain the sparsity around a sufﬁcient level. The inﬂuence of
  on the perceptibility and the sparsity of the perturbations
is demonstrated in Fig. 7.

Transferability and semantic information. We now
study if SparseFool adversarial perturbations can general-
ize across different architectures. For the VGG-16, ResNet-

Arabian camel

Arabian camel

Arabian camel

(0.169%)

(0.839%)

(3.202%)

Figure 7: The effect of   on the perceptibility and the spar-
sity of SparseFool perturbations. The values of   are shown
on top of each column, while the fooling label and the per-
centage of perturbed pixels are written below each image.

101, and DenseNet-161 [19] architectures, we report in Ta-
ble 3 the fooling rate of each model when fed with adver-
sarial examples generated by another one. We observe that
sparse adversarial perturbations can generalize only to some
extent, and also, as expected [29], they are more transfer-
able from larger to smaller architectures. This indicates that
there should be some shared semantic information between
different architectures that SparseFool exploits, but the per-
turbations are mostly network dependent.

Focusing on some animal categories of the ImageNet
dataset, we observe that indeed the perturbations are con-
centrated around “important” areas (i.e., head), but there is
not a consistent pattern to indicate speciﬁc features that are
the most important for the network (i.e., eyes, ears, nose
etc.); in many cases the noise also spreads around different
parts of the image. Examining now if semantic information
is shared across different architectures (Fig. 8), we observe
that in all the networks, the noise consistently lies around

9093

Median number of perturbed pixelsδ05010015020025004000800012000VGG16
ResNet101
DenseNet161

VGG16 ResNet101 DenseNet161
100%
25.3%
28.2%

8.2%
12.1%
100%

10.8%
100%
17.5%

Table 3: Fooling rates of SparseFool perturbations between
pairs of models for 4000 samples from ImageNet. The row
and column denote the source and target model respectively.

(a) VGG-16

(b) ResNet-101

(c) DenseNet-161

Figure 8: Shared information of the SparseFool perturba-
tions for ImageNet, as computed on three different archi-
tectures. For all networks, the ﬁrst row image was classiﬁed
as “Chihuahua” and misclassiﬁed as “French Bulldog”, and
second row image as “Ostrich” and “Crane” respectively.

the important areas of the image, but the way it concentrates
or spreads is different for each network.

For the CIFAR-10 dataset, we observe that in many cases
of animal classes, SparseFool tends to perturb some uni-
versal features around the area of the head (i.e., eyes, ears,
nose, mouth etc.), as shown in Fig. 9a. Furthermore, we
tried to understand if there is a correlation between the per-
turbed pixels and the fooling class.
Interestingly, we ob-
served that in many cases, the algorithm was perturbing
those regions of the image that correspond to important fea-
tures of the fooling class, i.e., when changing a “bird” la-
bel to a “plane”, where the perturbation seems to represent
some parts of the plane (i.e., wings, tail, nose, turbine). This
behavior becomes even more obvious when the fooling la-
bel is a “deer”, where the noise lies mostly around the area
of the head in a way that resembles the antlers.

Robustness of adversarially trained network. Fi-
nally, we study the robustness to sparse perturbations of
an adversarially trained ResNet-18 network on the CIFAR-
10 dataset, using `∞ perturbations. The accuracy of this
more robust network is 82.17%, while the training proce-
dure and its overall performance are similar to the ones pro-
vided in [30]. Compared to the results of Table 1, the av-
erage time dropped to 0.3 sec, but the perturbation percent-

(a) Universal features

(b) Fooling class features

Figure 9: Semantic information of SparseFool perturbations
for the CIFAR-10 dataset, on a ResNet-18 architecture. Ob-
serve that the perturbation is concentrated on (a) some fea-
tures around the area of the face, and (b) on areas that are
important for the fooling class.

age increased to 2.44%. In other words, the adversarially
trained network leads to just a slight change in the sparsity,
and thus training it on `∞ perturbations does not signiﬁ-
cantly improve its robustness against sparse perturbations.

5. Conclusion

Computing adversarial perturbations beyond simple `p
norms is a challenging problem from different aspects. For
sparse perturbations, apart from the NP-hardness of the `0
minimization, one needs to ensure the validity of the ad-
versarial example values. In this work, we provide a novel
geometry inspired sparse attack algorithm that is fast and
can scale to high dimensional data, where one can also have
leverage over the sparsity of the resulted perturbations. Fur-
thermore, we provide a simple method to improve the per-
ceptibility of the perturbations, while retaining the levels
of sparsity and complexity. We also note that for some
datasets, the proposed sparse attack alters features that are
shared among different images. Finally, we show that ad-
versarial training does not signiﬁcantly improve the robust-
ness against sparse perturbations computed with Sparse-
Fool. We believe that the proposed approach can be used to
further understand the behavior and the geometry of deep
image classiﬁers, and provide insights for building more ro-
bust networks.

Acknowledgements

We thank Mireille El Gheche and Stefano D’Aronco for
the fruitful discussions. This work has been supported by
a Google Faculty Research Award, and the Hasler Founda-
tion, Switzerland, in the framework of the ROBERT project.
We also gratefully acknowledge the support of NVIDIA
Corporation with the donation of the GTX Titan X GPU
used for this research.

9094

catdogdogdogdogcatcatcatdeercatdeerplaneplanedeerdeerdeerdeerdeerReferences

[1] S. Abu-El-Haija, N. Kothari, J. Lee, P. Natsev, G. Toderici,
B. Varadarajan, and S. Vijayanarasimhan. Youtube-8m: A
large-scale video classiﬁcation benchmark, 2016.
arXiv
preprint arXiv:1609.08675.

[2] A. Bibi, M. Alfadly, and B. Ghanem. Analytic expressions
for probabilistic moments of pl-dnn with gaussian input. In
Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, 2018.

[3] T. Blumensath and M. E. Davies. Iterative thresholding for
sparse approximations. Journal of Fourier Analysis and Ap-
plications, 14(5):629–654, 2008.

[4] E. Cand`es, M. Rudelson, T. Tao, and E. Vershynin. Error cor-
rection via linear programming. 46th Annual IEEE Sympo-
sium on Foundations of Computer Science (FOCS’05), pages
668–681, 2005.

[5] E. J. Cand`es and T. Tao. Decoding by linear programming.
IEEE Transactions on Information Theory, 51(12):4203–
4215, 2005.

[6] N. Carlini and D.Wagner. Towards evaluating the robustness
of neural networks. IEEE Symposium on Security and Pri-
vacy (SP), pages 39–57, 2017.

[7] N. Carlini and D. Wagner. Audio adversarial examples: Tar-
geted attacks on speech-to-text. IEEE Security and Privacy
Workshops (SPW), 2018.

[8] M. M. Cisse, Y. Adi, N. Neverova, and J. Keshet. Hou-
dini: Fooling deep structured prediction models. Advances in
Neural Information Processing Systems (NIPS), pages 6977–
6987, 2017.

[9] J. Deng, W. Dong, R. Socher, L.-J. Li, L. Kai, and F.-F.
Li.
Imagenet: A large-scale hierarchical image database.
IEEE Conference on Computer Vision and Pattern Recog-
nition (CVPR), pages 248–255, 2009.

[10] D. L. Donoho. Compressed sensing. IEEE Transactions on

Information Theory, 52(4):1289–1306, 2006.

[11] D. L. Donoho and M. Elad. Optimally sparse representation
in general (nonorthogonal) dictionaries via `1 minimization.
National Academy of Sciences, 100(5):2197–2202, 2003.

[12] A. Fawzi and P. Frossard. Manitest: Are classiﬁers really in-
variant? British Machine Vision Conference (BMVC), 2015.
[13] A. Fawzi, S.-M. Moosavi-Dezfooli, and P. Frossard. The ro-
bustness of deep networks: A geometrical perspective. IEEE
Signal Processing Magazine, 34(6):50–62, 2017.

[14] A. Fawzi, S.-M. Moosavi-Dezfooli, P. Frossard, and
S. Soatto. Empirical study of the topology and geometry of
deep networks. IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), pages 3762–3770, 2018.

[15] I. J. Goodfellow, J. Shlens, and C. Szegedy. Explaining and
harnessing adversarial examples. International Conference
on Learning Representations (ICLR), 2015.

[16] R. Gribonval and M. Nielsen. Sparse representations in
unions of bases. IEEE Transactions on Information Theory,
49(12):3320–3325, 2003.

[17] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning
for image recognition. IEEE Conference on Computer Vision
and Pattern Recognition (CVPR), pages 770–778, 2016.

[18] M. Hein and M. Andriushchenko. Formal guarantees on the
robustness of a classiﬁer against adversarial manipulation. In
Advances in Neural Information Processing Systems, 2017.
[19] G. Huang, Z. Liu, L. Maaten, and K. Q. Weinberger. Densely
connected convolutional networks.
IEEE Conference on
Computer Vision and Pattern Recognition (CVPR), pages
2261–2269, 2017.

[20] S. Jetley, N. A. Lord, and P. H. S. Torr. With friends
arXiv preprint

like these, who needs adversaries?, 2018.
arXiv:1807.04200.

[21] C. Kanbak, S.-M. Moosavi-Dezfooli, and P. Frossard. Geo-
metric robustness of deep networks: analysis and improve-
ment.
IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 4441–4449, 2018.

[22] I. Krasin, T. Duerig, N. Alldrin, A. Veit, S. Abu-El-Haija,
S. Belongie, D. Cai, Z. Feng, V. Ferrari, V. Gomes, A. Gupta,
D. Narayanan, C. Sun, G. Chechik, and K. Murphy. Open-
images: A public dataset for large-scale multi-label and
multi-class image classiﬁcation. Dataset available from
https://github.com/openimages, 2016.

[23] A. Krizhevsky. Learning multiple layers of features from

tiny images. Technical report, University of Toronto, 2009.

[24] A. Kurakin, I. Goodfellow, and S. Bengio. Adversar-
ial examples in the physical world, 2016. arXiv preprint
arXiv:1607.02533.

[25] Y. Lecun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-
based learning applied to document recognition. Proceed-
ings of the IEEE, 86(11):2278–2324, 1998.

[26] Y. LeCun and C. Cortes. Mnist handwritten digits database.
Dataset available from http://yann.lecun.com/exdb/mnist/,
2010.

[27] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Dollr, and C. L. Zitnick. Microsoft coco: Common
objects in context. European Conference on Computer Vision
(ECCV), pages 740–755, 2014.

[28] Y.-C. Lin, Z.-W. Hong, Y.-H. Liao, M.-L. Shih, M.-Y. Liu,
and M. Sun. Tactics of adversarial attack on deep reinforce-
ment learning agents. International Joint Conference on Ar-
tiﬁcial Intelligence (IJCAI), pages 3756–3762, 2017.

[29] Y. Liu, X. Chen, C. Liu, and D. X. Song. Delving into trans-
ferable adversarial examples and black-box attacks, 2016.
arXiv preprint arXiv:1611.02770.

[30] A. Madry, A. Makelov, L. Schmidt, D. Tsipras, and
A. Vladu. Towards deep learning models resistant to adver-
sarial attacks. International Conference on Learning Repre-
sentations (ICLR), 2018.

[31] J. H. Metzen, M. C. Kumar, T. Brox, and V. Fischer. Univer-
sal adversarial perturbations against semantic image segmen-
tation. IEEE International Conference on Computer Vision
(ICCV), pages 2774–2783, 2017.

[32] S.-M. Moosavi-Dezfooli, A. Fawzi, O. Fawzi,

and
P. Frossard. Universal adversarial perturbations.
IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), pages 86–94, 2017.

[33] S.-M. Moosavi-Dezfooli, A. Fawzi, and P. Frossard. Deep-
fool: A simple and accurate method to fool deep neural net-
works.
IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 2574–2582, 2016.

9095

[34] M. Nagahara, D. E. Quevedo, and J. Ostergaard. Sparse
packetized predictive control for networked control over era-
sure channels.
IEEE Transactions on Automatic Control,
59(7):1899–1905, 2014.

[35] N. Narodytska and S. Kasiviswanathan. Simple black-box
adversarial attacks on deep neural networks.
IEEE Con-
ference on Computer Vision and Pattern Recognition Work-
shops (CVPRW), pages 1310–1318, 2017.

[36] B. K. Natarajan. Sparse approximate solutions to linear sys-

tems. SIAM Journal on Computing, 24(2):227–234, 1995.

[37] M. Nikolova. Description of the minimizers of least squares
regularized with `0-norm. uniqueness of the global mini-
mizer. SIAM Journal on Imaging Sciences, 6(2):904–937,
2013.

[38] N. Papernot, P. McDaniel, S. Jha, M. Fredrikson, Z. B. Ce-
lik, and A. Swami. The limitations of deep learning in adver-
sarial settings. IEEE European Symposium on Security and
Privacy (EuroS&P), pages 372–387, 2016.

[39] N. Papernot, P. McDaniel, A. Swami, and R. Harang. Craft-
ing adversarial input sequences for recurrent neural net-
works.
IEEE Military Communications Conference (MIL-
COM), pages 49–54, 2016.

[40] A. Patrascu and I. Necoara. Random coordinate descent
methods for `0 regularized convex optimization.
IEEE
Transactions on Automatic Control, 60(7):1811–1824, 2015.
[41] A. Rozsa, M. Gunther, E. M. Rudd, and T. E. Boult. Are
facial attributes adversarially robust?
International Con-
ference on Pattern Recognition (ICPR), pages 3121–3127,
2016.

[42] A. Rozsa, M. G¨unther, E. M. Rudd, and T. E. Boult. Fa-
cial attributes: Accuracy and adversarial robustness. Pattern
Recognition Letters, 2017.

[43] K. Simonyan and A. Zisserman. Very deep convolutional
International

networks for large-scale image recognition.
Conference on Learning Representations (ICLR), 2015.

[44] J. Su, D. V. Vargas, and S. Kouichi. One pixel attack
arXiv preprint

for fooling deep neural networks, 2017.
arXiv:1710.08864.

[45] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the inception architecture for computer vision.
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR), pages 2818–2826, 2016.

[46] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan,
I. Goodfellow, and R. Fergus. Intriguing properties of neural
networks. International Conference on Learning Represen-
tations (ICLR), 2014.

[47] P. Tabacof, J. Tavares, and E. Valle. Adversarial images for

variational autoencoders, 2016. arXiv:1612.00155.

[48] C. Xiao, J.-Y. Zhu, B. Li, W. He, M. Liu, and D. Song. Spa-
tially transformed adversarial examples. International Con-
ference on Learning Representations (ICLR), 2018.

[49] Y. Zhang, K. Lee, and H. Lee. Augmenting supervised neural
networks with unsupervised objectives for large-scale image
classiﬁcation. International Conference on Machine Learn-
ing (ICML), 48:612–621, 2016.

9096

