Exploiting Kernel Sparsity and Entropy for Interpretable CNN Compression

Yuchao Li1#, Shaohui Lin1#, Baochang Zhang3, Jianzhuang Liu4,
David Doermann5, Yongjian Wu6, Feiyue Huang6, Rongrong Ji1,2 ∗

1Fujian Key Laboratory of Sensing and Computing for Smart City, Department of Cognitive Science,

School of Information Science and Engineering, Xiamen University, Xiamen, China

2Peng Cheng Laboratory, Shenzhen, China, 3Beihang University, China, 4Huawei Noah’s Ark Lab

5University at Buffalo, USA, 6BestImage, Tencent Technology (Shanghai) Co.,Ltd, China

xiamenlyc@gmail.com, shaohuilin007@gmail.com, bczhang@buaa.edu.cn, liu.jianzhuang@huawei.com,

doermann@buffalo.edu, littlekenwu@tencent.com, garyhuang@tencent.com, rrji@xmu.edu.cn

Abstract

Compressing convolutional neural networks (CNNs) has
received ever-increasing research focus. However, most ex-
isting CNN compression methods do not interpret their in-
herent structures to distinguish the implicit redundancy. In
this paper, we investigate the problem of CNN compression
from a novel interpretable perspective. The relationship be-
tween the input feature maps and 2D kernels is revealed
in a theoretical framework, based on which a kernel spar-
sity and entropy (KSE) indicator is proposed to quantitate
the feature map importance in a feature-agnostic manner
to guide model compression. Kernel clustering is further
conducted based on the KSE indicator to accomplish high-
precision CNN compression. KSE is capable of simultane-
ously compressing each layer in an efﬁcient way, which is
signiﬁcantly faster compared to previous data-driven fea-
ture map pruning methods. We comprehensively evaluate
the compression and speedup of the proposed method on
CIFAR-10, SVHN and ImageNet 2012. Our method demon-
strates superior performance gains over previous ones. In
particular, it achieves 4.7× FLOPs reduction and 2.9×
compression on ResNet-50 with only a Top-5 accuracy drop
of 0.35% on ImageNet 2012, which signiﬁcantly outper-
forms state-of-the-art methods.

1. Introduction

Deep convolutional neural networks (CNNs) have
achieved great success in various computer vision tasks,
including object classiﬁcation [5, 9, 12, 34], detection
[31, 32] and semantic segmentation [2, 23]. However,
deep CNNs typically require high computation overhead

#Equal contribution.
∗Corresponding author.

Figure 1. The relationship between an input feature map and its
corresponding 2D kernels is investigated. We introduce the kernel
sparsity and entropy (KSE) to represent the sparsity and informa-
tion richness of the input feature maps.

and large memory footprint, which prevents them from be-
ing directly applied on mobile or embedded devices. As a
result, extensive efforts have been made for CNN compres-
sion and acceleration, including low-rank approximation
[13, 17, 18, 39], parameter quantization [11, 47] and bina-
rization [30]. One promising direction to reduce the redun-
dancy of CNNs is network pruning [3, 4, 7, 10, 20, 24, 43],
which can be applied to different elements of CNNs such as
the weights, the ﬁlters and the layers.

Early works in network pruning [3, 4] mainly resort to
removing less important weight connections independently
with precision loss as little as possible. However, these un-
structured pruning methods require specialized software or
hardware designs to store a large number of indices for ef-
ﬁcient speedup. Among them, ﬁlter pruning has received
ever-increasing research attention, which can simultane-
ously reduce computation complexity and memory over-
head by directly pruning redundant ﬁlters, and is well sup-
ported by various off-the-shelf deep learning platforms. For

51202800

SparsityInformation richnessConv LayerSparsityEntropy2D kernelsFeature map*=Figure 2. The framework of our method. The convolution operation is split into two parts, 2D convolution and channel fusion (addition).
The 2D convolution is used to extract features from each input feature map, and the channel addition is used to obtain an output feature
map by summing the intermediate results of the 2D convolution across all the input feature maps. In our KSE method, we ﬁrst obtain the
2D kernels corresponding to an input feature map and calculate their sparsity and entropy as an indicator, which is further used to reduce
the number of the 2D kernels by kernel clustering and generate a compact network.

[27] calculated the effect of
instance, Molchanov et al.
ﬁlters on the network loss based on a Taylor expansion.
Luo et al. [24] proposed to remove redundant ﬁlters based
on a greedy channel selection. Those methods directly
prune ﬁlters and their corresponding output feature maps
in each convolutional layer, which may lead to dimensional
mismatch in popular multi-branch networks, e.g., ResNets
[5]. For example, by removing the output feature maps
in the residual mapping, the “add” operator cannot be im-
plemented due to different output dimensions between the
identity mapping and the residual mapping in ResNets. In-
stead, several channel pruning methods [8, 22] focus on the
input feature maps in the convolutional layers, which do not
modify the network architecture and operator when reduc-
ing the network size and FLOPs1. However, through di-
rectly removing the input feature maps, this approach typi-
cally has limited compression and speedup with signiﬁcant
accuracy drop.

In this paper, we investigate the problem of CNN com-
pression from a novel interpretable perspective. We argue
that interpreting the inherent network structure provides a
novel and fundamental means to discover the implicit net-
work redundancy. As investigated in network explanation
[15, 28, 46], individual feature maps within and across dif-
ferent layers play different roles in the network. As an intu-
itive example, feature maps in different layers can be seen
as hierarchical features, e.g., features like simple structures
in the bottom layers, and semantic features in the top lay-
ers. Even in the same layer, the importance of feature maps
varies; the more information a feature map represents, the
more important it is for the network. To this end, interpret-
ing the network, especially the feature map importance, if
possible, can well guide the quantization and/or pruning of
the network elements.

We here have the ﬁrst attempt to interpret the network

1FLOPs: The number of ﬂoating-point operations

structure towards fast and robust CNN compression. In par-
ticular, we ﬁrst introduce the receptive ﬁeld of a feature map
to reveal the sparsity and information richness, which are
the key elements to evaluate the feature map importance.
Then, as shown in Fig. 1, the relationship between an in-
put feature map and its corresponding 2D kernels is inves-
tigated, based on which we propose kernel sparsity and en-
tropy (KSE) as a new indicator to efﬁciently quantitate the
importance of the input feature maps in a feature-agnostic
manner. Compared to previous data-driven compression
methods [6, 7, 24], which need to compute all the feature
maps corresponding to the entire training dataset to achieve
a generalized result, and thus suffer from heavy computa-
tional cost for a large dataset, KSE can efﬁciently handle
every layer in parallel in a data-free manner. Finally, we
employ kernel clustering to quantize the kernels for CNN
compression, and ﬁne-tune the network with a small num-
ber of epochs.

We demonstrate the advantages of KSE using two
widely-used models (ResNets and DenseNets) on three
datasets (CIFAR-10, SVHN and ImageNet 2012). Com-
pared to the state-of-the-art methods, KSE achieves supe-
rior performance. For ResNet-50, we obtain 4.7× FLOPs
reduction and 2.9× compression with only 0.35% Top-5
accuracy drop on ImageNet. The compressed DenseNets
achieve much better performance than other compact net-
works (e.g., MobileNet V2 and ShufﬂeNet V2) and auto-
searched networks (e.g., MNASNet and PNASNet).

The main contributions of our paper are three-fold:

• We investigate the problem of CNN compression from
a novel interpretable perspective, and discover that the
importance of a feature map depends on its sparsity
and information richness.

• Our method in Fig. 2 is feature-agnostic that only
needs the 2D kernels to calculate the importance of
the input feature maps, which differs from the exist-

51212801

SparsityEntropy2D kernelsIndicator【】【】【】Kernel clustering0.530.970.07Inputfeature maps Outputfeature maps2D convresultChannel addition2D kernelsFilters*=Inputfeature maps 2D kernels*=Outputfeature maps2D convresultChannel additionSparsityEntropySparsityEntropyKSEOriginalconvolutional layerCompressedconvolutional layer0.970.530.07ing data-driven methods based on directly evaluating
the feature maps [6, 7, 24]. It can thus simultaneously
handle all the layers efﬁciently in parallel.

• Kernel clustering is proposed to replace the common
kernel pruning methods [26, 38], which leads to a
higher compression ratio with only slight accuracy
degradation.

2. Related Work

In this section, we brieﬂy review related work of net-
work pruning for CNN compression that removes redun-
dant parts, which can be divided into unstructured pruning
and structured pruning.

Unstructured pruning is to remove unimportant weights
independently. Han et al.
[3, 4] proposed to prune the
weights with small absolute values, and store the sparse
structure in a compressed sparse row or column format.
Yang et al.
[42] proposed an energy-aware pruning ap-
proach to prune the unimportant weights layer-by-layer by
minimizing the error reconstruction. Unfortunately, these
methods need a special format to store the network and the
speedup can only be achieved by using speciﬁc sparse ma-
trix multiplication in the special software or hardware.

By contrast, structured pruning directly removes struc-
tured parts (e.g., kernels, ﬁlters or layers) to simultane-
ously compress and speedup CNNs and is well supported
by various off-the-shelf deep learning libraries. Li et al.
[14] proposed to remove unimportant ﬁlters based on the
ℓ1-norm. Hu et al.
[7] computed the Average Percent-
age of Zeros (APoZ) of each ﬁlter, which is equal to the
percentage of zero values in the output feature map cor-
responding to the ﬁlter. Recently, Yoon et al.
[43] pro-
posed a group sparsity regularization that exploits correla-
tions among features in the network. He et al. [6] proposed
a LASSO regression based channel selection, which uses
least square reconstruction to prune ﬁlters. Differently, Lin
et al.
[19] proposed a global and dynamic training algo-
rithm to prune unsalient ﬁlters. Although ﬁlter pruning ap-
proaches in [6, 7, 19, 24, 43] can reduce the memory foot-
print, they encounter a dimensional mismatch problem for
the popular multi-branch networks, e.g., ResNets [5]. Our
method differs from all the above ones, which reduces the
redundancy of 2D kernels corresponding to the input fea-
ture maps and do not modify the output of a convolutional
layer to avoid the dimensional mismatch.

Several channel pruning methods [8, 22] are more suit-
able for the widely-used ResNets and DenseNets. These
methods remove unimportant input feature maps of convo-
lutional layers, and can avoid dimensional mismatch. For
example, Liu et al. [22] imposed ℓ1-regularization on the
scaling factors on the batch normalization to select unim-
portant feature maps. Huang et al. [8] combined the weight
pruning and group convolution to sparsify networks. These

Figure 3. Visualization of the receptive ﬁelds (in the resolution of
the input image) of three feature maps in the network.

channel pruning methods obtain a sparse network based on
a complex training procedure that requires signiﬁcant cost
of ofﬂine training. Unlike these methods, our approach de-
termines the importance of the feature maps in a novel in-
terpretable perspective and calculates them by their corre-
sponding kernels without extra training, which is signiﬁ-
cantly faster to implement CNNs compression.

Besides the network pruning, our work is also related to
some other methods [35, 37, 40]. Wu et al. [40] quanti-
ﬁed ﬁlters in convolutional layers and weight matrices in
fully-connected layers by minimizing the reconstruction er-
ror. However, they do not consider the different importance
of input feature maps, and instead the same number of quan-
tiﬁcation centroids. Wu et al. [41] applied k-means cluster-
ing on the weights to compress CNN, which needs to set
the different number of cluster centroids. Son et al. [35]
compressed the network by using a small amount of spatial
convolutional kernels to minimize the reconstruction error.
However, it is mainly used for 3 × 3 kernels and difﬁcult to
compress 1 × 1 kernels. In contrast, our KSE method can
be applied to all layers.

Note that our approach can be further integrated with
other strategies to obtain more compact networks, such as
low-rank approximation [16, 17, 18, 39] and compact archi-
tecture design [25, 33].

3. Interpretation of Feature Maps

Towards identifying feature map importance on the net-
work, the work in [1] uses bilinear interpolation to scale
the feature maps up to the resolution of the input image.
Then, a threshold determined by a top quantile level is used
to obtain the receptive ﬁeld of the feature maps, which can
be regarded as a binary mask. Following this principle, as
shown in Fig. 3, for the input feature maps from the same
convolutional layer, we compute their corresponding recep-
tive ﬁelds on the original input image. These receptive ﬁelds
indicate the different information contained in these feature
maps. The visualization results in the lower part of the red
box in Fig. 3 can be interpreted as an indicator of the feature
map importance, where the left one is the most important

51222802

……Conv-layer-1Conv-layer-L’Conv-layer-LFC-layersOutputInput imageHeat mapReceptive fields of the feature mapsamong the three while the right one is unimportant.

To quantify such an interpretation, we ﬁrst compute the
heat map of the original input image, which represents the
information distribution [45]. We use the output feature
maps of the last convolutional layer in the network, and add
them together on the channel dimension. Then we scale the
sumed feature map to the resolution of the input image by
bilinear interpolation. Each pixel value Hi,j in the heat map
H represents the importance of this pixel in the input image.
Finally, we compute the receptive ﬁeld of a feature map on
the heat map. As shown in Fig. 3, the red part in a recep-
tive ﬁeld can quantify the interpretation of the correspond-
ing feature map. To this end, the information contained in
a feature map can be viewed as the sum of the products be-
tween the elements of the mask and the heat map:

Him
X

Wim
X

i=1

j=1

Hi,jMi,j ,

(1)

where Him and Wim denote the resolution (height and
width) of the input image, and M is the binary mask gener-
ated by the feature map. Eq. 1 can be rewritten as:

I{M = 1}H,

(2)
where I{M = 1} is the number of the elements in M with
value 1, which can be viewed as the area of the receptive
ﬁeld that depends on the sparsity of the feature map, and
H is the average of all entry Hi,j whose corresponding el-
ement in M is 1. The heat map represents the information
distribution in the input image. The higher the value of an
element in Hi,j is, the more information this element con-
tains. Therefore, H can represent the information richness
in the feature map. Eq. 2 indicates that the importance of
a feature map depends on its sparsity and information rich-
ness. However, if we simply use Eq. 2 to compute the im-
portance of each feature map, it suffers from heavy compu-
tation cost, since we need to compute all the feature maps
with respect to the entire training dataset to obtain a com-
parative generalized result.

4. Proposed Method

To handle the above issue, we introduce the kernel spar-
sity and entropy (KSE), which serves as an indicator to rep-
resent the sparsity and information richness of input feature
maps in a feature-agnostic manner. It is generic, and can be
used to compress fully-connected layers by treating them as
1 × 1 convolutional layers.

Generally, a convolutional layer transforms an input
tensor X ∈ RC×Hin×Win into an output tensor Y ∈
RN ×Hout×Wout by using the ﬁlters W ∈ RN ×C×Kh×Kw .
Here, C is the number of the input feature maps, N is the
number of the ﬁlters, and Kh and Kw are the height and
width of a ﬁlter, respectively. The convolution operation
can be formulated as follows:

Yn =

C

X

c=1

Wn,c ∗ Xc,

(3)

where ∗ represents the convolution operation, and Xc and
Yc are the channels (feature maps) of X and Y, respectively.
For simplicity, the biases are omitted for easy presentation.
For an input feature map Xc, we call the set {Wn,c}N
n=1 the
corresponding 2D kernels of Xc.

4.1. Kernel Sparsity

We measure the sparsity of an input feature map (i.e.
I{M = 1}) by calculating the sparsity of its correspond-

ing 2D kernels, i.e., the sum of their ℓ1-norms Pn |Wn,c|.

Although these kernels do not participate in generating the
input feature map, the sparsity between input feature map
and its corresponding 2D kernels is closely related.

During training, the update of the 2D kernel Wn,c de-
and the weight decay R(Wn,c):

pends on the gradient

∂L

∂Wn,c

W (t+1)

n,c = W (t)

n,c − η

∂L

∂W (t)

n,c

−

∂R(W (t)
n,c)
∂W (t)

n,c

= W (t)

n,c − η

∂L
∂Y (t)

n

X (t)

c −

∂R(W (t)
n,c)
∂W (t)

n,c

,

(4)

where L represents the loss function and η is the learning
rate. If the input feature map X (t)
is sparse, the kernel’s gra-
dient is relatively small, and the update formula becomes:

c

W (t+1)

n,c ≈ W (t)

n,c −

∂R(W (t)
n,c)
∂W (t)

n,c

.

(5)

n,c

| → 0 with the iterations if R(W (t)

Note that |W (t+1)
n,c) is
deﬁned based on the ℓ2-regularization, which may make the
kernel being sparse [44]. Thus, the kernel corresponding to
the sparse input feature map may be sparse during training.
Therefore, for the c-th input feature map, we deﬁne its spar-
sity as:

sc =

N

X

n=1

|Wn,c|.

(6)

To the best of our knowledge, we are the ﬁrst to build
the relationship between the input feature maps (rather than
the output feature maps) and the kernels in terms of spar-
sity. Note that this sparsity relation has been veriﬁed in our
experiments shown in Section 5.2.

4.2. Kernel Entropy

For a convolutional layer, if the convolutional results
from a single input feature map are more diversiﬁed, this
feature map contains more information and should be main-
tained in the compressed network. In this case, the distribu-
tion of the corresponding 2D kernels is more complicated.
Therefore, we propose a new concept called kernel entropy
to measure the information richness of an input feature map.

51232803

We ﬁrst construct a nearest neighbor distance matrix Ac
for the 2D kernels corresponding to the c-th input feature
map. For each row i and col j, if Wi,c and Wj,c are “close”2,
i.e., Wj,c is among the k nearest neighbours of Wi,c, then
Aci,j = kWi,c − Wj,ck, and Aci,j = 0 otherwise. We set k
to 5 empirically, which can achieve good results. Then we
calculate the density metric of each kernel by the number of
instances located in the neighborhood of this kernel:

dm(Wi,c) =

N

X

j=1

Aci,j .

(7)

The larger the density metric of Wi,c is, the smaller the den-
sity of Wi,c is, i.e., the kernel is away from the others, and
the convolutional result using Wi,c becomes more different.
Hence, we deﬁne the kernel entropy to measure the com-
plexity of the distribution of the 2D kernels:

ec = −

N

X

i=1

dm(Wi,c)

dc

log2

dm(Wi,c)

dc

,

(8)

where dc = PN

i=1 dm(Wi,c). The smaller the kernel en-
tropy is, the more complicated the distribution of the 2D
kernels is, and the more diverse the kernels are. In this case,
the features extracted by these kernels have greater differ-
ence. Therefore, the corresponding input feature map pro-
vides more information to the network.

4.3. Deﬁnition of the KSE Indicator

As discussed in Section 3, the feature map importance
depends on two parts, the sparsity and the information rich-
ness. Upon this discovery, we ﬁrst use the min-max nor-
malization sc and ec into [0, 1] to make them in the same
scale. Then we combine the kernel sparsity and entropy to
measure the overall importance of an input feature map by:

vc = r sc

1 + αec

,

(9)

where α is a parameter to control the balance between the
sparsity and entropy, which is set to 1 in this work. We
call vc the KSE indicator that measures the interpretabil-
ity and importance of the input feature map. We further
use the min-max normalization to rescale the indicators to
[0, 1] based on all the input feature maps in one convolu-
tional layer.

4.4. Kernel Clustering

To compress kernels, previous channel pruning methods
divide channels into two categories based on their impor-
tance, i.e., important or unimportant ones. Thus, for an in-
put feature map, its corresponding 2D kernels are either all
kept or all deleted, which is a coarse compression. In our

2Let W

′
i,c and W

′
j,c be two vectors formed by the elements of Wi,c
and Wj,c, respectively. Then the distance between Wi,c and Wj,c is de-
ﬁned as the distance between W

′
i,c and W

′
j,c.

work, through clustering, we develop a ﬁne-grained com-
pression scheme to reduce the number of the kernels where
after pruning, the number is an integer between 0 and N
(but not just 0 or N as in the previous methods).

First, we decide the number of kernels required for their

corresponding c-th input feature map as:

qc = 


0,
N,

(cid:6)

N

2G−⌈vcG⌉+T (cid:7),

⌊vcG⌋ = 0,
⌈vcG⌉ = G,
otherwise,

(10)

where G controls the level of compression granularity. A
larger G results in a ﬁner granularity. N is the number of the
original 2D kernels and T is a hyper-parameter to control
the compression and acceleration ratios.

(cid:8)In,c ∈ {1, 2, ..., qc}(cid:9)N

Second, to guarantee each output feature map contains
the information from most input feature maps, we choose
to cluster, rather than pruning, the 2D kernels to reduce
the kernel number.
It is achieved simply by the k-means
algorithm with the number of cluster centroids equal to
qc. Thus, the c-th input feature map generates qc centroids
(new 2D kernels) {Bi,c ∈ RKh×Kw }qc
i=1 and an index set
to replace the original 2D ker-
n=1
nels {Wn,c ∈ RKh×Kw }N
n=1. For example, I1,c = 2 de-
notes that the ﬁrst original kernel is classiﬁed to the second
cluster B2,c. When qc = 0, the c-th input feature map is
considered as unimportant, it and all its corresponding ker-
nels are pruned. In the other extreme case where qc = N ,
this feature map is considered as most important for the con-
volutional layer, and all its corresponding kernels are kept.
There are three steps in our training procedure. (i) Pre-
train a network on a dataset. (ii) Compress the network (in
all the convolutional and fully-connected layers) using the
method proposed above and obtain qc, Bi,c and In,c. (iii)
Fine-tune the compressed network for a small number of
epochs. During the ﬁne-tuning, we only update the cluster
centroids.

In inference, our method accelerates the network by
sharing the 2D activation maps extracted from the input fea-
ture maps to reduce the computation complexity of convolu-
tion operations. Note that here the activation maps (yellow
planes in Fig. 2) are not the output feature maps (orange
planes in Fig. 2). As shown in Fig. 2, we split the convolu-
tional operation into two parts, 2D convolution and channel
fusion. In 2D convolution, the responses from each input
feature map are computed simultaneously to generate the
2D activation maps. The c-th input feature map corresponds
to the qc 2D kernels, which generates qc 2D activation maps
Zi,c = Bi,c∗Xc. Then, in the channel addition, we compute
Yn by summing their corresponding 2D activation maps:

Yn =

C

X

c=1

ZIn,c,c.

(11)

51242804

1.2

1.0

0.8

0.6

0.4

0.2

0.0

y
t
i
s
r
a
p
S
 
p
a
M
 
e
r
u
t
a
e
F
 
t
u
p
n

I

1.2

1.0

0.8

0.6

0.4

0.2

0.0

 
p
a
M
 
e
r
u
t
a
e
F
 
t
u
p
n

I

s
s
e
n
h
c
i
R
 
n
o
i
t
a
m
r
o
f
n
I
 

−0.2

−0.2

0.0

0.2

0.4

0.6

0.8

1.0

1.2

−0.2

−0.2

0.0

0.2

0.4

0.6

0.8

1.0

1.2

Kernel Sparsity

Kernel Entropy

Figure 4. Left: Relationship between the sparsity of the input fea-
ture maps and their corresponding kernel sparsity. Right: Re-
lationship between the information richness of the input feature
maps and their corresponding kernel entropy.

5. Experiments

We have implemented our method using Pytorch [29].
The effectiveness validation is performed on three datasets,
CIFAR-10, Street View House Numbers (SVHN), and Ima-
geNet ILSVRC 2012. CIFAR-10 has 32 × 32 images from
10 classes. The training set contains 50,000 images and
the test set contains 10,000 images. The SVHN dataset has
73,257 32 × 32 color digit images in the training set and
26,032 images in the test set. ImageNet ILSVRC 2012 con-
sists of 1.28 million images for training and 50,000 images
for validation over 1,000 classes.

All networks are trained using stochastic gradient de-
scent (SGD) with momentum set to 0.9. On CIFAR-10 and
SVHN, we respectively train the networks for 200 and 20
epochs using the mini-batch size of 128. The initial learn-
ing rate is 0.01 and is multiplied by 0.1 at 50% of the total
number of epochs. On ImageNet, we train the networks
for 21 epochs with the mini-batch size of 64, and the initial
learning rate is 0.001 which is divided by 10 at epoch 7 and
14. Because the ﬁrst layer has only three input channels and
the last layer is a classiﬁer in ResNet and DenseNet, we do
not compress the ﬁrst and the last layers of the networks.

In our method, we use T to control the compression and
acceleration ratios, which determines the number of 2D ker-
nels after compression. In experiments, we set T to 0 for
ResNet-56, DenseNet-40-12 and DenseNet-100-12 on both
CIFAR-10 and SVHN to achieve better accuracies, and set
T to 1 for ResNet-50 and all the DenseNets on ImageNet
2012 to achieve lower compression ratios.

5.1. Compression and Acceleration Ratios

In this section, we analyze the compression and accelera-
tion ratios. For a convolutional layer, the size of the original
parameters is N × C × Kh × Kw and each weight is as-
sumed to require 32 bits. We store qc cluster centroids, each
weight of which again requires 32 bits. Besides, each index
per input feature map takes log2qc bits. The size of each
centroid is Kh × Kw, and each input feature map needs N
indices for the correspondence. Therefore, we can calculate
the compression ratio rcomp for each layer by:

rcomp =

N CKhKw

(qcKhKw + N log2qc

32

P

c

.

)

(12)

We can also accelerate the compressed network based on
the sharing of the convolution results. As mentioned in Sec-
tion 4.4, we compute all the intermediate features from the
input feature maps, and then add the corresponding features
for each output feature map. The computation is mainly
consumed by convolution operations. Thus, the theoretical
acceleration ratio racce of each convolutional layer is com-
puted by:

racce ≃

N CHoutWoutKhKw
P
qcHoutWoutKhKw

c

=

.

N C
P
qc

c

(13)

We can also calculate the compression and acceleration
ratios on fully-connected layers by treating them as 1 × 1
convolutional layers.

5.2. Relationship between Input Feature Maps and

their Corresponding Kernels

We calculate the sparsity I{M = 1} and information
richness H of the input feature maps, and their correspond-
ing kernel sparsity and entropy. The relationships are shown
in Fig. 4 where the feature maps are a random subset of all
the feature maps from ResNet-56 on CIFAR-10. We can
see that the sparsity of the input feature maps and the ker-
nel sparsity increase simultaneously, while the information
richness of the input feature maps decreases as the kernel
entropy increases.

We can further use the Spearman correlation coefﬁcient

ρ to quantify these relationships:

ρ =

Pi(xi − x)(yi − y)

pPi(xi − x)2 Pi(yi − y)2

,

(14)

where x and y are the averages of the random variables x
and y, respectively. The correlation coefﬁcient for the re-
lationship on the left of Fig. 4 is 0.833, while the correla-
tion coefﬁcient for the relationship on the right of Fig. 4 is
−0.826. These values conﬁrm the positive correlation for
the ﬁrst and the negative correlation for the second.

5.3. Comparison with State of the Art Methods

CIFAR-10. We compare our method with [6, 14] on
ResNet-56, and with [8, 22, 35] on DenseNet. For ResNet-
56, we set G to two values (4 and 5) to compress the net-
work. For DenseNet-40-12 and DenseNet-BC-100-12, we
set G to another two values (3 and 6). As shown in Table 1
and Table 2, our method achieves the best results, compared
to the ﬁlter pruning methods [6, 14] on ResNet-56 and the
channel pruning methods [8, 22] on DenseNet. Moreover,
our method also achieves better results than other kernel
clustering methods [35] on DenseNet-BC-100-12. Com-
pared to Son et al.
[35], our KSE method can not only

51252805

Model

ResNet-56baseline

ResNet-56-pruned-A [14]
ResNet-56-pruned-B [14]

ResNet-56-pruned [6]

KSE (G=4)
KSE (G=5)

FLOPs
(racce)

125M(1.0×)
112M(1.1×)
90M(1.4×)
62M(2.0×)
60M(2.1×)
50M((2.5×)

#Param.
(rcomp)

0.85M(1.0×)
0.77M(1.1×)
0.73M(1.2×)

-

0.43M(2.0×)
0.36M(2.4×)

Top-1
Acc%
93.03
93.10
93.06
91.80
93.23
92.88

Model

ResNet-50baseline

GDP-0.6 [19]

ResNet-50(2×) [6]

ThiNet-50 [24]
ThiNet-30 [24]

KSE (G=5)
KSE (G=6)

FLOPs
(racce)

4.10B(1.0×)
1.88B(2.2×)
2.73B(1.5×)
1.71B(2.4×)
1.10B(3.7×)
1.09B(3.8×)
0.88B(4.7×)

#Param.
(rcomp)

25.56M(1.0×)

-
-

12.38M(2.0×)
8.66M(3.0×)
10.00M(2.6×)
8.73M(2.9×)

Top-1
Acc%
76.15
71.89
72.30
71.01
68.42
75.51
75.31

Top-5
Acc%
92.87
90.71
90.80
90.02
88.30
92.69
92.52

Table 1. Results of ResNet-56 on CIFAR-10.
ﬁgures, M/B means million/billion.

In all tables and

Table 4. Results of ResNet-50 on ImageNet2012.

Model

DenseNet-40baseline

DenseNet-40 (40%) [22]
DenseNet-40 (70%) [22]

KSE (G=3)
KSE (G=6)

DenseNet-BC-100baseline

DenseNet-PC128N [35]
CondenseNetlight-94 [8]

KSE (G=3)
KSE (G=6)

FLOPs
(racce)

283M(1.0×)
190M(1.5×)
120M(2.4×)
170M(1.7×)
115M(2.5×)

288M(1.0×)
212M(1.4×)
122M(2.4×)
159M(1.8×)
103M(2.8×)

#Param.
(rcomp)

1.04M(1.0×)
0.66M(1.6×)
0.35M(3.0×)
0.63M(1.7×)
0.39M(2.7×)

0.75M(1.0×)
0.50M(1.5×)
0.33M(2.3×)
0.45M(1.7×)
0.31M(2.4×)

Table 2. Results of DenseNet on CIFAR-10.

Model

DenseNet-40baseline

DenseNet-40 (40%) [22]
DenseNet-40 (60%) [22]

KSE (G=4)
KSE (G=5)

FLOPs
(racce)

283M(1.0×)
185M(1.5×)
134M(2.1×)
147M(1.9×)
130M(2.2×)

#Param.
(rcomp)

1.04M(1.0×)
0.65M(1.6×)
0.44M(2.4×)
0.49M(2.1×)
0.42M(2.5×)

Table 3. Results of DenseNet-40-12 on SVHN.

Top-1
Acc%
94.81
94.81
94.35
94.81
94.70

95.45
95.43
95.00
95.49
95.08

Top-1
Acc%
98.17
98.21
98.19
98.27
98.25

compress the 3 × 3 convolutional layers, but also the 1 × 1
convolutional layers to obtain a more compact network.

SVHN. We also evaluate the performance of KSE on
DenseNet-40-12 on SVHN. We set G to two values, 4 and
5. As shown in Table 3, our method achieves better perfor-
mance than the channel pruning method [22]. For example,
compared to He et al. [22], we obtain 0.06% increase in
Top-1 accuracy (98.25% vs. 98.19%) with higher compres-
sion and acceleration ratios (2.5× and 2.2× vs. 2.4× and
2.1×).

ImageNet 2012. We set G to 4 and 5, and compare our
KSE method with three state-of-the-art methods [6, 19, 24].
As show in Table 4, Our method achieves the best perfor-
mance with only a decrease of 0.35% in Top-5 accuracy by a
factor of 2.9× compression and 4.7× speedup. These state-
of-the-art methods perform worse mainly because they use
dichotomy to compress networks, i.e., prune or keep the ﬁl-
ters/channels, which leads to the loss of some important in-
formation in the network. Besides, ﬁlter pruning methods
like [19, 24] cannot be applied to some convolutional layers
due to the dimensional mismatch problem on ResNets with
a multi-branch architecture.

121
169
201

DenseNet
KSE

4

)
B
3
(
.
s
P
O
L
F
2

121
169
201

DenseNet
KSE

20

)

M

(
.

15

m
a
r
a
P
#

10

5

74

75
76
Top-1 Acc(%)

77

74

75
76
Top-1 Acc(%)

77

Figure 5. Parameter and FLOPs amount comparison between the
original DenseNets and the compressed DenseNets by our KSE.

For DenseNets, we set G to 4, and compress them
with three different numbers of layers, DenseNet-121,
DenseNet-169, and DenseNet-201. As shown in Fig. 5, the
compressed networks by KSE is on par with the original
networks, but achieves almost 2× parameter compression
and speedup.

In Fig. 6.

Recently, many compact networks [25, 33] have been
proposed to be used on mobile and embedded devices. In
addition, auto-search algorithms [21, 36] have been pro-
posed to search the best network architecture by reinforce-
ment learning. We compare the compressed DenseNet-121
and DenseNet-169 by KSE with these methods [8, 21, 25,
‘A’ represents G = 4 and ‘B’ rep-
33, 36].
resents G = 3. We use KSE to compress DenseNets,
which achieves more compact results. For example, we
obtain 73.03% Top-1 accuracy with only 3.37M parame-
ters on ImageNet 2012. Our KSE uses different numbers
of 2D kernels for different input feature maps to do con-
volution, which reduces more redundant kernels, compared
to the complicated auto-search algorithms which only use
the traditional convolutional layer. Besides, the widely-
used depth-wise convolution on MobileNet or ShufﬂeNet
may cause signiﬁcant information loss, due to only one 2D
kernel is used to extract features from each feature map.

5.4. Ablation Study

The effective use of KSE, is related to G. We select
ResNet-56 and DenseNet-40 on CIFAR-10, and ResNet-50
and DenseNet-121 on ImageNet2012 to evaluate G. More-
over, we analyze three different indicators.

5.4.1 Effect of the Compression Granularity G

In our kernel clustering, we use G to control the level of
compression granularity. The results of different G are

51262806

)

%

 

(
 
c
c
A
1
-
p
o
T

75.5
75.0
74.5
74.0
73.5
73.0
72.5
72.0

DenseNet169-A

ShuffleNetV2-2.0[   ]
25
MobileNetV2-1.4[   ]
33

DenseNet121-A

PNASNet[   ]
21
CondenseNet[   ]
8

DenseNet121-B
MnasNet-65[   ]
36
ShuffleNetV2-1.5[   ]
25

3

MobileNetV2-1[   ]
33
5
7
#Param. (M)

4

6

8

9

Figure 6. Comparison of the compressed DenseNets (red circles)
by our KSE and other compact networks (blue circles).

93.5

93.0

92.5

92.0

91.5

)

%

 

(
 
c
c
A
1
-
p
o
T

Sparsity
Entropy
KSE

G=2
G=3
G=4
G=5
G=6
0.200.250.300.350.400.450.500.55

#Param. (M)

)

%

 

(
 
c
c
A
1
-
p
o
T

93.5
93.0
92.5
92.0
91.5
91.0
90.5
90.0

Sparsity
Entropy
KSE

30

G=2
G=3
G=4
G=5
G=6
70

60

40

50

FLOPs (M)

Figure 7. Compression granularity and indicator analysis with
ResNet-56 on CIFAR-10.

shown in Fig. 7. Note that in this sub-section, only the red
solid circles in Fig. 7 are concerned. When G = 2, the 2D
kernels corresponding to the c-th feature map are divided
into two categories: qc = 0 or qc = N for pruning or keep-
ing all the kernels. It is a coarse-grained pruning method.
As G increases, qc achieves various different values, which
means to compress the 2D kernels in a ﬁne-grained man-
ner. In addition, the compression and acceleration ratios are
also increased. Compared to the coarse-grained pruning,
the ﬁne-grained pruning achieves much better results. For
example, when G = 4, it achieves the same compression
ratio as G = 2 with 0.52% Top-1 accuracy increase.

5.4.2

Indicator Analysis

In this paper, we have proposed three concepts, kernel spar-
sity, kernel entropy, and KSE indicator. In fact, all of them
can be used as an indicator to judge the importance of the
feature maps. We next evaluate these three indicators on
ResNet-56, with the proposed kernel clustering for com-
pression. As shown in Fig. 7, compared to the indicators
of kernel sparsity and kernel entropy, the KSE indicator
achieves the best results for different compression granu-
larities. This is due to the fact that the kernel sparsity only
represents the area of the receptive ﬁeld of a feature map,
and the density entropy of the 2D kernels only expresses
the position information of a receptive ﬁeld, which alone
are not as effective as KSE to evaluate the importance of a
feature map.

Figure 8. Visualization of the input feature maps and their KSE
indicator values at the Block1-Unit1-Conv2 layer of ResNet-50.

5.5. Visualization Analysis

We visualize the input feature maps and the correspond-
ing KSE indicator values at the Block1-Unit1-Conv2 layer
of ResNet-50 to reveal their connection. As shown in Fig.
8, the input image contains a bird. When the value of the
indicator is smaller, its corresponding feature map provides
less information of the bird. On the contrary, when the value
is close to 1, the feature map has both the bird and the back-
ground information. Therefore, our KSE method can accu-
rately discriminate the feature maps, and effectively judge
their importance.

6. Conclusion

In this paper, we ﬁrst investigate the problem of CNN
compression from a novel interpretable perspective and dis-
cover that the sparsity and information richness are the key
elements to evaluate the importance of the feature maps.
Then we propose kernel sparsity and entropy (KSE) and
combine them as an indicator to measure this importance
in a feature-agnostic manner. Finally, we employ kernel
clustering to reduce the number of kernels based on the
KSE indicator and ﬁne-tune the compressed network in
a few epochs. The networks compressed using our ap-
proach achieve better results than state-of-the-art methods.
For future work, we will explore a more rigorous theoreti-
cal proof with bounds/conditions to prove the relationship
between feature map and kernels. The code available at
https://github.com/yuchaoli/KSE.

Acknowledgments

This work is supported by the National Key R&D Pro-
gram (No.2017YFC0113000, and No.2016YFB1001503),
the Natural Science Foundation of China (No.U1705262,
No.61772443, No.61402388 and No.61572410), the Post
Doctoral Innovative Talent Support Program under Grant
BX201600094, the China Post-Doctoral Science Founda-
tion under Grant 2017M612134, Scientiﬁc Research Project
of National Language Committee of China (Grant No.
YB135-49), and Natural Science Foundation of Fujian
Province, China (No. 2017J01125 and No. 2018J01106).

51272807

References

[1] David Bau, Bolei Zhou, Aditya Khosla, Aude Oliva, and
Antonio Torralba. Network dissection: Quantifying inter-
pretability of deep visual representations. IEEE Conference
on Computer Vision and Pattern Recognition (CVPR), 2017.

[2] Liang-Chieh Chen, Yukun Zhu, George Papandreou, Florian
Schroff, and Hartwig Adam. Encoder-decoder with atrous
separable convolution for semantic image segmentation. Eu-
ropean Conference on Computer Vision (ECCV), 2018.

[3] Song Han, Huizi Mao, and William J Dally. Deep com-
pression: Compressing deep neural networks with pruning,
trained quantization and huffman coding. International Con-
ference on Learning Representations (ICLR), 2016.

[4] Song Han, Jeff Pool, John Tran, and William Dally. Learning
both weights and connections for efﬁcient neural network.
Advances in Neural Information Processing Systems (NIPS),
2015.

[5] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
Deep residual learning for image recognition. IEEE Confer-
ence on Computer Vision and Pattern Recognition (CVPR),
2016.

[6] Yihui He, Xiangyu Zhang, and Jian Sun. Channel pruning
International

for accelerating very deep neural networks.
Conference on Computer Vision (ICCV), 2017.

[7] Hengyuan Hu, Rui Peng, Yu-Wing Tai, and Chi-Keung
Tang. Network trimming: A data-driven neuron pruning ap-
proach towards efﬁcient deep architectures. arXiv preprint
arXiv:1607.03250, 2016.

[8] Gao Huang, Shichen Liu, Laurens Van der Maaten, and Kil-
ian Q Weinberger. Condensenet: An efﬁcient densenet using
learned group convolutions. IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), 2018.

[9] Gao Huang, Zhuang Liu, Laurens Van Der Maaten, and Kil-
ian Q Weinberger. Densely connected convolutional net-
works.
IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2017.

[10] Zehao Huang and Naiyan Wang. Data-driven sparse struc-
ture selection for deep neural networks. European Confer-
ence on Computer Vision (ECCV), 2018.

[11] Benoit Jacob, Skirmantas Kligys, Bo Chen, Menglong Zhu,
Matthew Tang, Andrew Howard, Hartwig Adam, and Dmitry
Kalenichenko. Quantization and training of neural networks
for efﬁcient integer-arithmetic-only inference. IEEE Confer-
ence on Computer Vision and Pattern Recognition (CVPR),
2017.

[12] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton.
Imagenet classiﬁcation with deep convolutional neural net-
works. Advances in Neural Information Processing Systems
(NIPS), 2012.

[13] Vadim Lebedev, Yaroslav Ganin, Maksim Rakhuba, Ivan Os-
eledets, and Victor Lempitsky. Speeding-up convolutional
neural networks using ﬁne-tuned cp-decomposition.
Inter-
national Conference on Learning Representations (ICLR),
2014.

[14] Hao Li, Asim Kadav, Igor Durdanovic, Hanan Samet, and
Hans Peter Graf. Pruning ﬁlters for efﬁcient convnets. In-

ternational Conference on Learning Representations (ICLR),
2016.

[15] Yixuan Li, Jason Yosinski, Jeff Clune, Hod Lipson, and
John E Hopcroft. Convergent learning: Do different neu-
ral networks learn the same representations? Advances in
Neural Information Processing Systems (NIPS), 2015.

[16] Shaohui Lin, Rongrong Ji, Chao Chen, and Feiyue Huang.
Espace: Accelerating convolutional neural networks via
eliminating spatial and channel redundancy. In AAAI Con-
ference on Artiﬁcial Intelligence AAAI, 2017.

[17] Shaohui Lin, Rongrong Ji, Chao Chen, Dacheng Tao, and
Jiebo Luo. Holistic cnn compression via low-rank decompo-
sition with knowledge transfer. IEEE transactions on pattern
analysis and machine intelligence, 2018.

[18] Shaohui Lin, Rongrong Ji, Xiaowei Guo, Xuelong Li, et al.
Towards convolutional neural networks compression via
global error reconstruction. International Joint Conference
on Artiﬁcial Intelligence (IJCAI), 2018.

[19] Shaohui Lin, Rongrong Ji, Yuchao Li, Yongjian Wu, Feiyue
Huang, and Baochang Zhang. Accelerating convolutional
networks via global & dynamic ﬁlter pruning. International
Joint Conference on Artiﬁcial Intelligence (IJCAI), 2018.

[20] Shaohui Lin, Rongrong Ji, Chenqian Yan, Baochang Zhang,
Liujuan Cao, Qixiang Ye, Feiyue Huang, and David Doer-
mann. Towards optimal structured cnn pruning via genera-
tive adversarial learning. In The IEEE Conference on Com-
puter Vision and Pattern Recognition (CVPR), 2019.

[21] Chenxi Liu, Barret Zoph, Jonathon Shlens, Wei Hua, Li-Jia
Li, Li Fei-Fei, Alan Yuille, Jonathan Huang, and Kevin Mur-
phy. Progressive neural architecture search. European Con-
ference on Computer Vision (ECCV), 2018.

[22] Zhuang Liu, Jianguo Li, Zhiqiang Shen, Gao Huang,
Shoumeng Yan, and Changshui Zhang. Learning efﬁcient
convolutional networks through network slimming. Interna-
tional Conference on Computer Vision (ICCV), 2017.

[23] Jonathan Long, Evan Shelhamer, and Trevor Darrell. Fully
convolutional networks for semantic segmentation.
IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2015.

[24] Jian-Hao Luo, Jianxin Wu, and Weiyao Lin. Thinet: A ﬁlter
level pruning method for deep neural network compression.
International Conference on Computer Vision (ICCV), 2017.
[25] Ningning Ma, Xiangyu Zhang, Hai-Tao Zheng, and Jian Sun.
Shufﬂenet v2: Practical guidelines for efﬁcient cnn archi-
tecture design. European Conference on Computer Vision
(ECCV), 2018.

[26] Huizi Mao, Song Han, Jeff Pool, Wenshuo Li, Xingyu Liu,
Yu Wang, and William J Dally. Exploring the regularity of
sparse structure in convolutional neural networks. Advances
in Neural Information Processing Systems (NIPS), 2017.

[27] Pavlo Molchanov, Stephen Tyree, Tero Karras, Timo Aila,
and Jan Kautz. Pruning convolutional neural networks for
resource efﬁcient transfer learning. CoRR, abs/1611.06440,
2016.

[28] Ari S Morcos, David GT Barrett, Neil C Rabinowitz, and
Matthew Botvinick. On the importance of single directions
for generalization.
International Conference on Learning
Representations (ICLR), 2018.

51282808

[44] Baochang Zhang, Alessandro Perina, Vittorio Murino, and
Alessio Del Bue. Sparse representation classiﬁcation with
manifold constraints transfer. IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), 2015.

[45] Bolei Zhou, Aditya Khosla, Agata Lapedriza, Aude Oliva,
and Antonio Torralba. Learning deep features for discrim-
inative localization. IEEE Conference on Computer Vision
and Pattern Recognition (CVPR), 2016.

[46] Bolei Zhou, Yiyou Sun, David Bau, and Antonio Torralba.
Revisiting the importance of individual units in cnns via ab-
lation. arXiv preprint arXiv:1806.02891, 2018.

[47] Shuchang Zhou, Yuxin Wu, Zekun Ni, Xinyu Zhou, He
Wen, and Yuheng Zou. Dorefa-net: Training low bitwidth
convolutional neural networks with low bitwidth gradients.
IEEE Conference on Computer Vision and Pattern Recogni-
tion (CVPR), 2016.

[29] Adam Paszke, Sam Gross, Soumith Chintala, Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Al-
ban Desmaison, Luca Antiga, and Adam Lerer. Automatic
differentiation in pytorch. Advances in Neural Information
Processing Systems (NIPS) Workshop, 2017.

[30] Mohammad Rastegari, Vicente Ordonez, Joseph Redmon,
and Ali Farhadi. Xnor-net: Imagenet classiﬁcation using bi-
nary convolutional neural networks. European Conference
on Computer Vision (ECCV), 2016.

[31] Joseph Redmon and Ali Farhadi. Yolo9000: better, faster,
stronger. IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), 2017.

[32] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun.
Faster r-cnn: towards real-time object detection with region
proposal networks. Advances in Neural Information Pro-
cessing Systems (NIPS), 2015.

[33] Mark Sandler, Andrew Howard, Menglong Zhu, Andrey Zh-
moginov, and Liang-Chieh Chen. Mobilenetv2: Inverted
residuals and linear bottlenecks. IEEE Conference on Com-
puter Vision and Pattern Recognition (CVPR), 2018.

[34] Karen Simonyan and Andrew Zisserman. Very deep convo-
lutional networks for large-scale image recognition. arXiv
preprint arXiv:1409.1556, 2014.

[35] Sanghyun Son, Seungjun Nah, and Kyoung Mu Lee. Cluster-
ing convolutional kernels to compress deep neural networks.
European Conference on Computer Vision (ECCV), 2018.

[36] Mingxing Tan, Bo Chen, Ruoming Pang, Vijay Vasudevan,
and Quoc V Le. Mnasnet: Platform-aware neural architec-
ture search for mobile. arXiv preprint arXiv:1807.11626,
2018.

[37] Frederick Tung and Greg Mori. Clip-q: Deep network com-
pression learning by in-parallel pruning-quantization. IEEE
Conference on Computer Vision and Pattern Recognition
(CVPR), 2018.

[38] Wei Wen, Chunpeng Wu, Yandan Wang, Yiran Chen, and
Hai Li. Learning structured sparsity in deep neural networks.
Advances in Neural Information Processing Systems (NIPS),
2016.

[39] Wei Wen, Cong Xu, Chunpeng Wu, Yandan Wang, Yiran
Chen, and Hai Li. Coordinating ﬁlters for faster deep neu-
ral networks. International Conference on Computer Vision
(ICCV), 2017.

[40] Jiaxiang Wu, Cong Leng, Yuhang Wang, Qinghao Hu, and
Jian Cheng. Quantized convolutional neural networks for
mobile devices. IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), 2016.

[41] Junru Wu, Yue Wang, Zhenyu Wu, Zhangyang Wang, Ashok
Veeraraghavan, and Yingyan Lin. Deep k-means: Re-
training and parameter sharing with harder cluster assign-
ments for compressing deep convolutions.
International
Conference on Machine Learning (ICML), 2018.

[42] Tien-Ju Yang, Yu-Hsin Chen, and Vivienne Sze. Designing
energy-efﬁcient convolutional neural networks using energy-
aware pruning. IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), 2016.

[43] Jaehong Yoon and Sung Ju Hwang. Combined group and
International

exclusive sparsity for deep neural networks.
Conference on Machine Learning (ICML), 2017.

51292809

