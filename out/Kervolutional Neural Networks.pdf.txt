Kervolutional Neural Networks

Chen Wang1

Jianfei Yang1

Lihua Xie1

Junsong Yuan2

chenwang@dr.com

yang0478@ntu.edu.sg

elhxie@ntu.edu.sg

jsyuan@buffalo.edu

1School of Electrical and Electronic Engineering, Nanyang Technological University, Singapore
2Computer Science and Engineering Department, State University of New York at Buffalo, USA

Abstract

Convolutional neural networks (CNNs) have enabled the
state-of-the-art performance in many computer vision tasks.
However, little effort has been devoted to establishing convo-
lution in non-linear space. Existing works mainly leverage
on the activation layers, which can only provide point-wise
non-linearity. To solve this problem, a new operation, ker-
volution (kernel convolution), is introduced to approximate
complex behaviors of human perception systems leveraging
on the kernel trick. It generalizes convolution, enhances the
model capacity, and captures higher order interactions of
features, via patch-wise kernel functions, but without intro-
ducing additional parameters. Extensive experiments show
that kervolutional neural networks (KNN) achieve higher
accuracy and faster convergence than baseline CNN.

1. Introduction

Convolutional neural networks (CNNs) have been tremen-
dously successful in computer vision, e.g. image recognition
[31, 20] and object detection [16, 42]. The core operator,
convolution, was partially inspired by the animal visual cor-
tex where different neurons respond to stimuli in a restricted
and partially overlaped region known as the receptive ﬁeld
[27, 28]. Convolution leverages on its equivariance to trans-
lation to improve the performance of a machine learning
system [18]. Its efﬁciency lies in that the learnable parame-
ters are sparse and shared across the entire input (receptive
ﬁeld). Nonetheless, convolution still has certain limitations,
which will be analyzed below. To address them, this paper in-
troduces kervolution to generalize convolution via the kernel
trick. The artiﬁcial neural networks containing kervolutional
layers are named as kervolutional neural networks (KNN).
There is circumstantial evidence that suggests most cells
inside striate cortex1 can be categorized as simple, complex,
and hypercomplex, with speciﬁc response properties [28].

1The striate cortex is the part of the visual cortex that is involved in

processing visual information.

However, the convolutional layers are linear and designed to
mimic the behavior of simple cells in human visual cortex
[57], hence they are not able to express the non-linear behav-
iors of the complex and hypercomplex cells inside the striate
cortex. It was also demonstrated that higher order non-linear
feature maps are able to make subsequent linear classiﬁers
more discriminative [37, 1, 9]. However, the non-linearity
that comes from the activation layers, e.g. rectiﬁed linear
unit (ReLU) can only provide point-wise non-linearity. We
argue that CNN may perform better if convolution can be
generalized to patch-wise non-linear operations via kernel
trick. Because of the increased expressibility and model
capacity, better model generalization may be obtained.

Non-linear generalization is simple in mathematics, how-
ever, it is generally difﬁcult to retain the advantages of con-
volution, i.e. (i) sharing weights (weight sparsity) and (ii)
low computational complexity. There exists several works
towards non-linear generalization. The non-linear convolu-
tional networks [57] implement a quadratic convolution at
the expense of additional n(n + 1)/2 parameters, where n is
the size of the receptive ﬁeld. However, the quadratic form
of convolution loses the property of "weight sparsity", since
the number of additional parameters of the non-linear terms
increases exponentially with the polynomial order, which
dramatically increases the training complexity. Another strat-
egy to introduce high order features is to explore the pooling
layers. The kernel pooling method in [9] directly concate-
nates the non-linear terms, while it requires the calculation
of non-linear terms, resulting in a higher complexity.

To address the above problems, kervolution is introduced
in this paper to extend convolution to kernel space while
keeping the aforementioned advantages of linear convolu-
tions. Since convolution has been applied to many ﬁelds,
e.g. image and signal processing, we expect kervolution will
also play an important role in those applications. However,
in this paper, we focus on its applications in artiﬁcial neural
networks. The contributions of this paper include: (i) via
kernel trick, the convolutional operator is generalized to ker-
volution, which retains the advantages of convolution and
brings new features, including the increased model capacity,

31

translational equivariance, stronger expressibility, and better
generalization; (ii) we provide explanations for kervolutional
layers from feature view and show that it is a powerful tool
for network construction; (iii) it is demonstrated that KNN
achieves better accuracy and surpasses the baseline CNN.

2. Related Work

As the name indicates, CNN [35] employs convolution as
the main operation, which is modeled to mimic the behavior
of simple cells found in the primary visual cortex known as
V1 [27, 28]. It have been tremendously successful in numer-
ous applications [33, 31, 20, 18]. Many strategies have been
applied to improve the capability of model generalization.

AlexNet [31] proves that the ensemble method "dropout"
is very effective for reducing over-ﬁtting of convolutional
networks. The non-saturated rectiﬁed linear unit (ReLU) dra-
matically improves the convergence speed [31] and becomes
a standard component of CNN. Network in network (NIN)
[36] establishes micro networks for local patches within the
receptive ﬁeld, each of which consists of multiple fully con-
nected layers followed by non-linear activation functions.
This improves the model capacity at the expense of addi-
tional calculation and complex structures. GoogLeNet [48]
increases both depth and width of CNN by introducing the
Inception model, which further improves the performance.
VGG [46] shows that deep CNN with small convolution
ﬁlters (3 × 3) is able to bring about signiﬁcant improvement.
ResNet [20] addresses the training problem of deeper
CNN and proposes to learn the residual functions with ref-
erence to the layer input. This strategy makes CNN easier
to optimize and improves regression accuracy with an in-
creased depth. DenseNet [25] proposes to connect each layer
to every other layer in a feed-forward fashion, which further
mitigates the problem of vanishing-gradient. The ResNeXt
[56] is constructed by repeating a building block that ag-
gregates a set of transformations with the same topology,
resulting in a homogeneous, multi-branch architecture. It
demonstrates the essence of a new dimension, which is the
size of the set of transformations. In order to increase the
representation power, SENet [24] focuses on channels and
adaptively recalibrates channel-wise feature responses by
explicitly modeling the interdependencies channels.

In recent years, researchers have been paying much at-
tentions on the extension of convolution. To enable the ex-
pressibility of convolution for complex cells, the non-linear
convolutional network [57] extends convolution to non-linear
space by directly introducing high order terms. However, as
indicated before, this introduces a large number additional
parameters and increases the training complexity exponen-
tially. To be invariant to spatial transformations, the spatial
transformer network [29] inserts learnable modules to CNN
for manipulating transformed data. For the same purpose,
deformable convolutional network [10] adds 2-D learnable

offsets to regular grid sampling locations for standard convo-
lution, which enables the learning of afﬁne transforms; while
[23] applies a simple two-parameter image warp before a
convolution. CapsNet [44] proposes to replace convolution
by representing the instantiation parameters of a speciﬁc
type of entity as activity vectors via a capsule structure. This
opens a new research space for artiﬁcial neural networks,
although its performance on large dataset is still relatively
weak. Decoupled network [38] interprets convolution as the
product of norm and cosine angle of the weight and input
vectors, resulting in explicit geometrical modeling of the
intra-class and extra-class variation. To process graph inputs,
Spline-CNN [14] extends convolution by using continuous
B-spline basis, which is parametrized by a constant number
of trainable control values. To decrease the storage, Modu-
lated CNN [55] extends the convolution operator to binary
ﬁlters, resulting in easier deployment on low power devices.

The kernel technique in this paper was applied to cre-
ate non-linear classiﬁers in the context of optimal margin
[4], which was later recognized as support vector machines
(SVM) [8]. It recently has also been widely applied to corre-
lation ﬁlter for improving the processing speed. For example,
the kernelized correlation ﬁlter (KCF) [22] is proposed to
speed up the calculation of kernel ridge regression by by-
passing a big matrix inversion, while it assumes that all
the data are circular shifts of each other [49], hence it can
only predict signal translation. To break this theoretical
limitation, the kernel cross-correlator (KCC) is proposed
in [54] by deﬁning the correlator in frequency domain di-
rectly, resulting in a closed-form solution with computational
complexity of O(N log N ), where N is the signal length.
Moreover, it does not impose any constraints on the training
data, thus KCC is useful for other applications [52, 50, 53]
and is applicable for afﬁne transform prediction, e.g. transla-
tion, rotation, and scale. This theorem is further extended to
speed up the prediction of joint rotation-scale transforms in
[51]. The above works show that the kernel technique is a
powerful tool for obtaining both accuracy and efﬁciency.

The kernel technique recently has also been applied to
artiﬁcial neural networks to improve the model performance.
The convolutional kernel network (CKN) [40] proposes to
learn transform invariance by kernel approximation, where
the kernel is used as a tool for learning CNN. Nevertheless,
the aim of CKN is not to extract non-linear features and
it is only different from CNN in the cost functions. The
SimNets [5] proposes to insert kernel similarity layers under
convolutional layer. However, both the similarity templates
and ﬁlters are needed to be trained and require a pre-training
process for initialization, which dramatically increases the
complexity. To capture higher order interactions of features,
the kernel pooling [9] is proposed in a parameter-free manner.
This is motivated by the aforementioned idea that higher
dimensional feature map produced by kernel functions is

32

able to make subsequent linear classiﬁer more discriminative
[1]. However, the kernel extension in the pooling stage is
not able to extract non-linear features in a patch-wise way.
Moreover, the additional higher order features are still need
to be calculated explicitly, which also dramatically improves
the complexity. To solve these problems, kervolution is
deﬁned to generalize convolution via the kernel trick.

3. Kervolution

We start from a convolution with output f (x), i.e.

f (x) = x ⊕ w,

(1)

where ⊕ is the convolutional operator and x ∈ Rn is a
vectorized input and w ∈ Rn is the ﬁlter. Speciﬁcally, the
ith element of the convolution output f (x) is calculated as:

fi(x) = (cid:10)x(i), w(cid:11) ,

(2)

where h · , · i is the inner product of two vectors and x(i) is
the circular shift of x by i elements. We deﬁne the index i
started from 0. The kervolution output g(x) is deﬁned as

g(x) = x ⊗ w,

(3)

where ⊗ is the kervolutional operator. Speciﬁcally, the ith
element of g(x) is deﬁned as:

gi(x) = (cid:10)ϕ(x(i)), ϕ(w)(cid:11) ,

(4)

where ϕ( · ) : Rn 7→ Rd (d ≫ n) is a non-linear mapping
function. The deﬁnition (4) enables us to extract features in
a high dimensional space, while its computational complex-
ity is also much higher than (2). Fortunately, we are able
to bypass the explicit calculation of the high dimensional
features ϕ(x(i)) via the kernel trick [8], since

(cid:10)ϕ(x(i)), ϕ(w)(cid:11) = X

cj(xT

(i)w)j = κ(x(i), w),

(5)

j

where κ( · , · ) : Rn × Rn 7→ R is a kernel function, whose
complexity is normally of O(n) as same as the inner product
of convolution. The coefﬁcient cj can be determined by the
mapping function ϕ( · ) or a predeﬁned kernel κ( · , · ), e.g.
the Gaussian RBF kernel, in which the feature dimension d
is inﬁnite. Intuitively, the inner product (2) is a linear kernel,
thus convolution is a linear case of kervolution.

The kervolution (3) retains the advantages of convolution
and brings new features: (i) sharing weights (Section 3.1);
(ii) equivariance to translation (Section 3.2); (iii) increased
model capacity and new feature similarity (Section 3.3);

that the number of elements in ﬁlter w is not increased
according to the deﬁnition of (5), thus kervolution keeps the
sparse connectivity of convolution. As a comparison, we take
the Volterra series-based non-linear convolution adopted in
[57] as an example, the additional parameters of non-linear
terms dramatically increase the training complexity, since
the number of learnable parameters increases exponentially
with the order of non-linearity. Even an quadratic expression
gv(x) in (6) from [57] is of complexity O(n2):

gv
i (x) = xT

(i)w2x(i) + wT

1 x(i),

(6)

where w1 ∈ Rn and w2 ∈ Rn×n are the linear and quadratic
ﬁlters, respectively. The quadratic term in (6) introduces
additional n(n + 1)/2 parameters (w2 is an upper triangular
matrix). Instead, a typical non-linear kernel is normally of
complexity O(n), i.e. the Gaussian RBF kernel, which is the
same with linear kernel (2), thus kervolution preserves the
linear computational complexity O(n).

Another strategy to introduce higher order features is to
explore the pooling layers. For example, the kernel pooling
method proposed in [9] directly concatenates the non-linear
terms cj(xT
(i)w)j as in (5) to the pooling layers. However,
this requires explicit calculation of the non-linear terms up
to p orders, although it can be approximated by applying the
discrete Fourier transform (DFT) of p times, resulting in a
computational complexity of O(p · n log n). Nevertheless,
based on the kernel trick, kervolution can introduce any order
of non-linear terms yet still with linear complexity.

3.2. Translational Equivariance

A crucial aspect of current architectures of deep learning
is the encoding of invariances. One of the reasons is that
the convolutional layers are naturally equivariant to image
translation [18]. In this section, we show that kervolution
preserves this important property. An operator is equivariant
to a transform when the effect of the transform is detectable
in the operator output [6]. Therefore, we have f(j)(x) =
x(j) ⊕ w, which means the input translation results in the
output translation [18]. Similarly,

Theorem 3.1. kervolution (3) is equivariant to translation.

Proof. Assume g′(x) = x(j) ⊗w, according to (5), we have

g′

i(x) = κ(x(i+j), w) = gi+j(x).

(7)

Therefore, the ith element of x(j) ⊗ w is the (i + j)th element
of g(x), hence we have

g(j)(x) = x(j) ⊗ w,

(8)

3.1. Sharing Weights

which completes the proof.

Sharing weights normally mean less trainable parameters
and lower computational complexity. It is straightforward

Note that the translational invariance of CNN is achieved
by concatenating pooling layers to convolutional layers [18],

33

channel 1

channel 2

channel 3

channel 4

channel 5

channel 6

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

0.6

0.4

0.2

0

-0.2

-0.4

N
N
K

N
N
C

Figure 1. The comparison of learned ﬁlters on MNIST from the ﬁrst layer (six channels and ﬁlter size of 5 × 5) of CNN and polynomial
KNN. It is interesting that some of the learned ﬁlters (e.g. channel 4) from KNN are quite similar to CNN. This indicates that part of the
kervolutional layer learns linear behavior, which is controlled by the linear part of the polynomial kernel.

Method Convolution L1-norm L2-norm

None
FGSM

99.17
71.92

99.12
74.08

99.11
76.36

Lp-Norm Kervolution The L1-norm in (9a) and L2-norm
in (9b) simply measures the Manhattan and Euclidean dis-
tances between input x and ﬁlter w, respectively.

Table 1. Test Accuracy (%) of the white-box FGSM attack with Lp-
norm kervolution on MNIST. 10K images are randomly selected.

and the translational invariance of KNN can be achieved
similarly. This property is crucial, since when invariances
are present in the data, encoding them explicitly in an ar-
chitecture provides an important source of regularization,
which reduces the amount of training data required [23]. As
mentioned in Section 2, the same property is also presented
in [22], which is achieved by assuming that all the training
samples are circular shifts of each other [49], while ours is
inherited from convolution. Interestingly, the kernel cross-
correlator (KCC) deﬁned in [54] is equivariant to any afﬁne
transforms (e.g., translation, rotation, and scale), which may
be useful for further development of this work.

3.3. Model Capacity and Features

It is straightforward that the kernel function (5) takes
kervolution to non-linear space, thus the model capacity is
increased without introducing extra parameters. Recall that
CNN is a powerful approach to extract discriminative local
descriptors. In particular, the linear kernel (2) of convolu-
tion measures the similarity of the input x and ﬁlter w, i.e.
the cosine of the angle θ between the two patches, since
hx, wi = cos(θ) · kxkkwk. From this point of view, kervo-
lution measures the similarity by match kernels, which are
equivalent to extracting speciﬁc features [3]. We next dis-
cuss how to interpret the kernel functions and present a few
instances κ( · , · ) of the kervolutional operator. One of the
advantages of kervolution is that the non-linear properties
can be customized without explicit calculation.

κm(x, w) = kx − wk1,
κe(x, w) = kx − wk2.

(9a)

(9b)

Both "distances" of two points involves aggregating the
distances between each element. If vectors are close on
most elements, but more discrepant on one of them, Eu-
clidean distance will reduce that discrepancy (elements are
mostly smaller than 1 because of the normalization layers),
being more inﬂuenced by the closeness of the other elements.
Therefore, the Euclidean kervolution may be more robust
to slight pixel perturbation. This hypothesis is veriﬁed by a
simple simulation of adversary attack using the fast gradient
sign method (FGSM) [19], shown in Table 1, where ‘None’
means the test accuracy on clean data.

Polynomial Kervolution Although the existing literatures
have shown that the polynomial kernel (10) works well for
the problem of natural language processing (NLP) when
dp = 2 using SVM [17], we ﬁnd its performance is better
when dp = 3 in KNN for the problem of image recognition.

κp(x, w) = (xT w + cp)dp =

dp

X

j=0

cdp
p

−j

(xT w)j,

(10)

where dp (dp ∈ Z+) extends the feature space to dp dimen-
sions; cp (cp ∈ R+) is able to balance the non-linear orders
(Intuitively, higher order terms play more important roles
when cp < 1). As a comparison, the kernel pooling strat-
egy [9] concatenates the non-linear terms cj(xT w)j directly,
while they are ﬁnally linearly combined by subsequent fully
connected layer, which dramaticaly increases the number of
learnable parameters in the linear layer.

34

To show the behavior of polynomial kervolution, the
learned ﬁlters of LeNet-5 trained for MNIST are visualized
in Figure 1, which contains all six channels of the ﬁrst ker-
volutional layer using polynomial kernel (dp = 2, cp = 0.5).
The optimization process is described in Section 4. For a
comparison, the learned ﬁlters from CNN are also presented.
It is interesting that some of the learned ﬁlters of KNN and
CNN are quite similar, e.g. channel 4, which means that
part of the capacity of KNN learns linear behavior as CNN.
This veriﬁes our understanding of polynomial kernel, which
is a combination of linear and higher order terms. This
phenomenon also indicates that polynomial kervolution in-
troduces higher order feature interaction in a more ﬂexible
and direct way than the existing methods.

Gaussian Kervolution The Gaussian RBF kernel (11) ex-
tends kervolution to inﬁnite dimensions.

κg(x, w) = exp(−γgkx − wk2),

(11)

where γg (γg ∈ R+) is a hyperparameter to control the
smoothness of decision boundary. It extends kervolutoin to
inﬁnite dimensions because of the i-degree terms in (12).

κg(x, w) = C

∞

X

i=0

(xT w)i

i!

,

(12)

where C = exp (cid:0)− 1

2 (cid:0)kxk2 + kwk2(cid:1)(cid:1) if γg = 1
2 .

The expression (12) is helpful for our intuitive understand-
ing, while the recent discovery reveals more information. It
is shown in [2] that the Gaussian kernel and its variants are
able to measure the similarity of gradient based patch-wise
features, e.g. SIFT [39] and HOG [11]. This provides a uni-
ﬁed way to generate a rich, diverse visual feature set [15].
However, instead of using the hand-crafted features as ker-
nel SVM, with KNN, we are able to inherit the substantial
achievements based on kernel trick while still taking advan-
tage of the great generalization ability of neural networks.

3.4. Kervolutional Layers and Learnable Kernel

Similar to a convolutional layer, the operation of a kervo-
lutional layer is slightly different from the standard deﬁnition
(3) in which x(i) becomes a 3-D patch in a sliding window
on the input. To be compatible with existing works, we also
implement all popular available structures of convolution in
CNN library [41] for kervolution, including the input and
output channels, input padding, bias, groups (to control con-
nections between input and output), size, stride, and dilation
of the sliding window. Therefore, the convolutional layers of
all existing networks can be directly or partially replaced by
kervolutional layers, which makes KNN inherit all the the
existing achievements of CNN, e.g. network architectures
[31, 20] and their numerous applications [42].

With kervolution, we are able to extract speciﬁc type of
features without paying attention to the weight parameters.
However, as aforementioned, we still need to tune the hy-
perparameters for some speciﬁc kernels, e.g. the balancer
cp in polynomial kernel, the smoother γg in Gaussian RBF
kernel. Although we noticed that the model performance is
mostly insensitive to the kernel hyperparameters, which is
presented in Section 4.2, it is sometimes troublesome when
we have no knowledge about the kernel. Therefore, we also
implement training the network with learnable kernel hy-
perparameters based on the back-propagation [43]. This
slightly increases the training complexity theoretically, but
in experiments we found that this brings more ﬂexibility and
the additional cost for training several kernel parameters is
negligible, compared to learning millions of parameters in
the network. Taking the Gaussian kervolution as an example,
the gradients are computed as:

∂
∂w
∂
∂γg

κg(x, w) = 2γg(x − w)κg(x, w),

κg(x, w) = −kx − wk2κg(x, w).

(13a)

(13b)

Note that the polynomial order dp is not trainable because of
the integer limitation, since the real exponent may produce
complex numbers, which makes the network complicated.

4. Ablation Study

This section explores the inﬂuences of the kernels, the
hyperparameters, and combination of kervolutional layers
using LeNet-5 and MNIST [34]. To eliminate the inﬂuence
of other factors, all conﬁgurations are kept as the same. The
accuracy of modern networks on MNIST has been saturated,
thus we adopt the evaluation criteria proposed in DAWN-
Bench [7] that jointly considers the computational efforts
and precision. It measures the total training time to a target
validation accuracy (98%), which is a trade-off between efﬁ-
ciency and accuracy. In all the experiments of this section,
we apply the stochastic gradient descent (SGD) method for
training, where a mini-batch size of 50, a momentum of 0.9,
an initial learning rate of 0.003, a multiplicative factor of
0.1, and a maximum epoch of 20 with milestones of [10, 15]
are adopted. Our algorithm is implemented based on the
PyTorch library [41]. All tests are conducted on a single
Nvidia GPU of GeForce GTX 1080Ti. The reported training
time does not include the testing and checkpoint saving time.

4.1. Kernels

Following the ablation principle, we only replace the
convolutional layers of LeNet-5 by kernvolutional layer us-
ing three kernel functions, i.e. polynomial kernel of dp =
3, cp = 1 in (10), Gaussian kernel of γg = 1 in (11), and
also sigmoid kernel κs(x, w) = tanh(xT w). As shown in

35

100

80

60

40

20

0

100

80

60

40

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

(a) kernels vs. convergence

[98.93%] convolution
[99.14%] kervolution-polynomail
[98.74%] kervolution-sigmoid
[99.08%] kervolution-gaussian

0.2

0.4

0.6

0.8

1

epoch

(b) kernels vs. training time

20

0

1

[6.46s] convolution
[2.72s] kervolution-polynomail
[13.1s] kervolution-sigmoid
[3.08s] kervolution-gaussian

3

4
2
training time [s]

5

6

(e) layer arrangement vs. convergence

[98.93%] CNN
[99.20%] KNN-poly-linear
[99.21%] KNN-linear-poly
[98.94%] KNN-poly-poly

0.2

0.4

0.6

0.8

1

epoch

(f) layer arrangement vs. training time

(c) hyperparameters vs. convergence

[98.93%] convolution
[99.14%] polynomail (d

[99.16%] polynomail (d

=3, c

=5, c

=1)

=1)

p

p

p

p

[99.03%] polynomail (d

p
[99.20%] polynomail (learnable)

=3, c

p

=0.5)

0.2

0.4

0.6

0.8

1

epoch

(d) hyperparameters vs. training time

[6.46s] convolution
[2.72s] polynomail (d

[2.08s] polynomail (d

=3, c

=5, c

=1)

=1)

p

p

p

p

100

80

60

40

20

0

100

80

60

40

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

100

80

60

40

20

0

100

80

60

40

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

]

%

[
 
y
c
a
r
u
c
c
a
n
o

 

i
t

a
d

i
l

a
v

20

0

1

[4.24s] polynomail (d

p
[3.13s] polynomail (learnable)

=3, c

p

=0.5)

3

4
2
training time [s]

5

6

20

0

1

[6.46s] CNN
[3.13s] KNN-poly-linear
[3.48s] KNN-linear-poly
[2.98s] KNN-poly-poly

3

4
2
training time [s]

5

6

Figure 2. The inﬂuences of kervolution on the convergence rate. The best validation accuracy (20 epochs) and training time to target accuracy
(98%) are displayed in brackets within the legend of each ﬁgure, respectively. (a) and (b) demonstrate that the kernel functions have a
signiﬁcant impact on the convergence speed. (c) and (d) demonstrate that the hyperparameters of kervolutional layer play less important
roles than kernels. (e) and (f) shows the effects of arrangement of kervolutional layers.

Figure 2 (a) and (b), although the computational complexity
of non-linear kernels is slightly higher than that of linear
kernel (convolution), the polynomial and Gaussian KNN are
still able to converge to a validation accuracy of 98% more
than 2× faster than the original CNN. However, the conver-
gence speed of sigmoid KNN is 2× slower than that of CNN,
which indicates that the kernel functions are crucial and have
a signiﬁcant impact on performance. Thanks to the wealth
of traditional methods, we have many other useful kernels
[47], although we cannot test all of them in this paper. The
L1 and L2-norm KNN achieve an accuracy of 99.05% and
99.19%, respectively, but we omit them in Figure 2 (a) and
(b) because they nearly coincide with the polynomail curve.

4.2. Hyperparameters

From the above analysis, we credit the signiﬁcant im-
provements of convergence speed to the usage of different
kernels. This part veriﬁes this assumption and further ex-
plores the inﬂuences of kernel hyperparameters. The polyno-
mial kervolution (10) with two hyperparameters, non-linear
order dp and balancer cp, is selected. As shown in Figure 2
(c) and (d), the convergence speed and validation accuracy of
polynomial KNN using different hyperparameters are pretty
similar to that of Figure 2 (a) and (b), which indicates that
KCC is less sensitive to the kernel hyperparameters.

It is also noticed that the KNN with learnable kernel pa-
rameters achieves the best precision (99.20%) in this group,
although it slightly increases the training time compared to
KNN (dp = 3, cp = 1). However, the cost is justiﬁable

since it saves the hyperparameter tuning process and the
convergence is still much faster than the baseline CNN.

4.3. Layer Arrangement

This part explores the inﬂuences of the placement of ker-
volutional layers. Thanks to the simplicity of LeNet-5 (two
convolutional layers), we can test all possible conﬁgurations
of layer arrangement, i.e. "conv-conv", "kerv-conv", "conv-
kerv", and "kerv-kerv". As shown in Figure 2 (e) and (f),
where the polynomial kernel (dp = 3, cp = 1) is adopted,
KNN still brings faster convergence. One interesting phe-
nomenon is that the architecture of "kerv-conv" achieves
better precision but slower convergence than "conv-kerv"
(we run multiple times and the results are similar). This
indicates that the sequence of kervolutional layers has an
impact on performance, although the model complexity is
the same. One side effect is that we may need to make some
efforts to adjust the layer sequence for deeper KNNs. It is
also noticed that the architecture of ‘kerv-kerv’ achieves the
fastest convergence but only with a comparable validation
accuracy to CNN. We argue that this is caused by the over-
ﬁtting problem, since its ﬁnal training loss is very close to
others (≈ 0.01), which means that the model capacity of
double kervolutional layers together with the activation and
max pooling layers is too large for the MNIST dataset.

4.4. Removing ReLU

As mentioned in Section 1, the non-linearity of CNN
mainly comes from the activation (ReLU) and max pool-

36

Network

CIFAR-10 CIFAR-100

CNN [26]

KNN

13.63
10.85

44.74
37.12

Hyperparm dp = 3

dp = 5

cp = 0
cp = 1

learnable cp

4.78
4.60
4.76

5.42
5.36
4.73

Table 2. Validation error (%) of ResNets on CIFAR-10 and CIFAR-
100 without data augmentation.

Table 4. Validation error (%) of polynomial KNN using ResNet-32
on CIFAR-10+ using different hyper parameters.

Architecture

CIFAR-10+
CIFAR-100+
CNN KNN CNN KNN

GoogLeNet [13]

ResNet [20]

DenseNet [25]

13.37
6.43
5.24

5.16
4.69
5.08

26.65
27.22
24.42

20.84
22.49
24.92

Hyperparm dp = 3

dp = 5

cp = 0
cp = 1

learnable cp

0.83
1.41
0.86

1.41
1.46
0.79

Table 3. Validation error (%) on CIFAR-10 and CIFAR-100 on
different architectures with data augmentation.

Table 5. Training time (h) of polynomial KNN using ResNet-32 on
CIFAR-10+ using different hyper parameters.

ing layers. Intuitively, KNN may be able to achieve same
model performance without activation or max pooling layers.
To this end, we simply remove all the activation layers of
LeNet-5 and replace the max pooling by average pooling
layers, which means that all the non-linearity comes from
the kervolutional layers. Without surprise, the CNN only
achieves an accuracy of 92.22%, which is far from the target
accuracy of 98%, hence the training time comparison ﬁgure
is omitted. However, the KNN of "gaussian-polynomial"
and "polynomial-polynomial" both achieve an accuracy of
99.11%, which further veriﬁes the effectiveness of kervo-
lution. In another sense, the strategy of removing the acti-
vation layers is one of the solutions to the aforementioned
over-ﬁtting problem in Section 4.3, although we need more
investigations to ﬁnd the best architectures for KNN.

5. Performance

This section aims to demonstrate the effectiveness of deep
KNN on larger datasets. In practice, the network architecture
has a signiﬁcant impact on performance. Since the modern
networks are so deep and kervolution provides many possi-
bilities via different kernels, we cannot perform exhaustive
tests to ﬁnd the best sequence of kervolutional layers. Hence,
we construct KNN based on several existing architectures
by mainly changing the ﬁrst convolutional layers to kervolu-
tional layers. Other factors, such as data augmentation and
optimizers, are kept as their original conﬁgurations. As dis-
covered in Section 4, this may not be the best conﬁguration,
while it can demonstrate the effectiveness of kervolution.

The CIFAR experiments in this section are conducted
in a single GPU of Nvidia GeForce GTX 1080Ti while we
employ four Nvidia Tesla M40 in the ImageNet experiments.
The polynomial kervolutional layer in this section adopts the
learnable balancer cp with power dp = 3.

5.1. CIFAR

The CIFAR-10 and CIFAR-100 [30] datasets consist of
colored natural images with 32 × 32 pixels in 10 and 100
classes, respectively. Each dataset contains 50k images for
training and 10k for testing. In the testing procedure, only
the single view of the original image is evaluated.

The proposed KNNs are ﬁrst evaluated without data aug-
mentaion using the architecture of ResNet. We construct
and train ResNet-110 following the architecture of [20] with
cross-entropy loss. The stochastic gradient descent (SGD)
is adopted with momentum of 0.9. We train the networks
for 200 epochs with a mini-batch size of 128. The learning
rate decays by 0.1 at the 75, 125, and 150 epochs; the weight
decay stays at 5 × 10−4. The validation error of KNN as
well as the best performance of baseline CNN from [26] are
presented in Table 2. It is interesting that KNN outperforms
CNN with a signiﬁcant improvements on the CIFAR dataset.
We perform more experiments using the data augmenta-
tion techniques, and the datasets are denoted as ‘CIFAR-10+’
and ’CIFAR-100+’, respectively. The KNNs are constructed
following the architecture of GoogLeNet [48] and DenseNet-
40-12 [25]. Data augmentation is applied following the
conﬁguration in ResNet [20], including horizontal ﬂipping
with a probability of 50%, reﬂection-padding by 4 pixels,
and random crop with size 32 × 32.

Different from ResNet, we train DenseNet-40-12 follow-
ing its original conﬁguration [25], i.e. SGD with batch size
64 for 300 epochs. The initial learning rate is set to 0.1, and
is divided by 10 at 50% and 75% of the total number of iter-
ations. Table 3 lists the performance of KNN and baselines
from [20, 25, 13]. We cannot see a signiﬁcant improvement
on DenseNet, which indicates that polynomial kervolution
may not suit for fully connected architecture.

We further demonstrate the sensitivity to the kernel hy-
perparameters. Table 4 lists the validation errors of KNN

37

on CIFAR-10+ with polynomial kernel of dp = 3, 5 and
cp = 0, 1 using the architecture of ResNet-32. The per-
formance with learnable balancer of cp is also given for
comparison. As suggested by [7], their training time to
an accuracy of 94% is measured and presented in Table 5.
It is interesting that, the conﬁguration of dp = 3, cp = 1
achieves the best accuracy, while dp = 5 with learnable cp
requires the least training time. The networks with learnable
kernel achieve the best overall performance by jointly con-
sidering the training time and accuracy. This indicates that
the learnable kernel technique can produce compromised
performance without tuning parameters.

5.2. ImageNet

The ILSVRC 2012 classiﬁcation dataset [12] is composed
of 1.2M images for training and 50k images for validation in
1000 classes. For fair comparison, we apply the same data
augmentation as described in [20, 21], where the single-crop
and 10-crop at a size of 224 × 224 are applied for testing.

We select four versions of ResNet [20], including ResNet-
18, ResNet-34, ResNet-50 and ResNet-101, as the baselines.
The kervolutional layer is applied with a polynomial kernel
(d = 3, cp = 2). All the networks are trained using the
stochastic gradient descent (SGD) method for 100 epochs
with a batch size of 256. The learning rate is set to 0.1, and
is reduced every 30 epochs. Also, a weight decay of 10−4
and a momentum of 0.9 without dampening are employed.
In our experiments, the best performance of ResNet cannot
be achieved in limited training time. To guarantee a fair com-
parison, the results of ResNet which have the best accuracy
in [45, 20, 21, 25] are chosen. We report the single-crop and
10-crop validation error on ImageNet in Table 6, where the
performance of KNN is the average of ﬁve running.

In Table 6, top-1 errors using ResNet-18/34/50/101 are
reduced by 0.5%, 0.41%, 0.29%, and 0.7% in single-crop
testing and 0.45%, 0.75%, 0.80%, and 0.83% in 10-crop
testing, respectively. For top-5 errors, KNN outperform
corresponding ResNets by 0.43%, 0.24%, 0.23%, and 0.28%
in single-crop testing, and 0.39%, 0.68%, 0.74%, and 0.87%
in 10-crop testing, respectively. It is noticed that simple
replacement of the convolutional layer in ResNet leads to
obvious improvements. We believe that more customized
network architecture as well as extensive hyperparameter
searches can further improve the performance on ImageNet.

6. Discussion

Kernel Different from convolution, which can only extract
linear features, kervolution is able to extract customized
patch-wise non-linear features, which makes KNN much
more ﬂexible. It is demonstrated that the higher order terms
make the subsequent linear classiﬁer more discriminant,
while this does not increase the computational complexity.
However, we have only tested several kernels, e.g. polyno-

Network

Top-1

Top-5

ResNet-18
KNN-18

30.24 / 27.88
29.74 / 27.43

10.92 / 9.42
10.49 / 9.03

ResNet-34
KNN-34

26.70 / 25.03
26.29 / 24.28

8.58 / 7.76
8.34 / 7.08

ResNet-50
KNN-50

23.85 / 22.85
23.56 / 22.05

7.13 / 6.71
6.90 / 5.97

ResNet-101
KNN-101

22.63 / 21.75
21.93 / 20.92

6.44 / 6.05
6.16 / 5.18

Table 6. The top-1 and top-5 validation errors on ImageNet, with
single-crop / 10-crop testing, respectively.

mial and Gaussian, which may not be optimal. It is obvious
that the kernel functions and their hyperparameters can be
task-driven and more investigations are necessary.

Training It is also noticed that the training can be unstable
when a network contains too much non-linearity, this is
because the model complexity is too high for a speciﬁc
task, which can be simply solved by reducing the number
of kervolutional layers. More investigations on searching
appropriate non-linearity for a speciﬁc task is challenging.

Architecture We have only applied kervolution to the ex-
isting architectures, e.g. ResNet. While this is not optimal,
especially when considering that the mechanism of deep
architectures is still unclear [32]. It is obvious that the perfor-
mance of kernvolution is dependent on the architecture. One
of the interesting challenges for future work is to investigate
the relationship between the architecture and kervolution.

7. Conclusion

This paper introduces the kervolution to generalize convo-
lution to non-linear space, and extends convolutional neural
networks to kervolutional neural networks. It is shown that
kervolution not only retains the advantages of convolution,
i.e. sharing weights and equivalence to translation, but also
enhances the model capacity and captures higher order inter-
actions of features, via patch-wise kernel functions without
introducing additional parameters. It has been demonstrated
that, with careful kernel chosen, the performance of CNN can
be signiﬁcantly improved on MNIST, CIFAR, and ImageNet
dataset via replacing convolutional layers by kervolutional
layers. Due to the large number of choices of kervolution,
we cannot perform a brute force search for all the possibil-
ities, while this opens a new space for the construction of
deep networks. We expect the introduction of kervolutional
layers in more architectures and extensive hyperparameter
searches can further improve the performance.

38

References

[1] Mathieu Blondel, Masakazu Ishihata, Akinori Fujino, and
Naonori Ueda. Polynomial Networks and Factorization Ma-
chines: New Insights and Efﬁcient Training Algorithms. In
International Conference on Machine Learning, 2016.

[2] Liefeng Bo, Xiaofeng Ren, and Dieter Fox. Kernel Descrip-
tors for Visual Recognition. In Conference on Neural Infor-
mation Processing Systems, 2010.

[3] Liefeng Bo and Cristian Sminchisescu. Efﬁcient Match Ker-
nel between Sets of Features for Visual Recognition.
In
Conference on Neural Information Processing Systems, pages
135–143, 2009.

[4] Bernhard E Boser, Isabelle M Guyon, and Vladimir N Vap-
nik. A training algorithm for optimal margin classiﬁers. In
Proceedings of the ﬁfth annual workshop on Computational
learning theory, pages 144–152. ACM, 1992.

[5] Nadav Cohen, Or Sharir, and Amnon Shashua. Deep Sim-
Nets. In IEEE Conference on Computer Vision and Pattern
Recognition, pages 4782–4791. IEEE, 2016.

[6] Taco Cohen and Max Welling. Group Equivariant Convolu-

tional Networks. ICML, 2016.

[7] Cody Coleman, Deepak Narayanan, Daniel Kang, Tian Zhao,
Jian Zhang, Luigi Nardi, Peter Bailis, Kunle Olukotun, Chris
Re, and Matei Zaharia. DAWNBench: An End-to-End Deep
Learning Benchmark and Competition. Training, 100, 2017.
[8] Corinna Cortes and Vladimir Vapnik. Support-vector net-

[17] Yoav Goldberg and Michael Elhadad. splitsvm: fast, space-
efﬁcient, non-heuristic, polynomial kernel computation for
nlp applications. In Proceedings of the 46th Annual Meeting
of the Association for Computational Linguistics on Human
Language Technologies: Short Papers, pages 237–240. Asso-
ciation for Computational Linguistics, 2008.

[18] Ian Goodfellow, Yoshua Bengio, and Aaron Courville. Deep

Learning. MIT Press, 2016.

[19] Ian J Goodfellow, Jonathon Shlens, and Christian Szegedy.
Explaining and Harnessing Adversarial Examples. arXiv.org,
Dec. 2014.

[20] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
Deep Residual Learning for Image Recognition. In The Con-
ference on Computer Vision and Pattern Recognition, 2016.

[21] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
Identity mappings in deep residual networks. In European
Conference on Computer Vision, pages 630–645. Springer,
2016.

[22] J F Henriques, R Caseiro, and P Martins. High-Speed Track-
ing with Kernelized Correlation Filters. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 37(3):583–596,
2015.

[23] João F Henriques and Andrea Vedaldi. Warped Convolu-
In

tions: Efﬁcient Invariance to Spatial Transformations.
International Conference on Machine Learning, 2017.

[24] Jie Hu, Li Shen, and Gang Sun. Squeeze-and-Excitation

works. Machine learning, 20(3):273–297, 1995.

Networks. CVPR, 2018.

[9] Yin Cui, Feng Zhou, Jiang Wang, Xiao Liu, Yuanqing Lin,
and Serge Belongie. Kernel Pooling for Convolutional Neural
Networks. In 2017 IEEE Conference on Computer Vision and
Pattern Recognition (CVPR), pages 3049–3058. IEEE, 2017.
[10] Jifeng Dai, Haozhi Qi, Yuwen Xiong, Yi Li, Guodong Zhang,
Han Hu, and Yichen Wei. Deformable Convolutional Net-
works. ICCV, 2017.

[11] Navneet Dalal and Bill Triggs. Histograms of Oriented Gra-
dients for Human Detection. In IEEE Computer Society Con-
ference on Computer Vision and Pattern Recognition, pages
886–893. IEEE, 2005.

[12] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li
Fei-Fei. Imagenet: A large-scale hierarchical image database.
In Computer Vision and Pattern Recognition, 2009. CVPR
2009. IEEE Conference on, pages 248–255. IEEE, 2009.

[13] Abhimanyu Dubey, Otkrist Gupta, Pei Guo, Ramesh Raskar,
Ryan Farrell, and Nikhil Naik. Pairwise confusion for ﬁne-
grained visual classiﬁcation. In Proceedings of the European
Conference on Computer Vision (ECCV), pages 70–86, 2018.
[14] Matthias Fey, Jan Eric Lenssen, Frank Weichert, and Heinrich
Müller. Splinecnn: Fast geometric deep learning with contin-
uous b-spline kernels. In Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, pages 869–877,
2018.

[15] Peter Gehler and Sebastian Nowozin. On feature combina-
tion for multiclass object classiﬁcation. In 2009 IEEE 12th
International Conference on Computer Vision (ICCV), pages
221–228. IEEE, 2009.

[16] Ross Girshick. Fast R-CNN. In IEEE International Confer-

ence on Computer Vision, pages 1440–1448. IEEE, 2015.

[25] Gao Huang, Zhuang Liu, Laurens van der Maaten, and Kil-
ian Q Weinberger. Densely Connected Convolutional Net-
works. CVPR, pages 2261–2269, 2017.

[26] Gao Huang, Yu Sun, Zhuang Liu, Daniel Sedra, and Kil-
ian Q Weinberger. Deep Networks with Stochastic Depth. In
European Conference on Computer Vision, 2016.

[27] David H Hubel and Torsten N Wiesel. Receptive ﬁelds, binoc-
ular interaction and functional architecture in the cat’s visual
cortex. The Journal of physiology, 160(1):106–154, 1962.

[28] David H Hubel and Torsten N Wiesel. Receptive ﬁelds and
functional architecture of monkey striate cortex. The Journal
of physiology, 195(1):215–243, 1968.

[29] Max Jaderberg, Karen Simonyan, Andrew Zisserman, and
Koray Kavukcuoglu. Spatial Transformer Networks. In Con-
ference on Neural Information Processing Systems, 2015.

[30] Alex Krizhevsky and Geoffrey Hinton. Learning multiple lay-
ers of features from tiny images. Technical report, University
of Toronto, 2009.

[31] Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Im-
ageNet Classiﬁcation with Deep Convolutional Neural Net-
works.
In Conference on Neural Information Processing
Systems, 2012.

[32] C-C Jay Kuo. Understanding convolutional neural networks
with a mathematical model. Journal of Visual Communication
and Image Representation, 41:406–413, 2016.

[33] Yann LeCun, Bernhard Boser, John S Denker, Donnie Hen-
derson, Richard E Howard, Wayne Hubbard, and Lawrence D
Jackel. Backpropagation applied to handwritten zip code
recognition. Neural computation, 1(4):541–551, 1989.

39

[34] Y Lecun, L Bottou, Y Bengio, and P Haffner. Gradient-based
learning applied to document recognition. Proceedings of the
IEEE, 86(11):2278–2324, 1998.

[52] Chen Wang, Junsong Yuan, and Lihua Xie. Non-iterative
SLAM. In International Conference on Advanced Robotics
(ICAR), pages 83–90. IEEE, 2017.

[53] Chen Wang, Handuo Zhang, Thien-Minh Nguyen, and Lihua
Xie. Ultra-wideband aided fast localization and mapping
system. In IEEE/RSJ International Conference on Intelligent
Robots and Systems (IROS), 2017.

[54] Chen Wang, Le Zhang, Lihua Xie, and Junsong Yuan. Kernel
Cross-Correlator. In The Thirty-Second AAAI Conference on
Artiﬁcial Intelligence, 2018.

[55] Xiaodi Wang, Baochang Zhang, Ce Li, Rongrong Ji, Jungong
Han, Xianbin Cao, and Jianzhuang Liu. Modulated convo-
lutional networks. In Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, pages 840–848,
2018.

[56] Saining Xie, Ross B Girshick, Piotr Dollár, Zhuowen Tu, and
Kaiming He. Aggregated Residual Transformations for Deep
Neural Networks. CVPR, pages 5987–5995, 2017.

[57] Georgios Zoumpourlis, Alexandros Doumanoglou, Nicholas
Vretos, and Petros Daras. Non-linear Convolution Filters for
CNN-Based Learning. In IEEE International Conference on
Computer Vision (ICCV), pages 4771–4779. IEEE, 2017.

[35] Yann LeCun et al. Generalization and network design strate-

gies. Connectionism in perspective, pages 143–155, 1989.

[36] Min Lin, Qiang Chen, and Shuicheng Yan. Network In Net-

work. arXiv.org, Dec. 2013.

[37] Tsung-Yu Lin, Aruni RoyChowdhury, and Subhransu Maji.
Bilinear CNN models for ﬁne-grained visual recognition. In
Proceedings of the IEEE international conference on com-
puter vision, pages 1449–1457, 2015.

[38] Weiyang Liu, Zhen Liu, Zhiding Yu, Bo Dai, Rongmei Lin,
Yisen Wang, James M Rehg, and Le Song. Decoupled Net-
works. In The Conference on Computer Vision and Pattern
Recognition, 2018.

[39] David G Lowe. Distinctive Image Features from Scale-
Invariant Keypoints. International Journal of Computer Vi-
sion, 60(2):91–110, 2004.

[40] Julien Mairal, Piotr Koniusz, Zaid Harchaoui, and Cordelia
Schmid. Convolutional Kernel Networks. In Conference on
Neural Information Processing Systems, 2014.

[41] Adam Paszke, Sam Gross, Soumith Chintala, Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Al-
ban Desmaison, Luca Antiga, and Adam Lerer. Automatic
differentiation in pytorch. In NIPS Workshop, 2017.

[42] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun.
Faster R-CNN: Towards Real-Time Object Detection with
Region Proposal Networks. IEEE Transactions on Pattern
Analysis and Machine Intelligence, 39(6):1137–1149, 2017.

[43] David E Rumelhart, Geoffrey E Hinton, Ronald J Williams,
et al. Learning representations by back-propagating errors.
Cognitive modeling, 5(3):1, 1988.

[44] Sara Sabour, Nicholas Frosst, and Geoffrey E Hinton. Dy-
namic Routing Between Capsules. In Conference on Neural
Information Processing Systems, Dec. 2017.

[45] Tong Xiao Sam Gross. fb.resnet.torch. https://github.

com/facebook/fb.resnet.torch, 2016.

[46] Karen Simonyan and Andrew Zisserman. Very Deep Con-
volutional Networks for Large-Scale Image Recognition. In
Intelnational Conference on Learning Research, 2015.

[47] Alex J Smola and Bernhard Schölkopf. Learning with kernels,

volume 4. Citeseer, 1998.

[48] Christian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet,
Scott Reed, Dragomir Anguelov, Dumitru Erhan, Vincent
Vanhoucke, and Andrew Rabinovich. Going Deeper with
Convolutions. In IEEE Conference on Computer Vision and
Pattern Recognition, pages 1–9. IEEE, 2015.

[49] Chen Wang. Kernel Learning for Visual Perception. PhD

thesis, Nanyang Technological University, 2019.

[50] Chen Wang, Minh-Chung Hoang, Lihua Xie, and Junsong
Yuan. Non-iterative RGB-D-inertial Odometry. arXiv.org,
Oct. 2017.

[51] Chen Wang, Tete Ji, Thien-Minh Nguyen, and Lihua Xie.
Correlation Flow: Robust Optical Flow using Kernel Cross-
Correlators. In International Conference on Robotics and
Automation (ICRA). IEEE, May 2018.

40

