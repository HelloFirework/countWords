Octree guided CNN with Spherical Kernels for 3D Point Clouds

Huan Lei
Ajmal Mian
Computer Science and Software Engineering

Naveed Akhtar

The University of Western Australia

huan.lei@research.uwa.edu.au, {naveed.akhtar, ajmal.mian}@uwa.edu.au

Abstract

We propose an octree guided neural network architec-
ture and spherical convolutional kernel for machine learn-
ing from arbitrary 3D point clouds. The network archi-
tecture capitalizes on the sparse nature of irregular point
clouds, and hierarchically coarsens the data representation
with space partitioning. At the same time, the proposed
spherical kernels systematically quantize point neighbor-
hoods to identify local geometric structures in the data,
while maintaining the properties of translation-invariance
and asymmetry. We specify spherical kernels with the help
of network neurons that in turn are associated with spa-
tial locations. We exploit this association to avert dynamic
kernel generation during network training that enables ef-
ﬁcient learning with high resolution point clouds. The ef-
fectiveness of the proposed technique is established on the
benchmark tasks of 3D object classiﬁcation and segmenta-
tion, achieving competetive performance on ShapeNet and
RueMonge2014 datasets.

1. Introduction

Convolutional Neural Networks (CNNs) [17] are known
to learn highly effective features from data. However, stan-
dard CNNs are only amenable to data deﬁned over regular
grids, e.g. pixel arrays. This limits their ability in process-
ing 3D point clouds that are inherently irregular. Point cloud
processing has recently gained signiﬁcant research interest
and large repositories for this data modality have started to
emerge [1, 4, 12, 39, 40]. Recent literature has also seen
many attempts to exploit the representation prowess of stan-
dard convolutional networks for point clouds by adaption
[23, 39]. However, these attempts have often led to exces-
sively large memory footprints that restrict the allowed in-
put data resolution [29, 33]. A more attractive choice is to
combine the power of convolution operation with graph rep-
resentations of irregular data. The resulting Graph Convo-
lutional Networks (GCNs) offer convolutions either in spec-
tral domain [3, 7, 15] or spatial domain [33].

In GCNs, the spectral domain methods require the Graph
Laplacian to be aligned, which is not straight forward to

achieve for point clouds. On the other hand, the only promi-
nent approach in spatial domain is the Edge Conditioned ﬁl-
ters in CNNs for graphs (ECC) [33] that, in contrast to the
standard CNNs, must generate convolution kernels dynam-
ically entailing a signiﬁcant computational overhead. Addi-
tionally, ECC relies on range searches for graph construc-
tion and coarsening, which can become prohibitively expen-
sive for large point clouds. One major challenge in applying
convolutional networks to irregular 3D data is in specify-
ing geometrically meaningful convolution kernels in the 3D
metric space. Naturally, such kernels are also required to
exhibit translation-invariance to identify similar local struc-
tures in the data. Moreover, they should be applied to point
pairs asymmetrically for a compact representation. Owing
to such intricate requirements, few existing techniques alto-
gether avoid the use of convolution kernels in computational
graphs to process unstructured data [16, 27, 28]. Although
still attractive, these methods do not contribute towards har-
nessing the potential of convolutional neural networks for
point clouds.

In this work, we introduce the notion of spherical con-
volutional kernel that systematically partitions a spherical
3D region into multiple volumetric bins, see Fig. 1. Each
bin of the kernel speciﬁes a matrix of learnable parameters
that weights the points falling within that bin for convolu-
tion. We apply these kernels between the layers of a Neural
Network (Ψ-CNN) that we propose to construct by exploit-
ing octree partitioning [24] of the 3D space. The sparsity
guided octree structuring determines the locations to per-
form the convolutions in each layer of the network. The
network architecture itself is guided by the hierarchy of the
octree, having the same number of hidden layers as the tree
depth. By exploiting space partitioning, the network avoids
K-NN/range search and efﬁciently consumes high resolu-
tion point clouds. It also avoids dynamic generation of the
proposed kernels by associating them to its neurons. At the
same time, the kernels are able to share weights between
similar local structures in the data. We theoretically estab-
lish that the spherical kernels are applied asymmetrically to
points in our network just as the kernels in standard CNNs

19631

Figure 1. The proposed octree guided CNN, i.e. Ψ-CNN directly processes raw point clouds using octree partitioning information. The
representation is hierarchically coarsened at each network layer (three layers depicted) by applying spherical convolutional kernels. A
spherical kernel systematically splits the space around a point xi into multiple volumetric bins. For the jth neighboring point xj , a kernel
ﬁrst determines its relevant bin and uses the weight matrix Wκ deﬁned for that bin to compute the activation value. The proposed spherical
kernel preserves translation-invariance and asymmetry properties of standard 2D convolutional kernel in 3D point cloud domain.

are applied asymmetrically to image pixels. This ensures
compact representation learning by the proposed network in
the point cloud domain. We demonstrate the effectiveness
of our method for 3D object classiﬁcation, part segmenta-
tion and large-scale semantic segmentation. The major con-
tributions of this work are summarized below:

• A novel concept of translation-invariant and asymmet-
ric convolutional kernel is proposed and analyzed for
point-wise feature learning from irregular point clouds.
• The resulting convolutional kernel is exploited with an
octree guided neural network that, in contrast to the
previous voxelization applications of octree to point
clouds [29], hierarchically coarsens the data and con-
structs point neighborhoods using space partitioning to
avoid time-consuming K-NN/range search.

• Efﬁcacy of the proposed technique is established
by experiments with ModelNets [39] for 3D object
classiﬁcation, ShapeNet [40] for part segmentation,
and RueMonge2014 [30] for semantic segmentation,
achieving competetive performance on the last two.

2. Related Work

PointNet [27] is one of the ﬁrst instances of exploit-
ing neural networks to represent point clouds.
It directly
uses x, y, z-coordinates of points as input features. The
network learns point-wise features with shared MLPs, and
extracts a global feature with max pooling. A major limi-
tation of PointNet is that it explores no geometric context
in point-wise feature learning. This was later addressed
by PointNet++ [28] with hierarchical application of max-
pooling to the local regions. The enhancement builds lo-
cal regions using K-NN search as well as range search.
Nevertheless, both PointNets [27, 28] aggregate the context
information with max pooling, and no convolution mod-
ules are explored in the networks.
In regards to process-
ing point clouds with deep learning using tree structures,

Kd-network [16] is among the pioneering prominent con-
tributions. Kd-network also uses point coordinates as its in-
put, and computes feature of a parent node by concatenating
the features of its children in a balanced tree. However, its
performance depends heavily on the randomization of the
tree construction. This is in sharp contrast to our approach
that uses deterministic geometric relationships between the
points. Another technique, SO-Net [18] reorganizes the ir-
regular point cloud into an m× m 2D rectangular map, and
uses the PointNet architecture to learn node-wise features
for the map. Similarly, KCNet [32] also builds on PointNet
and introduces a point-set template to learn geometric corre-
lations of local points in the point cloud. PointCNN [19] ex-
tracts permutation-invariant features by reordering the local
points canonically with a learnable χ-transformation. All of
these methods relate to our work in terms of directly accept-
ing the spatial coordinates of points as input. However, they
do not contribute towards the use of convolutional networks
for processing 3D point clouds. Approaches advancing that
research direction can be divided into two broad categories,
discussed below.

A. Graph Convolutional Networks

Graph convolutional networks can be grouped into spec-
tral networks [3, 7, 15] and spatial networks [33]. The spec-
tral networks perform convolution in the spectral domain
relying on the graph Laplacian and adjacency matrices,
while the spatial networks perform convolution in the spa-
tial domain. A major limitation of spectral networks is that
they demand the graph structure to be ﬁxed, which makes
their application to the data with varying graph structures
(e.g. point clouds) challenging. Yi et al.
[41] attempted
to address this issue with Spectral Transformer Network
(SpecTN), similar to STN [14] in the spatial domain. How-
ever, the signal transformation from spatial to spectral do-
mains and vice-versa results in computational complexity

O(n2). ECC [33] is among the pioneering works for point

cloud analysis with graph convolution in the spatial domain.

9632

Inspired by the dynamic ﬁlter networks [6], it adapts MLPs
to generate convolution ﬁlters between the connected ver-
tices dynamically. The dynamic generation of ﬁlters comes
with computational overhead. Additionally, the neighbor-
hood construction and graph coarsening in ECC must rely
on range searches, which is not efﬁcient. We achieve coars-
ening and neighborhood construction directly from the oc-
tree partitioning, thereby avoiding expensive range search-
ing. Moreover, our spherical convolutional kernel effec-
tively explores the geometric context of each point without
requiring dynamic ﬁlter generation.

B. 3D Convolutional Neural Networks

3D-CNNs are applied to volumetric representations of
3D data.
In the earlier attempts in this direction, only
low input resolution could be processed, e.g. 30×30×30
[39], 32×32×32 [23]. This issue transcended to subsequent
works as well [13, 31, 42, 43]. The limitation of low input
resolution was a natural consequence of the cubic growth
of memory and computational requirements associated with
the volumetric input data. Later methods [8, 20] mainly aim
at addressing these issues. Most recently, Riegler et al. [29]
proposed OctNet, that represents point clouds with a hybrid
of shallow grid octrees (depth=3). Compared to its dense
peers, OctNet reduces the computational and memory costs
to a large degree, and is applicable to high-resolution in-
puts up to 256×256×256. Whereas OctNet also exploits
octrees, there are major differences between OctNet and
our method. Firstly, OctNet must process point clouds as
regular 3D volumes due to its 3D-CNN kernels. No such
constraint is applicable to our technique due to the proposed
spherical kernels. Secondly, we are able to learn point cloud
representation with a single deep octree instead of using hy-
brid of shallow trees.

3. Spherical Convolutional Kernel

Our network derives its main strength from spherical
convolutional kernels. Thus, it is imperative to ﬁrst under-
stand the proposed kernel before delving into the network
details. This section explains our convolutional kernel for
3D point cloud processing.

For images, hand-crafted features have traditionally been
computed over more primitive constituents, i.e. patches. In
effect, the same principle transcended to automatic feature
extraction with the standard CNNs that compute feature
maps using the activations of well-deﬁned rectangular re-
gions. Whereas rectangular regions are a common choice
to process data of 2D nature, spherical regions are more
suited to process unstructured 3D data such as point clouds.
Spherical regions are inherently amenable to computing ge-
ometrically meaningful features for such data [9, 34, 35].
Inspired by this natural kinship, we introduce the concept
of spherical convolutional kernel1 that uses a 3D sphere as

1Note that the term spherical in Spherical CNN [5] is used for spherical

the basic geometric shape to perform the convolution.

Given an arbitrary point cloud P = {xi ∈ R3}m
i=1,
where m is the number of points; we deﬁne the convolu-
tion kernel with the help of a sphere of radius ρ ∈ R+.
For a target point xi, we consider its neighborhood N (xi)
to comprise the points within the sphere centered at xi,
i.e. N (xi) = {x : d(x, xi) ≤ ρ}, where d(., .) is a
distance metric - ℓ2 distance in this work. We divide the
sphere into n × p × q ‘bins’ (see Fig. 1) by partitioning
the occupied space uniformly along the azimuth (θ) and el-
evation (φ) dimensions. We allow the partitions along the
radial dimension to be non-uniform because cubic volume
growth for large radius values can become undesirable. Our
quantization of the spherical region is mainly inspired by
3DSC [9]. We also deﬁne an additional bin correspond-
ing to the origin of the sphere to allow the case of self-
convolution of points. For each bin, we deﬁne a weight

matrix Wκ∈{0,1,...,n×p×q} ∈ Rs×t of learnable parameters,
where s-t are the number of output-input channels and W0
relates to self-convolution. Together, the n×p×q+1 weight
matrices specify a single spherical convolutional kernel.
To compute the activation value for a target point xi, we
must identify the relevant weight matrices of the kernel for
each of its neighboring points xj ∈ N (xi). It is straightfor-
ward to associate xi with W0 for self-convolution. For the
non-trivial cases, we ﬁrst represent the neighboring points
in terms of their spherical coordinates that are referenced
using xi as the origin. That is, for each xj we compute
T (∆ji) → ψji, where T (.) deﬁnes the transformation
from Cartesian to Spherical coordinates and ∆ji = xj−xi.
Assuming that the bins of the quantized sphere are in-
dexed by kθ, kφ and kr along the azimuth, elevation and
radial dimensions respectively, the weight matrices asso-
ciated with the spherical kernel bins can be indexed as
κ = kθ + (kφ − 1) × n + (kr − 1) × n × p, where
kθ ∈ {1, . . . , n}, kφ ∈ {1, . . . , p}, kr ∈ {1, . . . , q}. Using
this indexing, we assign each ψji; and hence xj to its rele-
vant weight matrix. In the lth network layer, the activation
for the ith point can then be computed as:

1

zl
i =

|N (xi)|
i),

al
i = f (zl

|N (xi)|
X

j=1

Wl
κ

al−1
j + bl,

(1)

(2)

j

where al−1
is the activation value of a neighboring point
from layer l − 1, Wl
κ is the weight matrix, bl is the
bias vector, and f (·) is the non-linear activation function
- ReLU [25] in our experiments.
To elaborate on the characteristics of the proposed spher-
ical convolutional kernel, let us denote the edges of the ker-

surfaces (i.e. 360◦ images) not the ambient 3D space. Our concept of
spherical kernel widely differs from [5], and it is used in different context.

9633

nel bins along θ, φ and r dimensions respectively as:

radius ρ = √3, using the following edges for the bins:

Θ = [Θ1, . . . , Θn+1], Θk < Θk+1, Θk ∈ [−π, π],
π
π
Φ = [Φ1, . . . , Φp+1](cid:3), Φk < Φk+1, Φk ∈ (cid:2) −
,
2
2
R = [R1, . . . , Rq+1], Rk < Rk+1, Rk ∈ (0, ρ].

],

Due to the constraint of uniform splitting along the azimuth
and elevation, we can write Θk+1 − Θk = 2π
n and Φk+1 −
Φk = π
p .
Lemma 2.1: If Θk · Θk+1 ≥ 0, Φk · Φk+1 ≥ 0 and n > 2,
then for any two points xa 6= xb within the spherical con-
volutional kernel, the weight matrices Wκ,∀κ > 0, are
applied asymmetrically.
Proof: Let ∆ab = xa − xb = [δx, δy, δz]⊺, then ∆ba =
[−δx,−δy,−δz]⊺. Under the Cartesian to Spherical co-
ordinate transformation, we have T (∆ab) = ψab =
[θab, φab, r]⊺, and T (∆ba) = ψba = [θba, φba, r]⊺. We as-
sert that ψab and ψba fall in the same bin indexed by κ ←
(kθ, kφ, kr), i.e. Wκ is applied symmetrically to the points
xa and xb. In that case, under the inverse transformation
T −1(.), we have δz = r sin φab and (−δz) = r sin φba. The
condition Φkφ · Φkφ+1 ≥ 0 entails that −δ2
z = δz · (−δz) =
(r sin φab)·(r sin φba) = r2(sin φab sin φba) ≥ 0 =⇒ δz =
0. Similarly, Θkθ · Θkθ+1 ≥ 0 =⇒ δy = 0. Since xa 6= xb,
for δx 6= 0 we have cos θab = − cos θba =⇒ |θab − θba| =
π. However, if θab, θba fall into the same bin, we have
|θab − θba| = 2π
n < π, which entails δx = 0. Thus, the
assertion can not hold, and Wκ can not be applied to any
two points symmetrically unless both points are the same.

The asymmetry property of the spherical kernel is sig-
niﬁcant because it restricts the sharing of the same weights
between point pairs, which facilitates in learning more ef-
fective features with ﬁner geometric details. Lemma 2.1
also provides guidelines for the division of the convolu-
tion kernel into bins such that the asymmetry is always pre-
served. To elaborate further on this aspect, we provide few
examples of kernel divisions that violate asymmetry in the
supplementary material of the paper. Note that asymmet-
ric application of kernel weights to pixels comes naturally
in standard CNN kernels. However, the proposed kernel is
able to ensure the same property in the point cloud domain.

Relation to 3D-CNN: Here, we brieﬂy relate the proposed
notion of spherical kernel to the existing techniques that ex-
ploit CNNs for 3D data. Pioneering works in this direction
rasterize the raw data into uniform voxel grids, and then ex-
tract features using 3D-CNNs from the resulting volumetric
representations [23, 39]. In 3D-CNNs, the convolution ker-
nel of size 3 × 3 × 3 = 27 is prevalently used, that splits
the space in 1 cell/voxel for radius r = 0 (self-convolution);
6 cells for radius r = 1; 12 cells for radius r = √2; and
8 cells for radius r = √3. An analogous spherical con-

volution kernel for the same region can be speciﬁed with a

, 0,

, π];

π
Θ = [−π,−
2
π
,−
Φ = [−
4
R = [ǫ, 1,√2, ρ], ǫ → 0+.

π
2
π
4

π
2

π
2

, 0,

];

,

(3)

This division results in a kernel size (i.e. total number of
bins) 4 × 4 × 3 + 1 = 49, which is the coarsest multi-scale
quantization allowed by Lemma 2.1.
Notice that, if we move radially from the center to the pe-
riphery of spherical kernel, we encounter identical number
of bins (16 in this case) after each edge deﬁned by R, where
ﬁne-grained bins are located close to the origin that can
encode detailed local geometric information of the points.
This is in sharp contrast to 3D-kernels that must keep the
size of all cells constant and rely on increased input reso-
lution of the data to capture ﬁner details - generally entail-
ing memory issues. The multi-scale granularity of spherical
kernel makes it a natural choice for raw point clouds.

4. Neural Network

Most of the existing attempts to process point clouds
with neural networks [18, 19, 28, 32, 33] rely on K-NN
or range searches to deﬁne local neighborhood of points,
that are subsequently used to perform operations like con-
volution or pooling. However,
to process large point
clouds, these search strategies become computationally pro-
hibitive. For unstructured data, an efﬁcient mechanism
to deﬁne point neighbourhood is tree-structuring, e.g. Kd-
tree [2]. The hierarchical nature of tree structures also pro-
vide guidelines for neural network architectures that can be
used to process the point cloud. More importantly, a tree-
structured data also possess the much desired attributes of
permutation and translation invariance for neural networks.

A. Core Architecture

We exploit octree structuring [24] of point clouds and
design a neural network based on the resulting trees. Our
choice of using octree comes from its amenability to neural
networks as the base data structure [29], and its ability to
account for more data in point neighborhoods compared to,
for example, Kd-tree. We illustrate 3D space partitioning
under octree, the resulting tree, and the formation of neural
network using the proposed strategy of network construc-
tion in Fig. 2 for a toy example. For an input point cloud
P, we construct an octree of depth L (L = 3 in the ﬁgure).
In the construction, the splitting of nodes is ﬁxed to use a
maximum capacity of one point, with the exception of the
last layer leaf nodes. The point in a parent node is computed
as the Expected value of the points in its children. The al-
location of multiple points in the last layer nodes directly
results from the allowed ﬁnest partitioning of the space. For
the sub-volumes in 3D space that are not densely populated,

9634

Figure 2. Illustration of octree guided network architecture using a toy example: The point cloud in 3D space is partitioned under an
octree of depth 3. The corresponding tree representation allocates points to nodes at the maximum depth based on the space partitioning,
and computes the location of each parent node as the Expected location of its children. Leaf nodes on shallow branches are replicated to
match the maximum depth. The corresponding neural network has the same number of hidden layers as tree depth, and it learns spherical
convolutional kernels for feature extraction.

our splitting strategy can result in leaf nodes before the tree
reaches its maximum depth. In such cases, to facilitate map-
ping of the tree to a neural network, we replicate the leaf
nodes to the maximum depth of the tree. We safely ignore
the empty nodes while implementing the network, resulting
in computational and memory beneﬁts.

Based on the hierarchical tree structure, our neural net-
work also has L hidden layers. Notice that, in Fig. 2 we use
l = 1 for the ﬁrst hidden layer that corresponds to Depth
= 3 for the tree. We will use the same convention in the
text to follow. For each non-empty node in the tree, there
is a corresponding neuron in our neural network. Recall
that, a spherical convolutional kernel is speciﬁed with a tar-
get point over whose neighborhood the convolution is per-
formed. Therefore, to facilitate convolutions, we associate a
single 3D point with each neuron, except for the leaf nodes
at the maximum depth of the tree. For a leaf node, the as-
sociated point is the mean value of data points allocated to
that node. A neuron uses its associated point/location to
select the appropriate spherical kernel and later applies the
non-linear activation (not shown in Fig. 2). In our network,
all convolution layers before the last layer are followed by
batch normalization and ReLU activations.

We denote the location associated with the ith neuron in
the lth layer of the network as ¯xl
i. From l = 1 to l = L,
we can represent the locations associated with all neurons
1 }mL
i=1. Denoting the raw
i is numerically computed

i}m1
i=1, . . . , QL = {¯xL
i=1, ¯xl

as Q1 = {¯x1
input points as Q0 = {¯x0

by our network as:

i}m0
P

¯xl−1

j

¯x

¯xl

i =

l−1

j ∈N (¯xl
i)
|N (¯xl
i)|

,

(4)

where N (¯xl

i) contains locations of the relevant children
nodes in the octree.
It is worth noting that the strategy
used for specifying the network layers also entails that

|Ql−1| > |Ql|. Thus, from the ﬁrst layer to the last, the

features learned by our network move from lower to higher
level of abstraction similar to the standard CNNs.

In relating the spherical nature of point neighborhood
considered in our network to the cubic partitioning of space
by octree, a subtle detail is worth considering. Say xmin =
[xmin, ymin, zmin]⊺, and xmax = [xmax, ymax, zmax]⊺ deter-
mine the range of point coordinates in a given cubic volume
resulting from our space partitioning. The spherical neigh-
borhood associated with a neuron in the lth layer is deﬁned
with the radius ρ = 2l−L−1||xmax − xmin||2. This neigh-

bourhood may not strictly circumscribe all points of the cor-
responding cubic volume at this level due to shape dissimi-
larity. Although the number of such points is minuscule in
practice, we still take those into account by assigning them
to the outer-most bins of our kernels based on their azimuth
and elevation values.

Our neural network performs inter-layer convolutions in-
stead of intra-layer convolutions. This drastically reduces
the operations required to process large point clouds when
compared with graph-based networks [3, 7, 15, 33, 41].
We note that for all nodes with a single child, only self-
convolutions are performed in the network. Note that due
to its unconventional nature, spherical convolutional kernel
is not readily implemented using the existing deep learning
libraries, e.g. matconvnet [36]. Therefore, we implement
it ourselves with CUDA C++ and mex interface2. For the
other modules such as ReLU, batch normalization etc., we
use matconvnet. See Sec. E of the supplementary material
to understand the spherical kernel in a conventional way.

Comparison to OctNet [29]: OctNet [29] also makes use
of octree structure. However, OctNet processes point clouds
as regular 3D volumes - a 3D-CNN. In contrast, we process
point clouds following their unstructured nature. Our net-

work learns features for each point in the sets from Q0 to
QL, which is in contrast to OctNet that must account for

occupied and unoccupied voxels, entailing complexity. We
exploit octree structure to simultaneously construct neigh-
borhoods of all points and coarsen the original point cloud
layer-by-layer, while OctNet uses this structure to voxelize

2The implementation will be made public.

9635

Figure 3. Classiﬁcation and segmentation using the core network of Fig. 2. For classiﬁcation, the features at the root node (top layer)
are concatenated with the max-pooled (dashed lines) features at the remaining layers followed by FC layers. For segmentation, the
representation of a point uses the layer-level features of all the ancestors along the path to the root node, e.g. red path for point ‘1’ and blue
path for point ‘m’. Point-wise classiﬁcation (segmentation) is performed using the concatenated raw point features (xyz/xyz − rgb), the
MLP features and all the extracted layer-level features. A simple conﬁguration MLP(32)-Octree(64-128-256) is shown for illustration.

the point cloud into different resolutions.

B. Classiﬁcation and Segmentation

The classiﬁcation and segmentation networks are basi-
cally variants of the same core architecture shown in Fig 2.
However, we additionally insert an MLP layer prior to the
octree structure to obtain more expressive point-wise fea-
tures. This concept is inspired from Kd-Net [16]. Figure 3
shows the complete architectures for classiﬁcation and seg-
mentation. To fully exploit the hierarchical features learned
at different octree levels, we use features from all octree lay-
ers. For classiﬁcation, we max pool the features from inter-
mediate layers, including the raw features, and concatenate
them with the features at the root node to form a global rep-
resentation of the complete point cloud. For segmentation,
we need point wise features. The feature of each point is
the concatenation of raw features, MLP features and layer-
wise features without any pooling. The ﬁnal classiﬁcation
or segmentation is performed using three fully connected
layers.

5. Experiments

We conduct experiments on clean CAD Models as well
as noisy point clouds to evaluate the performance of our
method for the tasks of 3D object classiﬁcation, part seg-
mentation and semantic segmentation. Throughout the ex-
periments, we keep the size of our convolution kernel ﬁxed
to 8 × 2 × 3 + 1, in which the radial dimension is split uni-
formly. We use three fully connected layers (512-256-C)
followed by softmax as the classiﬁer for both the classiﬁca-
tion and segmentation tasks. Here, C denotes the number of
classes/parts. The training of our network is conducted us-
ing a Titan Xp GPU with 12 GB memory. We use Stochas-
tic Gradient Descent with momentum to train the network.
The batch size is kept ﬁxed to 16 in all our experiments.
These hyper-parameters were empirically optimized using
cross-validation. We use only the (x, y, z) coordinates of
points provided by point clouds to train our network, and the
(r, g, b) values when the color information is provided. Few

existing methods in the literature also take advantage of nor-
mals, and use them as input features. However, normals are
not directly sensed by 3D sensors and must be computed us-
ing the point coordinates. This also entails additional com-
putational burden. Hence, we avoid using normals as input
features. In our experiments, we follow the standard prac-
tice of taking advantage of data augmentation. To that end,
we used random sub-sampling of the original point clouds,
performed random azimuth rotation (up to π
6 rad) and also
applied noisy translation (std. dev = 0.02) to increase the
number of training examples. These operations were per-
formed on the ﬂy in each training epoch of the network.

A. Classiﬁcation

We use the benchmark datasets ModelNet10 and Model-
Net40 [39] to evaluate our technique for the classiﬁcation
task. These datasets are created using clean CAD models.
ModelNet10 contains 10 categories of object meshes, and
the samples are split into 3,991 training examples and 908
test instances. ModelNet40 contains object meshes for 40
categories with 9,843/2,468 training/testing split.

Compared to existing works (e.g. [27, 28, 32, 33]), the
convolutions performed in our network allow the proposed
method to consume large input point clouds. Hence, we
train our network using 10K input points. For the classiﬁ-
cation task, we adopted a network with 6 levels of octree,
whereas the number of feature channels are kept MLP(32)-
Octree(64-64-64-128-128-128). The network comprises
two components, octree based architecture for feature ex-
traction and classiﬁcation stage. We train the whole net-
work in an end-to-end fashion. We standardize the input
models by normalizing the 3D point clouds to ﬁt into a cube

of [−1, 1]3 with zero mean.
Table 1 benchmarks the object classiﬁcation perfor-
mance of our approach that is abbreviated as Ψ-CNN3. Our
method uses xyz coordinates of points as raw features to
achieve these results. As can be seen, Ψ-CNN consistently

3A Greek alphabet is chosen as preﬁx to avoid duplication with other

OCNNs and SCNNs, e.g. [21, 26, 37].

9636

Table 1. Classiﬁcation performance on ModelNets [39].
ModelNet40

ModelNet10

Method

class

instance

class

instance

OctNet [29]
ECC [33]
PointNet [27]
PointNet++ [28]
Kd-Net [16]
SO-Net [18]
KCNet [32]
Ψ-CNN

90.1
90.0

–
–

92.8
93.9

–

94.4

90.9
90.8

–
–

93.3
94.1
94.4
94.6

83.8
83.2
86.2

–

86.3
87.3

–

88.7

86.5
87.4
89.2
90.7
90.6
90.9
91.0
92.0

achieves the best performance on ModelNets. We note that,
like our method Kd-Net [16] and OctNet [29] are also tree
structure based networks. However, they require twice the
number of parametric layers as required by our method to
achieve the reported performance. This is a direct conse-
quence of effective exploration of geometric information by
the proposed kernel. We also provide an ablation study to
support this in the supplementary material of the paper.

B. Part Segmentation

ShapeNet part segmentation dataset [40] contains 16,881
CAD models from 16 categories. The models in each cat-
egory have two to ﬁve annotated parts, amounting to 50
parts in total. The point clouds are created with uniform
sampling from 3D meshes. This dataset provides xyz co-
ordinates of the points as raw features, and has 14007/2874
training/testing split deﬁned. We use a 6-level octree for
the segmentation network, with conﬁguration MLP(64)-
Octree(128-128-256-256-512-512). The output class num-
ber C of the classiﬁer is determined by the number of parts
in each category. We use the part-averaged IoU (mIoU) pro-
posed in [27] to report the performance in Table 2. Simi-
lar to the classiﬁcation task, we also standardize the input
models of ShapeNet by normalizing input point clouds to

[−1, 1]3 cube with zero mean.

In Table 2, we compare our results with the popular
methods that also take irregular point clouds as input. Yet,
to achieve their results, some of these methods exploit nor-
mals besides xyz coordinates as input features, e.g. Point-
Net, PointNet++, SO-Net. It can seen that Ψ-CNN not only
achieves the highest mIoU 86.8%, but also outperforms the
other approaches on 11 out of 16 categories. To the best
of our knowledge, Ψ-CNN records the new state-of-the-
art performance on this part segmentation dataset that is
∼ 1% higher than the specialized segmentation networks,
SSCN [11] and SGPN [38].

In Fig. 4, we show few representative segmentation re-
sults. High mIoU is achieved by Ψ-CNN for the high-
quality results, whereas the mIoU value is low for the other
case. Examining the low-quality results, we found that
most of these cases are caused by one of the two condi-
tions. (1) Confusing ground truth labelling: E.g. the axle in

Skateboard is labelled as a separate segment in most of the
ground truth samples but part of the wheels in few other
samples. Hence, the network learns the more dominant
segmentation. Similar is the case for the legs of Chairs.
(2) Small parts without clear boundaries: E.g. handles of a
Bag are considered separate segments in the ground truth.
We also provide further examples in the supplementary ma-
terial. From these results, we can easily conclude the suc-
cess of Ψ-CNN for the part segmentation task.

C. Semantic Segmentation

We also test our model for Semantic Segmentation of
real world data with RueMonge2014 dataset [30]. This
dataset contains 700 meter facades along a street annotated
with point-wise labelling. The classes includes window,
wall, balcony, door, roof, sky and shop. The point clouds are
provided with color features. To train our network, we split
both the training and testing data into 1m3 blocks. We align
the facade plane of all the blocks into the same plane, and
adjust the gravitational axis to be upright. We only force
the x and y dimensions to have zero-means, but not the
z axis. This processing strategy is adopted to avoid loos-
ing the height information. We use xyz+rgb as input raw
features to train our network. The used network conﬁgura-
tion is MLP(64)-Octree(64-64-128-128-256-256). Table 3
compares the results of our approach with those of the re-
cent methods on this dataset, under the evaluation protocol
of [10]. With 7 parametric layers, we achieve better per-
formance than OctNet, which uses 20 parametric layers to
learn the ﬁnal representation of each point. These results
demonstrate the promises of Ψ-CNN in practical applica-
tions. Visualizations for the segmentation results are pro-
vided in the supplementary material.

D. Discussion

For geometrically meaningful convolutions, knowledge
of local neighborhood of points is imperative. A related
approach, ECC [33] exploits range search for this purpose.
Another obvious choice is K-NN clustering. However, with
tree structures, e.g. octree; the point neighborhood infor-
mation is already readily available that adds to computa-
tional efﬁciency of Ψ-CNN. In Fig. 5, we report the tim-
ings of computing neighborhoods under different choices,
and compare them to octree construction. As can be seen,
for larger number of input points, octree structuring is more
efﬁcient as compared to K-NN and range searching. More-
over, its efﬁciency is also better than Kd-tree for large input
sizes because the binary split in Kd-tree forces it to be much
deeper than octree.

Running our classiﬁcation network on 1K randomly se-
lected samples from ModelNets, we compute the test time
of our network for point clouds of sizes 10K, and report tim-
ings in Table 4. The test time for a sample consists of time
required to construct the octree and performing the forward

9637

High-Quality Segmentation

Low-Quality Segmentation

GT

Ours

GT

Ours

GT

Ours

GT

Ours

Lamp

91.4%

Bag

98.1%

Lamp

35.5%

Bag

46.8%

Skateboard

92.2%

Chair

96.0%

Skateboard

55.8%

Chair

41.6%

Figure 4. Representative examples of high- and low-quality segmentation results of Ψ-CNN. Computed mIoU is also given in each case.
Low-quality segemetation generally result from: (1) confusing ground truth labeling, e.g. axles of skateboards are considered separate
segments in most of the ground-truth labels, (2) small object parts with no clear boundaries, e.g. handles of bags. Color coding is within
category (best viewed on screen).

Table 2. Results on ShapeNet part segmentation dataset

Method
3D-CNN [27]
Kd-net [16]
PointNet [27]
SyncSpecCNN [41]
KCNet [32]
SO-Net [18]
PointNet++ [28]
Ψ-CNN

mIoU NO. Airplane Bag Cap Car Chair Earphone Guitar Knife Lamp Laptop Motorbike Mug Pistol Rocket Skateboard Table
77.1
79.4
80.3
82.3
80.6
83.7
82.1
84.7
84.7
81.3
83.0
84.9
82.6
85.1
86.8
85.9

72.8 73.3 70.0 87.2
74.6 74.3 70.3 88.6
78.7 82.5 74.9 89.6
81.7 81.9 75.2 90.2
81.5 86.4 77.6 90.3
77.8 88.0 77.3 90.6
79.0 87.7 77.3 90.8
82.1 83.8 80.5 91.0

88.4
90.2
91.5
93.0
91.0
90.7
91.0
91.6

79.6
87.2
85.9
86.1
87.2
83.9
85.9
86.7

65.3
69.9
72.8
82.9
75.2
72.9
76.4
75.9

63.5
73.5
73.0
74.9
76.8
73.5
71.8
78.3

74.4
81.0
80.8
84.7
84.5
82.8
83.7
84.7

93.9
94.9
95.3
95.6
95.5
94.8
95.3
95.6

58.7
57.4
65.2
66.7
69.2
69.1
71.6
74.8

91.8
86.7
93.0
92.7
94.4
94.2
94.1
94.5

76.4
78.1
81.2
81.6
81.6
80.9
81.3
83.4

51.2
51.8
57.9
60.6
60.1
53.1
58.7
61.3

75.1
80.1
83.4
81.6
82.8
82.8
82.4
84.2

0
0
0
2
1
1
0
11

Table 3. Semantic Segmentation on RueMonge2014 dataset

Method
Riemenschneider et al. [30]
Martinovic et al. [22]
Gadde et al. [10]
OctNet 2563 [29]
Ψ-CNN

Average Overall

–
–

68.5
73.6
74.7

–
–

78.6
81.5
83.5

IoU
42.3
52.2
54.4
59.2
63.6

Figure 5. Comparison of octree structuring with K-NN, range
search and Kd-tree for neighborhood computation.

Input size Octree construction Forward pass

10K

3.5

30.6

Total

34.1

Normal computation

27.4

Table 4. Per-sample test time (ms) for 10K input. The computing
time for normals is included for reference only - indicated by red.

pass. We also show the time of normal computation in the
table for reference. Our approach does not compute nor-
mals to achieve the results reported in the previous section.
To put these timings into perspective, PointNet++ [28] re-
quires roughly 115ms for a forward pass of input with 1024
points on the same machine. In Fig. 6, we also show a repre-
sentative example of point cloud coarsening by our method

l = 1

l = 2

l = 3

l = 4

l = 5

Figure 6. Point cloud coarsening example under octree structuring
by our technique. ‘l’ is the octree level.

under octree structuring. Our network gradually sparsiﬁes
the point cloud by applying spherical convolutional kernel
at each level.

6. Conclusion

We introduced the notion of spherical convolutional ker-
nels for point cloud processing and demonstrated its util-
ity with a neural network guided by octree structure. The
network successively performs convolutions in the neigh-
borhood of its neurons, the locations of which are governed
by the nodes of the underlying octree. To perform the con-
volutions, our spherical kernel divides its occupied space
into multiple bins and associates a weight matrix to each
bin. These matrices are learned with network training. We
have shown that the resulting network can efﬁciently pro-
cess large 3D point clouds in effectively achieving excellent
performance on the tasks of 3D classiﬁcation and segmen-
tation on synthetic and real data.
Acknowledgments This
supported by
ARC Discovery Grant DP160101458 and partially by
DP190102443. We also thank NVIDIA corporation for do-
nating the Titan XP GPU used in our experiments.

research was

9638

References

[1] I. Armeni, O. Sener, A. R. Zamir, H. Jiang, I. Brilakis,
M. Fischer, and S. Savarese. 3D semantic parsing of large-
scale indoor spaces. In Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, pages 1534–
1543, 2016. 1

[2] J. L. Bentley. Multidimensional binary search trees used
for associative searching. Communications of the ACM,
18(9):509–517, 1975. 4

[3] J. Bruna, W. Zaremba, A. Szlam, and Y. LeCun. Spectral
networks and locally connected networks on graphs. In In-
ternational Conference on Learning Representations, 2014.
1, 2, 5

[4] A. X. Chang, T. Funkhouser, L. Guibas, P. Hanrahan,
Q. Huang, Z. Li, S. Savarese, M. Savva, S. Song, H. Su,
et al. ShapeNet: An information-rich 3D model repository.
arXiv preprint arXiv:1512.03012, 2015. 1

[5] T. S. Cohen, M. Geiger, J. K¨ohler, and M. Welling. Spherical
cnns. In International Conference on Learning Representa-
tions, 2018. 3

[6] B. De Brabandere, X. Jia, T. Tuytelaars, and L. Van Gool.
Dynamic ﬁlter networks. In Advances in Neural Information
Processing Systems, 2016. 3

[7] M. Defferrard, X. Bresson, and P. Vandergheynst. Convolu-
tional neural networks on graphs with fast localized spectral
ﬁltering. In Advances in Neural Information Processing Sys-
tems, pages 3844–3852, 2016. 1, 2, 5

[8] M. Engelcke, D. Rao, D. Zeng Wang, C. Hay Tong, and
I. Posner. Vote3Deep: Fast object detection in 3D point
clouds using efﬁcient convolutional neural networks.
In
IEEE International Conference on Robotics and Automation,
June 2017. 3

[9] A. Frome, D. Huber, R. Kolluri, T. B¨ulow, and J. Malik.
Recognizing objects in range data using regional point de-
scriptors. European Conference on Computer Vision, pages
224–237, 2004. 3

[10] R. Gadde, V. Jampani, R. Marlet, and P. V. Gehler. Efﬁcient
2D and 3D facade segmentation using auto-context.
IEEE
transactions on Pattern Analysis and Machine Intelligence,
40(5):1273–1280, 2018. 7, 8

[11] B. Graham, M. Engelcke, and L. van der Maaten. 3D se-
mantic segmentation with submanifold sparse convolutional
networks. Proceedings of the IEEE Computer Vision and
Pattern Recognition, pages 18–22, 2018. 7
[12] T. Hackel, N. Savinov, L. Ladicky,

J. D. Wegner,
K. Schindler, and M. Pollefeys. Semantic3D.net: A new
large-scale point cloud classiﬁcation benchmark. In ISPRS
Annals of the Photogrammetry, Remote Sensing and Spatial
Information Sciences, pages 91–98, 2017. 1

[13] J. Huang and S. You. Point cloud labeling using 3D convo-
lutional neural network. In ICPR, pages 2670–2675, 2016.
3

[14] M. Jaderberg, K. Simonyan, A. Zisserman, et al. Spatial
In Advances in Neural Information

transformer networks.
Processing Systems, pages 2017–2025, 2015. 2

[15] T. N. Kipf and M. Welling. Semi-supervised classiﬁcation
with graph convolutional networks. In International Confer-
ence on Learning Representations, 2017. 1, 2, 5

[16] R. Klokov and V. Lempitsky. Escape from cells: Deep kd-
networks for the recognition of 3d point cloud models.
In
Proceedings of the IEEE International Conference on Com-
puter Vision, pages 863–872. IEEE, 2017. 1, 2, 6, 7, 8

[17] Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-
based learning applied to document recognition. Proceed-
ings of the IEEE, 86(11):2278–2324, 1998. 1

[18] J. Li, B. M. Chen, and G. H. Lee. So-net: Self-organizing
network for point cloud analysis. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition,
pages 9397–9406, 2018. 2, 4, 7, 8

[19] Y. Li, R. Bu, M. Sun, and B. Chen. Pointcnn. Advances in

Neural Information Processing Systems, 2018. 2, 4

[20] Y. Li, S. Pirk, H. Su, C. R. Qi, and L. J. Guibas. FPNN: Field
probing neural networks for 3D data. In Advances in Neural
Information Processing Systems, pages 307–315, 2016. 3

[21] B. Liu, M. Wang, H. Foroosh, M. Tappen, and M. Pensky.
Sparse convolutional neural networks. In Proceedings of the
IEEE Conference on Computer Vision and Pattern Recogni-
tion, pages 806–814, 2015. 6

[22] A. Martinovic,

J. Knopp, H. Riemenschneider,

and
L. Van Gool. 3D all the way: Semantic segmentation of
urban scenes from start to end in 3D. In Proceedings of the
IEEE Conference on Computer Vision and Pattern Recogni-
tion, pages 4456–4465, 2015. 8

[23] D. Maturana and S. Scherer. VoxNet: A 3D convolutional
neural network for real-time object recognition. In IEEE/RSJ
International Conference on Intelligent Robots and Systems,
pages 922–928. IEEE, 2015. 1, 3, 4

[24] D. Meagher. Geometric modeling using octree encoding.
Computer graphics and image processing, 19(2):129–147,
1982. 1, 4

[25] V. Nair and G. E. Hinton. Rectiﬁed linear units improve
In ICML, pages 807–814,

restricted boltzmann machines.
2010. 3

[26] A. Parashar, M. Rhu, A. Mukkara, A. Puglielli, R. Venkate-
san, B. Khailany, J. Emer, S. W. Keckler, and W. J. Dally.
SCNN: An accelerator for compressed-sparse convolutional
neural networks. In Proceedings of the 44th Annual Interna-
tional Symposium on Computer Architecture, pages 27–40.
ACM, 2017. 6

[27] C. R. Qi, H. Su, K. Mo, and L. J. Guibas. PointNet: Deep
learning on point sets for 3D classiﬁcation and segmenta-
tion. Proceedings of the IEEE Conference on Computer Vi-
sion and Pattern Recognition, pages 652–660, 2017. 1, 2, 6,
7, 8

[28] C. R. Qi, L. Yi, H. Su, and L. J. Guibas. PointNet++: Deep
hierarchical feature learning on point sets in a metric space.
Advances in Neural Information Processing Systems, 2017.
1, 2, 4, 6, 7, 8

[29] G. Riegler, A. Osman Ulusoy, and A. Geiger. OctNet: Learn-
ing deep 3d representations at high resolutions. In Proceed-
ings of the IEEE Conference on Computer Vision and Pattern
Recognition, pages 3577–3586, 2017. 1, 2, 3, 4, 5, 7, 8

9639

[30] H. Riemenschneider, A. B´odis-Szomor´u, J. Weissenberg,
and L. Van Gool. Learning where to classify in multi-view
semantic segmentation.
In European Conference on Com-
puter Vision, pages 516–532, 2014. 2, 7, 8

[31] N. Sedaghat, M. Zolfaghari, and T. Brox. Orientation-
boosted voxel nets for 3D object recognition. In British Ma-
chine Vision Conference, 2017. 3

[32] Y. Shen, C. Feng, Y. Yang, and D. Tian. Mining point cloud
local structures by kernel correlation and graph pooling. In
Proceedings of the IEEE Conference on Computer Vision
and Pattern Recognition, volume 4, 2018. 2, 4, 6, 7, 8

[33] M. Simonovsky and N. Komodakis.

Dynamic edge-
conditioned ﬁlters in convolutional neural networks on
graphs.
In Proceedings of the IEEE Conference on Com-
puter Vision and Pattern Recognition, 2017. 1, 2, 4, 5, 6,
7

[34] F. Tombari, S. Salti, and L. Di Stefano. Unique shape context
for 3D data description. In Proceedings of the ACM work-
shop on 3D object retrieval, pages 57–62. ACM, 2010. 3

[35] F. Tombari, S. Salti, and L. Di Stefano. Unique signatures of
histograms for local surface description. In European Con-
ference on Computer Vision, pages 356–369, 2010. 3

[36] A. Vedaldi and K. Lenc. Matconvnet: Convolutional neural
networks for matlab. In Proceedings of the 23rd ACM inter-
national conference on Multimedia, pages 689–692. ACM,
2015. 5

[37] P.-S. Wang, Y. Liu, Y.-X. Guo, C.-Y. Sun, and X. Tong. O-
CNN: Octree-based convolutional neural networks for 3D
shape analysis. ACM Transactions on Graphics, 36(4):72,
2017. 6

[38] W. Wang, R. Yu, Q. Huang, and U. Neumann. SGPN:
Similarity group proposal network for 3D point cloud in-
stance segmentation. In Proceedings of the IEEE Conference
on Computer Vision and Pattern Recognition, pages 2569–
2578, 2018. 7

[39] Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and
J. Xiao. 3D ShapeNets: A deep representation for volumetric
shapes. In Proceedings of the IEEE Conference on Computer
Vision and Pattern Recognition, pages 1912–1920, 2015. 1,
2, 3, 4, 6, 7

[40] L. Yi, V. G. Kim, D. Ceylan, I. Shen, M. Yan, H. Su, A. Lu,
Q. Huang, A. Sheffer, L. Guibas, et al. A scalable active
framework for region annotation in 3D shape collections.
ACM Transactions on Graphics, 35(6):210, 2016. 1, 2, 7

[41] L. Yi, H. Su, X. Guo, and L. J. Guibas. Syncspeccnn: Syn-
chronized spectral cnn for 3d shape segmentation. In Pro-
ceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pages 2282–2290, 2017. 2, 5, 8

[42] A. Zeng, S. Song, M. Nießner, M. Fisher, J. Xiao, and
T. Funkhouser. 3DMatch: Learning local geometric descrip-
tors from RGB-D reconstructions.
In Proceedings of the
IEEE Conference on Computer Vision and Pattern Recog-
nition, pages 199–208, 2017. 3

[43] Y. Zhang, M. Bai, P. Kohli, S. Izadi, and J. Xiao. Deep-
context: Context-encoding neural pathways for 3D holistic
scene understanding.
In Proceedings of the IEEE Interna-
tional Conference on Computer Vision, pages 1192–1201,
2017. 3

9640

