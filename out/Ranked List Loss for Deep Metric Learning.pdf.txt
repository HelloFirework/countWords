Ranked List Loss for Deep Metric Learning

Xinshao Wang1,2, Yang Hua1, Elyor Kodirov2, Guosheng Hu2,1, Romain Garnier2, Neil M. Robertson1,2
1 School of Electronics, Electrical Engineering and Computer Science, Queen’s University Belfast, UK

{xwang39, y.hua, n.robertson}@qub.ac.uk, {elyor, guosheng.hu, romaing}@anyvision.co

2 Anyvision Research Team, UK

Abstract

The objective of deep metric learning (DML) is to learn
embeddings that can capture semantic similarity informa-
tion among data points. Existing pairwise or tripletwise
loss functions used in DML are known to suffer from slow
convergence due to a large proportion of trivial pairs or
triplets as the model improves. To improve this, ranking-
motivated structured losses are proposed recently to incor-
porate multiple examples and exploit the structured infor-
mation among them. They converge faster and achieve
state-of-the-art performance. In this work, we present two
limitations of existing ranking-motivated structured losses
and propose a novel ranked list loss to solve both of them.
First, given a query, only a fraction of data points is in-
corporated to build the similarity structure. Consequently,
some useful examples are ignored and the structure is less
informative. To address this, we propose to build a set-
based similarity structure by exploiting all instances in the
gallery. The samples are split into a positive set and a nega-
tive set. Our objective is to make the query closer to the pos-
itive set than to the negative set by a margin. Second, previ-
ous methods aim to pull positive pairs as close as possible in
the embedding space. As a result, the intraclass data distri-
bution might be dropped. In contrast, we propose to learn a
hypersphere for each class in order to preserve the similar-
ity structure inside it. Our extensive experiments show that
the proposed method achieves state-of-the-art performance
on three widely used benchmarks.

1. Introduction

Deep metric learning (DML) plays a crucial role in a va-
riety of applications in computer vision, such as image re-
trieval [28, 19], clustering [10], and transfer learning [20].
In addition, DML is a good solution for challenging extreme
classiﬁcation settings [22, 40], in which there exist an enor-
mous number of classes and only a few images per class.
For example, by using DML, FaceNet [24] achieves super-
human performance on face veriﬁcation with 260M face im-
ages of 8M identities.

Figure 1: Illustration of our proposed RLL. Given a query
and its ranked list, RLL aims to make the query closer to the
positive set than to the negative set by a margin m. Circle
and triangle represent two different classes. The blue circle
is a query. The yellow shapes represent nontrivial examples
while the red shapes represent trivial examples. The arrow
indicates the query’s gradient direction determined by the
corresponding non-trivial examples. The ﬁnal gradient di-
rection of the query is a weighted combination of them. The
optimised ranked list is shown in the bottom.

Loss function plays a key role in successful DML frame-
works and a large variety of loss functions have been pro-
posed in the literature. Contrastive loss [2, 6] captures the
relationship between pairwise data points, i.e., similarity or
dissimilarity. Triplet-based losses are also widely studied
[24, 33, 3]. A triplet is composed of an anchor point, a simi-
lar (positive) data point and dissimilar (negative) data point.
The purpose of triplet loss is to learn a distance metric by
which the anchor point is closer to the similar point than
the dissimilar one by a margin. In general, the triplet loss
outperforms the contrastive loss [20, 24] because the rela-
tionship between positive and negative pairs is considered.
Inspired by this, recent work [24, 28, 20, 29, 16, 19] pro-
poses to take into consideration the richer structured infor-
mation among multiple data points and achieve impressive

5207

performance on many applications, e.g., image retrieval and
clustering.

However, there are still certain limitations in current
state-of-the-art DML approaches. Firstly, we notice that
only a proportion of informative examples is incorporated
to capture the structure in previous ranking-motivated loss
functions.
In this case, some non-trivial examples are
wasted and the structured information is extracted from
fewer data points. To address it, we propose to utilise all
non-trivial data points to build a more informative struc-
ture and exploit it to learn more discriminative embeddings.
Speciﬁcally, given a query, we obtain a ranked list by sort-
ing all other data points (gallery) according to the similar-
ities. Ideally, all the positive examples are supposed to be
ranked before the negative samples in the feature space. To
achieve this, we propose ranked list loss (RLL) to organise
the samples of each query. Given a query, the optimisa-
tion of RLL is to rank all positive points before the neg-
ative points and forcing a margin between them. In other
words, RLL aims to explore the set-based similarity struc-
ture, which contains richer information than the point-based
approach, e.g., triplet loss.

Secondly, we observe that the intraclass data distribution
is not considered in the previous structured losses. All al-
gorithms [24, 20, 28, 29, 19] target to pull data points in
the same class as close as possible. Consequently, these ap-
proaches try to shrink samples of the same class into one
point in the feature space and may easily drop their sim-
ilarity structure. To address this, we propose to learn a
hypersphere for each class in RLL. Speciﬁcally, instead of
pulling intraclass examples as compact as possible, we only
force the distance of a positive pair smaller than a thresh-
old, which is the diameter of each class’s hypersphere. In
this case, RLL can help preserve the similarity structure in-
side each class as much as possible.

Empirically,

the convergence rate of DML methods
highly depends on the possibility of seeing non-trivial sam-
ples [24]. Given an anchor (query), it is non-trivial to sep-
arate the positive and negative sets by a margin when all
data points are considered. As a result, only a few ranked
lists are perfectly optimized as the model improves during
training. Therefore, our method can take advantage of a
maximum of elements with non-zero losses and release the
potentials for the learning procedure. The proposed RLL is
illustrated in Figure 1.

Our contributions in this paper are listed as follows:

• We propose a novel ranking-motivated structured loss
(RLL) to learn discriminative embeddings. In contrast
with previous ranking-motivated losses, we are the ﬁrst
to incorporate all non-trivial data points and exploit
the structure among them. Besides, we learn a hyper-
sphere for each class to preserve intraclass data distri-
bution instead of shrinking each class into one point in

the embedding space.

• We achieve new state-of-the-art performance on three
popular benchmarks, i.e., CARS196 [15], CUB-200-
2011 [32] and SOP [20].

2. Preliminaries

Notations. Let X = {(xi, yi)}N
i=1 be the input data, where
(xi, yi) indicates i-th image and its corresponding class la-
bel. The total number of classes is C, i.e., yi ∈ [1, 2, ..., C].
i }Nc
The images from c-th class are represented as {xc
i=1,
where Nc is the number of images in c-th class.

2.1. Structured Losses

2.1.1 Ranking-Motivated Structured Losses

Triplet Loss [37, 24] aims to pull the anchor point closer
to the positive point than to the negative point by a ﬁxed
margin m:

L(X; f ) =

1
|Γ| X

(i,j,k)∈Γ

[d2

ij + m − d2

ik]+,

(1)

where Γ is the set of triplets, i, j and k are the indexes of
anchor, positive and negative points, respectively. f is the
embedding function, dij = ||f (xi) − f (xj)||2 is the Eu-
clidean distance. [·]+ is the hinge function.

N-pair-mc [28] exploits the structured relationship
among multiple data points to learn the embedding func-
tion. Triplet loss pulls one positive point while pushing a
negative one simultaneously. To improve the triplet loss by
interacting with more negative classes and examples, N -
pair-mc aims to identify one positive example from N − 1
negative examples of N − 1 classes (one negative example
per class):

L({(xi, x+

i )}N

i=1; f ) =

1
N

N

X

log{1+

i=1
exp(f ⊤

X

i f +

j − f ⊤

i f +

i )}

,

(2)

j6=i

i )}N

where fi = f (xi) and {(xi, x+
i=1 are N pairs of exam-
ples from N different classes, i.e., yi 6= yj, ∀i 6= j. Here, xi
and x+
i are the query and the positive example respectively.
{x+

j , j 6= i} are the negative examples.
Lifted Struct [20] is proposed by Song et al.

to learn
the embedding function by incorporating all negative ex-
amples. The objective of Lifted Struct is to pull one positive
pair (x+
j ) as close as possible and pushes all negative
data points corresponding to x+
j farther than a margin

i or x+

i , x+

5208

Figure 2: Illustration of different ranking-motivated structured losses. Different shapes (circle, triangle and square) represent
different classes. For simplicity, only 3 classes are shown. The blue circle is an anchor (query). In triplet [24], the anchor
is compared with only one negative example and one positive example. In N -pair-mc [28], Proxy-NCA [19] and Lifted
Struct [20], one positive example and multiple negative classes are incorporated. N -pair-mc randomly selects one example
per negative class. Proxy NCA pushes the anchor away from negative proxies instead of negative examples. The proxy is
class-level and can represent any instance in the corresponding class. Lifted Struct uses all examples from all negative classes.
On the contrary, our proposed ranked list loss not only exploits all negative examples, but also makes use of all positive ones.

α. Mathematically:

L(X; f ) =

1
2|P| X

(i,j)∈P

[{dij + log( X

exp(α − dik)

(i,k)∈N

+ X

(j,l)∈N

exp(α − djl))}]+

(3)
where P and N respectively represent the sets of posi-
tive pairs and negative pairs. Given the query xi, Lifted
Struct intends to identify one positive example from all cor-
responding negative data points.

Proxy-NCA [19] is proposed to address the sampling
problem using proxies. The proxy W is a small set of data
points that represent training classes in the original data.
The proxy for u is chosen by:

p(u) = argminw∈Wd(u, w),

(4)

p(u) denotes the closest point to u from W. The Proxy-
NCA loss is the traditional NCA loss deﬁned over proxies
instead of the original data points:

L(a, u, Z) = −log(

exp(−d(a, p(u))))

Pz∈Z exp(−d(a, p(z)))

),

(5)

where Z is the negative set, p(u) and p(z) are the prox-
ies of positive and negative points, respectively. a is the
anchor and d(·, ·) is the Euclidean distance between two
points. With static proxy assignment, i.e., one proxy per
class, the performance is much better than dynamic proxy
assignment. However, the proxies in the static proxy as-
signment are learned during training and similar to the class
vectors of the fully connected layer in classiﬁcation. There-
fore, Proxy-NCA does not preserve the scalability of DML
as the number of classes needs to be considered.

The proposed RLL is ranking-motivated structured loss,
which avoids two limitations of traditional methods by in-

corporating all non-trivial data points and exploring intrin-
sic structured information among them. The illustration and
comparison of different ranking-motivated losses and our
method is presented in Figure 2.

,

2.1.2 Clustering-Motivated Structured Losses

Struct Clust [29] is recently proposed to learn the embed-
ding function f by optimising the clustering quality metric.
The proposed structured loss function is deﬁned as:

L(X; f ) = [F (X, ˆy; f )+γ△(y, ˆy)) −F (X, y; f )]+, (6)

△(y, ˆy) = 1 − NMI(y, ˆy),

(7)

where ˆy and y are the predicted and ground-truth cluster-
ing assignments respectively. F measures the quality of the
clustering on X with the label assignment and distance met-
ric. NMI(y, ˆy) is the normalised mutual information [25].
NMI is 1 if the predicted clustering assignment is as good as
the ground-truth and 0 if it is the worst. ˆy is predicted based
on the learned distance metric f and Struct Clust [29] aims
to learn f such that the F of the ground-truth assignment is
larger than any other predicted clustering assignment.

However, this algorithm is NP-hard as we need to op-
timise both the clustering medoids and the distance met-
ric simultaneously. As a result, the loss augmented infer-
ence and reﬁnement are applied to select facilities (cluster-
ing medoids) based on the greedy algorithm [18]. Large
enough greedy search iterations are needed to ﬁnd a local
optimum, which might be costly.

Spectral Clust [16] also aims to optimise the quality of
the clustering. Spectral Clust relaxes the problem of clus-
tering with Bregman divergences [1] and computes the gra-
dient in a closed-form, which reduces the algorithmic com-
plexity of existing iterative methods, e.g., Struct Clust [29].
However, it is still non-trivial to learn deep models based

5209

on mini-batch implementation. Large batch size (1260 = 18
classes x 70 per class) is required for the clustering in the
mini-batch. As a result, Spectral Clust iteratively computes
submatrices and concatenates them into a single matrix for
computing the loss and gradient, which might be expensive.
Both ranking-motivated and clustering-motivated struc-
tured loss functions exploit the structured similarity infor-
mation among multiple data points. However, in general,
clustering-motivated losses are more difﬁcult to optimise
than ranking-motivated losses.

2.2. Mining Non trivial Examples

Example mining strategies are widely applied in existing
methods [24, 35, 27, 11, 41, 26, 3, 20, 28, 36] to provide
non-trivial examples for faster convergence and better per-
formance. In FaceNet [24], they propose to mine semi-hard
negative samples. In N -pair-mc [28], hard negative class
mining is proposed to provide informative negative exam-
In Lifted Struct [20], harder negative examples are
ples.
emphasized. In our work, we simply mine examples which
have non-zero losses.

3. Methodology

Our objective is to learn a discriminative function f
(a.k.a. deep metric) such that the similarity between pos-
itive pairs is higher than the similarity between negative
pairs in the feature space. There exist at least two images
in each class so that all classes can be evaluated. In this
case, given a query from any class, we aim to identify its
matching samples from all other examples.

3.1. Pairwise Constraint

Inspired by the former work on pairwise similarity con-
straint [6, 38], we aim to pull positive examples closer than
a predeﬁned threshold (boundary). In addition, we intend
to separate the positive and negative sets by a margin m. To
achieve this, we choose the pairwise margin loss [38] as our
basic pairwise constraint to construct the set-based similar-
ity structure.

Given an image xi, we aim to push its negative point far-
ther than a boundary α and pull its positive one closer than
another boundary α − m. Thus m is the margin between
two boundaries. Mathematically,

Lm(xi, xj; f ) = (1 − yij)[α − dij]+ + yij[dij − (α − m)]+,
(8)
where yij = 1 if yi = yj , and yij = 0 otherwise. dij =
||f (xi) − f (xj)||2 is the Euclidean distance between two
points.

3.2. Ranked List Loss

j |k 6= c}, |Nc,i| = Pk6=c Nk.

In each ranked list, there are Nc − 1
trated in Figure 1.
positive points in the positive set and Pk6=c Nk points in
the negative set. The positive set with respect to the query
xc
i is denoted as Pc,i = {xc
j|j 6= i}, |Pc,i| = Nc − 1. Sim-
ilarly, we represent the negative set with respect to xc
i as
Nc,i = {xk
Non-trivial Sample Mining. Mining informative exam-
ples is widely adopted [24, 41, 3, 20, 28, 36, 9] because
it allows fast convergence and good performance. By in-
formative examples, we mean non-trivial data points which
have non-zero losses, i.e., violating the pairwise constraint
with respect to the query. Since they have zero gradients,
including them for training will ‘weaken’ the contribution
of non-trivial examples during gradient fusion as the model
improves [9].

c,i = {xc

j |k 6= c, dij < α}.

We mine both non-trivial positive and negative exam-
i , the non-trivial positive set after min-
j|j 6= i, dij > (α − m)}.
c,i =

ples. For the query xc
ing is represented as P∗
Similarly, we denote the negative set after mining as N∗
{xk
Loss-based Negative Examples Weighting. With re-
spect to each query xc
i , there are a large number of non-
trivial negative examples (N∗
c,i) with different magnitude
of losses. To make better use of them, we propose to weight
the negative examples based on their loss values, i.e., how
much each negative pair violates the constraint. The weight-
ing strategy is formally represented as:

wij = exp(T · (α − dij)), xk

j ∈ N∗

c,i.

(9)

We notice that the gradient magnitude with respect to any
embedding is always one in Eq. (8). Mathematically,

||

∂Lm(xi, xj; f )

∂f (xj)

||2 = ||

f (xi) − f (xj)

||f (xi) − f (xj)||2

||2 = 1. (10)

Consequently, the gradient magnitude of any embedding is
only determined by our weighting strategy wij . In this case,
it is also convenient to evaluate its inﬂuence, which is stud-
In Eq. (9), T ≥ 0 is the temperature
ied in section 4.3.
parameter which controls the degree (slope) of weighting
negative examples. If T = 0, it treats all non-trivial nega-
tive examples equally. If T = +∞, it becomes the hardest
negative example mining.
Optimisation Objective. For each query xc
i , we propose to
make it closer to its positive set Pc,i than to its negative set
Nc,i by a margin m. At the same time, we force all negative
examples to be farther than a boundary α. Consequently, we
pull all samples from the same class into a hypersphere. The
diameter of each class hypershpere is α − m.

In order to pull all non-trivial positive points in P∗

c,i to-

gether and learn a class hypersphere, we minimise:

Given a query xc

i , we rank all other data points (gallery)
according to their similarities to the query, which is illus-

LP(xc

i ; f ) =

5210

1
|P∗

c,i| X

xc

j ∈P∗

c,i

Lm(xc

i , xc

j; f ).

(11)

Figure 3: The overall framework of our proposed ranked
list loss. For each input mini-batch, every image acts as a
query iteratively and obtains a list of other images ranked
by the similarity scores. For each ranked list, we mine non-
trivial data points and weight negative examples based on
their pairwise margin losses with respect to the query. At
last, the ranked list loss is computed for every query.

We do not weight positive points because there exist only
a few positive examples. Similarly, to push the non-trivial
negative points in N∗
c,i beyond the boundary α, we min-
imise:

LN(xc

i ; f ) = X
j ∈|N∗

xk

c,i|

wij

Pxk

j ∈|N∗

c,i| wij

Lm(xc

i , xk

j ; f ).

(12)
In RLL, we treat the two minimisation objectives equally

Algorithm 1 Ranked List Loss on one mini-batch

1: Mini-Batch Setting: The batch size N , the number of

classes C, the number of images per class Nc.

2: Parameters Setting: The distance constraint α on neg-
ative examples, the margin between positive and nega-
tive examples m, the weighting temperature T .

3: Input: X = {(xi, yi)}N

i }Nc
bedding function f , the learning rate β.

i=1 = {{xc

i=1}C

c=1, the em-

4: Output: Updated f .
5: Step 1: Feedforward all images {xi}N
tain the images’ embeddings {f (xi)}N

i=1 into f to ob-
i=1.

6: Step 2: Online iterative ranking and loss computation.

7:

8:

9:

10:

11:

12:

13:

14:

15:

foreach f (xc

i ) ∈ {{f (xc

i )}Nc

i=1}C

c=1 do
c,i.

Mine non-trivial positive set P∗
Mine non-trivial negative subsets N∗
Weight negative examples as Eq. (9).
Compute LP(xc
Compute LN(xc
Compute LRLL(xc

i ; f ) as Eq. (11):
i ; f ) as Eq. (12).

i ; f ) as Eq. (13).

c,i.

end for
Compute LRLL(X; f ) as Eq. (14).

and optimise them jointly:

16: Step 3: Gradient computation and backpropagation to

LRLL(xc

i ; f ) = LP(xc

i ; f ) + λLN(xc

i ; f ),

(13)

where λ controls the balance between positive and negative
sets. We ﬁx λ = 1 without tuning, which works well in
our practice. In the ranked list of xc
i , we regard the features
of other examples as constants. Therefore, only f (xc
i ) is
updated based on the inﬂuence of weighted combination of
other elements.

3.3. Learning Deep Models Based on RLL

To learn deep models, we implement our RLL based
on mini-batch and stochastic gradient descent. Each mini-
batch is a randomly sampled subset of the whole training
classes, which can be regarded as a simpliﬁed ranking prob-
lem with a smaller gallery (identifying the matching exam-
ples from a smaller number of classes).

Every image xc

i in the mini-batch acts as the query (an-
chor) iteratively and the other images serve as gallery. The
RLL of each mini-batch is represented as:

LRLL(X; f ) =

1
N X

∀c,∀i

LRLL(xc

i ; f ),

(14)

N is the batch size. The learning of the deep embedding
function f based on RLL is illustrated in Algorithm 1. The
overall pipeline is shown in Figure 3.
Computational Complexity. As illustrated in Algorithm 1,
our proposed method does not require the input data to be
prepared in any rigid format, e.g., triplets, n-pair tuplets. In-
stead, it takes random input images with multiclass labels.
We conduct online iterative ranking and loss computation

update the parameters of f .
∇f = ∂LRLL(X; f )/∂f
f = f − β · ∇f

17:

18:

(step 2 in Algorithm 1) after obtaining images’ embeddings
(step 1 in Algorithm 1). Therefore, the computational com-
plexity of RLL is O(N 2), which is the same as existing
ranking-motivated structured loss functions [20, 28, 19].

3.4. Implementation Details

In each mini-batch, we randomly sample C classes and
K images per class. We set C = 60, K = 3. Thus
N = 180, Nc = K = 3, ∀c.
In this case, there are 2
positive images and 177 negative images in the ranked list
corresponding to each query, which simulates the global
set-based similarity structure. More precisely, only a few
matching examples exist in a large gallery. We use the same
data preprocessing and augmentation as in [20]. Speciﬁ-
cally, the input images are ﬁrst resized to 256 × 256 and
then cropped at 227 × 227. During training, we use random
crop and random horizontal mirroring for data augmenta-
tion. For testing, we only use a single center crop without
mirroring. We set the embedding size to 512 on all datasets
following the setting in [16, 28]. As done in [29, 19], the
features are L2 normalised before computing their distance
during training and testing.

We use GoogLeNet V2 [12] as our backbone network
for fair comparison with [29, 19, 16]. In this net, there are
three fully connected layers used in different layers. We re-

5211

fer them based on their relative locations as follows: L for
low-level layer (inception-3c/output), M for mid-level layer
(inception-4e/output) and H for high-level layer (inception-
5b/output). Following [29, 19, 16], the pretrained model on
ImageNet [23] is used for initialisation in our experiments.
Three original 1000-neuron fully connected layers followed
by the softmax layer and cross-entropy loss are changed
to three 512-neuron fully connected layers followed by our
proposed ranked list loss. According to [20], the new layers
are randomly initialised and optimised with 10 times larger
learning rate than the others for faster convergence.

We use GoogLeNet V2 [12] (with batch normaliza-
tion) as our backbone network for fair comparison with
[29, 19, 16]. Following them, the pretrained model on Im-
ageNet [23] is used for initialisation in our experiments.
Three original 1000-neuron fully connected layers followed
by the softmax layer and cross-entropy loss are changed
to three 512-neuron fully connected layers followed by our
proposed ranked list loss. According to [20], the new layers
are randomly initialised and optimised with 10 times larger
learning rate than the others for faster convergence. Our
method is implemented in the Caffe deep learning frame-
work [13].

4. Experiments

4.1. Datasets and Settings

Datasets. We conduct experiments on three popular bench-
marks: (1) CUB-200-2011 [15] has 11,788 images of 200
bird species. 5,864 images of the ﬁrst 100 classes are used
for training and 5,924 images of the other 100 classes for
testing. (2) CARS196 [32] contains 16,185 images of 196
car models. We use the ﬁrst 98 classes (8,054 images) for
training and the remaining 98 classes (8,131 images) for
testing. (3) SOP [20] contains 120,053 images of 22,634
online products sold on eBay.com. 59,551 images of 11,318
categories and 60,502 images of 11,316 categories are used
for training and testing respectively. The train/test split and
evaluation protocol are the same as [20]. For CUB-200-
2011 and CARS196, our method is evaluated on the original
images (without using the bounding box information).
Metrics. Following the standard [20], we report the image
retrieval performance and the image clustering quality in
terms of Recall@K and NMI [25] respectively.
Training Settings. We run our experiments on a single
Tesla V100 GPU with 32 GB RAM. The standard stochastic
gradient descent (SGD) optimiser is used with a momentum
of 0.9, a weight decay rate of 1e−5. We set the base learning
rate to 1e−2 for CARS196 and SOP. Smaller base learning
rate 1e−3 is better for CUB as it overlaps a little with Im-
ageNet and contains fewer images [15, 34]. On CARS and
CUB, the training procedure converges at 10k iterations,
while 16k iterations for SOP. We set hyper-parameters em-

pirically as follows m = 0.4, T = 10, α = 1.2.

4.2. Comparison with the State of the art Methods

Competitors. We compared our method with the following
methods which are implemented and tested under the same
setting: Triplet Semihard, Lifted Struct, N-pair-mc, Struct
Clust, Spectral Clust, and Proxy NCA 1. The methods have
been described in Section 2 except for Triplet Semihard [24]
that mines semihard negative examples to improve the con-
ventional triplet loss.
Results. The comparison between our method and other
competitors on both small datasets (CUB-200-2011 and
CARS196) and large dataset (SOP) is presented in Table 1
and Table 2 respectively. As stated in Section 3.4, we have
three fully connected layers in GoogLeNet V2. We report
two sets of results. For fair comparison, we report the re-
sults of the high-level embedding, which is denoted as RLL-
H. In addition, we ﬁnd emperically that the multilevel em-
bedding (RLL-(L,M,H) in short) by concatenating the low-
level, mid-level and high-level embeddings can achieve bet-
ter performance. We have the following observations from
Table 1 and 2:

• Overall, our method outperforms all the compared
methods. This validates the effectiveness of our pro-
posed loss function.

• On the small datasets CARS196 and CUB-200-2011,
RLL-H achieves the state-of-the-art performance on
two tasks by single-level embedding. For example, on
CUB-2011-2011, the Recall@1 and NMI of RLL-H
are higher than previous state-of-the-art by 4.2% and
4.1%, respectively.

• On the large dataset SOP, RLL-H also outperforms
all the previous methods in the image retrieval task.
Speciﬁcally, the Recall@1 is higher than Proxy NCA
by 2.4%. However, our method slightly underper-
forms with comparison to Proxy NCA. Interestingly,
all methods perform similarly when this metric is used.
This may indicate that NMI is not a good metric for a
large-scale dataset.

• RLL-(L,M,H) works much better than RLL-H on ev-
ery dataset. This indicates that the multilevel embed-
ding is more discriminative than the single-level fea-
ture representation in our method.

Discussion. It is worth to mention that although the perfor-
mance of Proxy NCA is also good on CARS196 and SOP,

1 The methods in [7, 34, 31, 4, 17] using GoogLeNet V1 [30] and the
margin loss [38] using ResNet50 [8] are not reported. Also, we do not
compare with ensemble models [41, 21, 14, 39] since ours is single model.
Although HTL [5] also uses GoogLeNet V2, we do not benchmark it be-
cause it builds the global class-level hierarchical tree by using all original
classes as leaves and updates the tree after every epoch, thus being very
computationally expensive and unscalable.

5212

Table 1: Comparison with the state-of-the-art methods on CARS196, CUB-200-2011 in terms of Recall@K (%) and NMI
(%). All the compared methods use GoogLeNet V2 as the backbone architecture. For fair comparison, RLL-H denotes
single-level embedding, i.e., the high-level embedding. RLL-(L,M,H) denotes multilevel embedding by concatenating the
low-level, mid-level and high-level embeddings.

CARS196

CUB-200-2011

Triplet Semihard [24]
Lifted Struct [20]
N -pair-mc [28]
Struct Clust [29]
Spectral Clust [16]
Proxy NCA [19]
RLL-H
RLL-(L,M,H)

R@1 R@2 R@4 R@8 NMI R@1 R@2 R@4 R@8 NMI
55.4
51.5
56.5
53.0
53.9
57.2
59.2
58.1
59.2
73.1
59.5
73.2
74.0
63.6
66.1
82.1

63.8
65.7
66.8
70.6
82.2
82.4
83.6
89.3

73.5
76.0
77.8
80.3
89.0
86.4
90.1
93.7

82.4
84.3
86.4
87.8
93.0
88.7
94.1
96.7

53.4
56.9
57.8
59.0
64.3
64.9
65.4
71.8

42.6
43.6
45.4
48.2
53.2
49.2
57.4
61.3

66.4
68.6
69.5
71.8
76.7
67.9
79.2
82.7

77.2
79.6
79.5
81.9
85.3
72.4
86.9
89.4

55.0
56.6
58.4
61.4
66.1
61.9
69.7
72.7

Table 2: Comparison with the state-the-of-art methods on
SOP. The evaluation settings follow Table 1. The ‘–’ de-
notes the corresponding results are not reported in the orig-
inal paper.

SOP

Triplet Semihard [24]
Lifted Struct [20]
N-pair-mc [28]
Struct Clust [29]
Spectral Clust [16]
Proxy NCA [19]
RLL-H
RLL-(L,M,H)

82.4
80.8
83.2
83.7
83.7

R@1 R@10 R@100 NMI
89.5
66.7
88.7
62.5
66.4
89.4
89.5
67.0
89.4
67.6
90.6
73.7
76.1
89.7
79.8
90.4

91.9
91.9
93.0
93.2
93.3

89.1
91.3

95.4
96.3

–

–

Proxy NCA does not preserve the scalability of deep met-
ric learning as the number of classes needs to be consid-
ered. Proxy NCA learns one proxy per class, which also
requires more learning parameters. Our method not only
achieves better performance, but also preserves the scala-
bility of deep metric learning, as shown in Table 2.

4.3. Ablation study

4.3.1 Mining Non-trivial Examples

As presented in Section 3.2, for each query, RLL mines ex-
amples which violate the pairwise constraint with respect to
the query. Speciﬁcally, we mine negative examples whose
distance is smaller than α in Eq. (12). Simultaneously, we
mine positive examples whose distance is larger than α − m
in Eq. (11). As a result, a margin m is established between
negative and positive examples in each ranked list. Since
the sample mining range is determined by the constraint pa-
rameters α, m, we conduct experiments on the large dataset
SOP to analyse their inﬂuence.
Impact of α. To study the impact of α, we set the tempera-

ture T = 10 and the margin m = 0.4 in all experiments.
The results are presented in Table 3. We observe that a
proper negative constraint α is important for RLL to learn
discriminative embeddings. This is consistent with our in-
tuition as α controls how much the negative examples are
pushed away.
Impact of m. To see the impact of m, we ﬁx α = 1.2
and T = 10. The results of different margin values are
presented in Table 4. We have three important observations:

• When m > 0, RLL performs much better by around
3% than m = 0. It shows that the margin is important
for improving the generalisation capability of RLL.

• The margin-based RLL is insensitive to the margin
value. The performance difference is smaller than 1%
when m ranges from 0.2 to 1.2.

• When m = α = 1.2, there is no mining over positive

Table 3: The impact of α on the distance distribution of
negative examples. SOP is used. Recall@K (%) results are
reported. In all experiments, m = 0.4, T = 10.

m = 0.4, T = 10 R@1 R@10 R@100
α = 1.4
α = 1.2
α = 1.0

76.2
79.8
78.7

95.6
96.3
95.9

89.4
91.3
90.5

Table 4: The impact of the distance margin m between neg-
ative and positive examples. The Recall@K (%) results on
SOP are shown with α = 1.2, T = 10 in all experiments.

α = 1.2, T = 10 R@1 R@10 R@100
m = 0
m = 0.2
m = 0.4
m = 0.6
m = 1.2

95.7
96.3
96.3
96.0
95.8

76.1
79.0
79.8
79.2
79.1

89.8
91.2
91.3
90.6
90.5

5213

points (α − m = 0). In this case, RLL pulls positive
examples as close as possible, which has the same ef-
fect as conventional contrastive loss.

4.3.2 Weighting Negative Examples

In this section, we conduct experiments to evaluate the in-
ﬂuence of different temperatures T for weighting negative
examples in Eq. (9). We ﬁx m = 0.4 and α = 1.2 in all ex-
periments. The temperature parameter T (T > 0) controls
the slope of weighting. The results are presented in Table 5.
We ﬁnd:

• When T = 0, RLL treats all non-trivial negative ex-
amples equally, i.e., no weighting is applied. The
Recall@1 result is 78.8%, which is only 1% lower
than the best performance using proper weighting.
This demonstrates the superiority of RLL even with-
out weighting.

• RLL is insensitive to the setting of T . The performance
gap is around 1% when T ranges from 0 to 20.
In
addition, the performance drops when T is large. This
is because ‘very’ hard examples exist in the training
data (e.g., outliers) [24, 3].

Table 5: The results of different T on SOP in terms of
Recall@K (%). We ﬁx m = 0.4, α = 1.2 in all experi-
ments.

m = 0.4, α = 1.2 R@1 R@10 R@100
T = 0
T = 5
T = 10
T = 15
T = 20

96.1
96.2
96.3
96.0
95.7

78.8
79.1
79.8
79.3
78.6

90.7
91.0
91.3
90.9
90.5

4.3.3 Single-level versus Multilevel Embeddings

we conduct experiments on SOP. The results are reported in
Table 6. We observe that:

• All single-level embeddings perform worse than the

multilevel embedding by around 3%.

• The low-level embedding also performs very well in
contrast with mid-level and high-level embeddings.
The performance gap of different single-level embed-
dings is smaller than 1%. Note that the low-level
embedding can be used for fast inference, which is
essential for resource-constrained computational de-
vices, e.g., mobile phones.

4.3.4 The Impact of Batch Size

The batch size is usually important in deep metric learn-
ing.
It determines the size of problem we are going to
solve every iteration during training. As presented in Sec-
tion 3.3 and 3.4, the batch size decides the number of
negative classes in the gallery. We conduct experiments
on SOP to evaluate the inﬂuence of batch size in our ap-
proach. Speciﬁcally, we ﬁx the number of images per class
(∀c, N c = K = 3) and only change the number of classes
(C ∈ {40, 50, 55, 60, 65}) in each mini-batch. The results
are reported in Table 7. We can see that the batch size does
not play a crucial role in RLL. The performance gap is only
0.6% when C changes from 120 to 195.

Table 7: The results of different batch size on SOP.

Batch size
120 = 40 × 3
150 = 50 × 3
165 = 55 × 3
180 = 60 × 3
195 = 65 × 3

R@1 R@10 R@100
79.2
79.5
79.7
79.8
79.8

96.2
96.2
96.3
96.3
96.3

90.9
91.1
91.2
91.3
91.3

As demonstrated in Section 4.2, we ﬁnd that RLL performs
better using the multilevel embedding. To compare differ-
ent single-level embeddings with the multilevel embedding,

5. Conclusion

Table 6: Single-level embeddings versus multilevel embed-
ding on SOP in terms of Recall@K (%). L, M and H repre-
sent the low-level, mid-level and high-level embedding re-
spectively. (L,M,H) means the concatenation of low-level,
mid-level and high-level embeddings.

Embedding R@1 R@10 R@100
L
M
H
(L,M,H)

76.1
76.9
76.1
79.8

94.9
95.5
95.4
96.3

88.8
89.6
89.1
91.3

In this paper, the ranked list loss is proposed to ex-
ploit all informative data points in order to build a more
informative structure for learning discriminative embed-
dings, which is not considered in the previous ranking-
motivated losses. Given a query, RLL splits its positive
and negative sets and forces a margin between them.
In
addition, non-trivial samples mining and negative exam-
ples weighting are exploited to make better use of all in-
formative data points. The proposed RLL achieves state-
of-the-art performance on three popular benchmarks using
the single-level embedding. In addition, we ﬁnd that RLL
works better when using the multilevel embedding empiri-
cally.

5214

References

[1] A. Banerjee, S. Merugu, I. S. Dhillon, and J. Ghosh. Clus-
tering with bregman divergences. The Journal of Machine
Learning Research, pages 1705–1749, 2005. 3

[2] S. Chopra, R. Hadsell, and Y. LeCun. Learning a similarity
metric discriminatively, with application to face veriﬁcation.
In CVPR, 2005. 1

[3] Y. Cui, F. Zhou, Y. Lin, and S. Belongie. Fine-grained cate-
gorization and dataset bootstrapping using deep metric learn-
ing with humans in the loop. In CVPR, 2016. 1, 4, 8

[4] Y. Duan, W. Zheng, X. Lin, J. Lu, and J. Zhou. Deep adver-

sarial metric learning. In CVPR, 2018. 6

[5] W. Ge, W. Huang, D. Dong, and M. R. Scott. Deep metric

learning with hierarchical triplet loss. In ECCV, 2018. 6

[6] R. Hadsell, S. Chopra, and Y. LeCun. Dimensionality reduc-
tion by learning an invariant mapping. In CVPR, 2006. 1,
4

[7] B. Harwood, B. Kumar, G. Carneiro, I. Reid, T. Drummond,
et al. Smart mining for deep metric learning. In ICCV, 2017.
6

[8] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning

for image recognition. In CVPR, 2016. 6

[9] A. Hermans, L. Beyer, and B. Leibe.

loss for person re-identiﬁcation.

triplet
arXiv:1703.07737, 2017. 4

In defense of the
arXiv preprint

[10] J. R. Hershey, Z. Chen, J. Le Roux, and S. Watanabe. Deep
clustering: Discriminative embeddings for segmentation and
separation. In ICASSP, 2016. 1

[11] C. Huang, C. C. Loy, and X. Tang. Local similarity-aware

deep feature embedding. In NIPS, 2016. 4

[12] S. Ioffe and C. Szegedy. Batch normalization: Accelerating
deep network training by reducing internal covariate shift. In
ICML, 2015. 5, 6

[13] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-
shick, S. Guadarrama, and T. Darrell. Caffe: Convolutional
architecture for fast feature embedding. In ACMMM, 2014.
6

[14] W. Kim, B. Goyal, K. Chawla, J. Lee, and K. Kwon.
In

Attention-based ensemble for deep metric learning.
ECCV, 2018. 6

[15] J. Krause, M. Stark, J. Deng, and L. Fei-Fei. 3d object rep-
resentations for ﬁne-grained categorization. In ICCV Work-
shop, 2013. 2, 6

[16] M. T. Law, R. Urtasun, and R. S. Zemel. Deep spectral clus-

tering learning. In ICML, 2017. 1, 3, 5, 6, 7

[17] X. Lin, Y. Duan, Q. Dong, J. Lu, and J. Zhou. Deep varia-

tional metric learning. In ECCV, 2018. 6

[18] B. Mirzasoleiman, A. Badanidiyuru, A. Karbasi, J. Vondr´ak,

and A. Krause. Lazier than lazy greedy. In AAAI, 2015. 3

[19] Y. Movshovitz-Attias, A. Toshev, T. K. Leung, S. Ioffe, and
S. Singh. No fuss distance metric learning using proxies. In
ICCV, 2017. 1, 2, 3, 5, 6, 7

[20] H. Oh Song, Y. Xiang, S. Jegelka, and S. Savarese. Deep
metric learning via lifted structured feature embedding. In
CVPR, 2016. 1, 2, 3, 4, 5, 6, 7

[21] M. Opitz, G. Waltner, H. Possegger, and H. Bischof. Bier-
boosting independent embeddings robustly. In ICCV, 2017.
6

[22] Y. Prabhu and M. Varma. Fastxml: A fast, accurate and
In

stable tree-classiﬁer for extreme multi-label learning.
SIGKDD, 2014. 1

[23] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh,
S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,
et al.
Imagenet large scale visual recognition challenge.
International Journal of Computer Vision, pages 211–252,
2015. 6

[24] F. Schroff, D. Kalenichenko, and J. Philbin. Facenet: A uni-
ﬁed embedding for face recognition and clustering. In CVPR,
2015. 1, 2, 3, 4, 6, 7, 8

[25] H. Sch¨utze, C. D. Manning, and P. Raghavan. Introduction
to information retrieval. Cambridge University Press, 2008.
3, 6

[26] H. Shi, Y. Yang, X. Zhu, S. Liao, Z. Lei, W. Zheng, and S. Z.
Li. Embedding deep metric for person re-identiﬁcation: A
study against large variations. In ECCV, 2016. 4

[27] E. Simo-Serra, E. Trulls, L. Ferraz, I. Kokkinos, P. Fua, and
F. Moreno-Noguer. Discriminative learning of deep convo-
lutional feature point descriptors. In ICCV, 2015. 4

[28] K. Sohn.

Improved deep metric learning with multi-class

n-pair loss objective. In NIPS, 2016. 1, 2, 3, 4, 5, 7

[29] H. O. Song, S. Jegelka, V. Rathod, and K. Murphy. Deep
metric learning via facility location. In CVPR, 2017. 1, 2, 3,
5, 6, 7

[30] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR, 2015. 6

[31] E. Ustinova and V. Lempitsky. Learning deep embeddings

with histogram loss. In NIPS, 2016. 6

[32] C. Wah, S. Branson, P. Welinder, P. Perona, and S. Belongie.

The caltech-ucsd birds-200-2011 dataset. 2011. 2, 6

[33] J. Wang, Y. Song, T. Leung, C. Rosenberg, J. Wang,
J. Philbin, B. Chen, and Y. Wu. Learning ﬁne-grained im-
age similarity with deep ranking. In CVPR, 2014. 1

[34] J. Wang, F. Zhou, S. Wen, X. Liu, and Y. Lin. Deep metric

learning with angular loss. In ICCV, 2017. 6

[35] X. Wang and A. Gupta. Unsupervised learning of visual rep-

resentations using videos. In ICCV, 2015. 4

[36] X. Wang, Y. Hua, E. Kodirov, G. Hu, and N. M. Robertson.
Deep metric learning by online soft mining and class-aware
attention. In AAAI, 2019. 4

[37] K. Q. Weinberger, J. Blitzer, and L. K. Saul. Distance metric
learning for large margin nearest neighbor classiﬁcation. In
NIPS, 2006. 2

[38] C.-Y. Wu, R. Manmatha, A. J. Smola, and P. Kr¨ahenb¨uhl.
In ICCV,

Sampling matters in deep embedding learning.
2017. 4, 6

[39] H. Xuan, R. Souvenir, and R. Pless. Deep randomized en-

sembles for metric learning. In ECCV, 2018. 6

[40] I. E.-H. Yen, X. Huang, P. Ravikumar, K. Zhong, and
I. Dhillon. Pd-sparse: A primal and dual sparse approach
to extreme multiclass and multilabel classiﬁcation. In ICML,
2016. 1

5215

[41] Y. Yuan, K. Yang, and C. Zhang. Hard-aware deeply cas-

caded embedding. In ICCV, 2017. 4, 6

5216

