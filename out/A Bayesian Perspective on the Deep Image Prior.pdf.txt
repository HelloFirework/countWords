A Bayesian Perspective on the Deep Image Prior

Zezhou Cheng Matheus Gadelha

Subhransu Maji Daniel Sheldon

University of Massachusetts, Amherst

{zezhoucheng, mgadelha, smaji, sheldon}@cs.umass.edu

Abstract

The deep image prior [26] was recently introduced as a
prior for natural images. It represents images as the output
of a convolutional network with random inputs. For “in-
ference”, gradient descent is performed to adjust network
parameters to make the output match observations. This
approach yields good performance on a range of image re-
construction tasks. We show that the deep image prior is
asymptotically equivalent to a stationary Gaussian process
prior in the limit as the number of channels in each layer of
the network goes to inﬁnity, and derive the corresponding
kernel. This informs a Bayesian approach to inference. We
show that by conducting posterior inference using stochas-
tic gradient Langevin dynamics we avoid the need for early
stopping, which is a drawback of the current approach, and
improve results for denoising and impainting tasks. We il-
lustrate these intuitions on a number of 1D and 2D signal
reconstruction tasks.

1. Introduction

It is well known that deep convolutional networks trained
on large datasets provide a rich hierarchical representa-
tion of images. Surprisingly, several works have shown
that convolutional networks with random parameters can
also encode non-trivial image properties. For example,
second-order statistics of ﬁlter responses of random convo-
lutional networks are effective for style transfer and synthe-
sis tasks [27]. On small datasets, features extracted from
random convolutional networks can work just as well as
trained networks [24]. Along these lines, the “deep im-
age prior” proposed by Ulyanov et al. [26] showed that the
output of a suitably designed convolutional network on ran-
dom inputs tends to be smooth and induces a natural image
prior, so that the search over natural images can be replaced
by gradient descent to ﬁnd network parameters and inputs
to minimize a reconstruction error of the network output.

Code and supplementary materials are available at https://

people.cs.umass.edu/˜zezhoucheng/gp-dip

Remarkably, no prior training is needed and the method op-
erates by initializing the parameters randomly.

Our work provides a novel Bayesian view of the deep
image prior. We prove that a convolutional network with
random parameters operating on a stationary input, e.g.,
white noise, approaches a two-dimensional Gaussian pro-
cess (GP) with a stationary kernel in the limit as the num-
ber of channels in each layer goes to inﬁnity (Theorem 1).
While prior work [19, 31, 18, 3, 20] has investigated the
GP behavior of inﬁnitely wide networks and convolutional
networks, our work is the ﬁrst to analyze the spatial covari-
ance structure induced by a convolutional network on sta-
tionary inputs. We analytically derive the kernel as a func-
tion of the network architecture and input distribution by
characterizing the effects of convolutions, non-linearities,
up-sampling, down-sampling, and skip connections on the
spatial covariance. These insights could inform choices of
network architecture for designing 1D or 2D priors.

We then use a Bayesian perspective to address draw-
backs of current estimation techniques for the deep image
prior. Estimating parameters in a deep network from a sin-
gle image poses a huge risk of overﬁtting. In prior work
the authors relied on early stopping to avoid this. Bayesian
inference provides a principled way to avoid overﬁtting by
adding suitable priors over the parameters and then using
posterior distributions to quantify uncertainty. However,
posterior inference with deep networks is challenging. One
option is to compute the posterior of the limiting GP. For
small networks with enough channels, we show this closely
matches the deep image prior, but is computationally ex-
pensive. Instead, we conduct posterior sampling based on
stochastic gradient Langevin dynamics (SGLD) [28], which
is both theoretically well founded and computationally ef-
ﬁcient, since it is based on standard gradient descent. We
show that posterior sampling using SGLD avoids the need
for early stopping and performs better than vanilla gradient
descent on image denoising and inpainting tasks (see Fig-
ure 1). It also allows us to systematically compute variances
of estimates as a measure of uncertainty. We illustrate these
ideas on a number of 1D and 2D reconstruction tasks.

5443

(a) MSE vs. Iteration

(b) Final MSE vs. σ2

(c) Inferred mean

(d) Inferred variance

Figure 1. (Best viewed magniﬁed.) Denoising and inpainiting results with the deep image prior. (a) Mean Squared Error (MSE) of the
inferred image with respect to the noisy input image as a function of iteration for two different noise levels. SGD converges to zero MSE
resulting in overﬁtting while SGLD roughly converges to the noise level in the image. This is also illustrated in panel (b) where we plot
the MSE of SGD and SGLD as a function of the noise level σ2 after convergence. See Section 5.2.1 for implementation details. (c) An
inpainting result where parts of the image inside the blue boundaries are masked out and inferred using SGLD with the deep image prior.
(d) An estimate of the variance obtained from posterior samples visualized as a heat map. Notice that the missing regions near the top left
have lower variance as the area is uniform.

2. Related work

Image priors. Our work analyzes the deep image prior [26]
that represents an image as a convolutional network f with
parameters θ on input x. Given a noisy target y the de-
noised image is obtained by minimizing the reconstruction
error ky − f (x; θ)k over x and θ. The approach starts from
an initial value of x and θ drawn i.i.d. from a zero mean
Gaussian distribution and optimizes the objective through
gradient descent, relying on early stopping to avoid overﬁt-
ting (see Figure 1). Their approach showed that the prior is
competitive with state-of-the-art learning-free approaches,
such as BM3D [6], for image denoising, super resolution,
and inpainting tasks. The prior encodes hierarchical self-
similarities that dictionary-based approaches [21] and non-
local techniques such as BM3D and non-local means [4] ex-
ploit. The architecture of the network plays a crucial role:
several layer networks were used for inpainting tasks, while
those with skip connections were used for denoising. Our
work shows that these networks induce priors that corre-
spond to different smoothing “scales”.

Gaussian processes (GPs). A Gaussian processes is an in-
ﬁnite collection of random variables for which any ﬁnite
subset are jointly Gaussian distributed [23]. A GP is com-
monly viewed as a prior over functions. Let T be an in-
dex set (e.g., T = R or T = Rd) and let µ(t) be a real-
valued mean function and K(t, t′) be a non-negative deﬁ-
nite kernel or covariance function on T . If f ∼ GP (µ, K),
then, for any ﬁnite number of indices t1, . . . , tn ∈ T , the
vector (f (ti))n
i=1 is Gaussian distributed with mean vec-
tor (µ(ti))n
i,j=1. GPs
have a long history in spatial statistics and geostatistics [17].
In ML, interest in GPs was motivated by their connec-
tions to neural networks (see below). GPs can be used
for general-purpose Bayesian regression [31, 22], classiﬁ-
cation [30], and many other applications [23].

i=1 and covariance matrix (K(ti, tj))n

Deep networks and GPs. Neal [19] showed that a two-
layer network converges to a Gaussian process as its width

goes to inﬁnity. Williams [29] provided expressions for the
covariance function of networks with sigmoid and Gaussian
transfer functions. Cho and Saul [5] presented kernels for
the ReLU and the Heaviside step non-linearities and inves-
tigated their effectiveness with kernel machines. Recently,
several works [13, 18] have extended these results to deep
networks and derived covariance functions for the resulting
GPs. Similar analyses have also been applied to convolu-
tional networks. Garriaga-Alonso et al. [9] investigated the
GP behavior of convolutional networks with residual lay-
ers, while Borovykh [3] analyzed the covariance functions
in the limit when the ﬁlter width goes to inﬁnity. Novak et
al. [20] evaluated the effect of pooling layers in the result-
ing GP. Much of this work has been applied to prediction
tasks, where given a dataset D = {(xi, yi)}n
i=1, a covari-
ance function induced by a deep network is used to esti-
mate the posterior p(y|x,D) using standard GP machinery.
In contrast, we view a convolutional network as a spatial
random process over the image coordinate space and study
the induced covariance structure.

Bayesian inference with deep networks.
It has long
been recognized that Bayesian learning of neural networks
weights would be desirable [15, 19], e.g., to prevent overﬁt-
ting and quantify uncertainty. Indeed, this was a motivation
in the original work connecting neural networks and GPs.
Performing MAP estimation with respect to a prior on the
weights is computationally straightforward and corresponds
to regularization. However, the computational challenges
of full posterior inference are signiﬁcant. Early works used
MCMC [19] or the Laplace approximation [7, 15] but were
much slower than basic learning by backpropagation. Sev-
eral variational inference (VI) approaches have been pro-
posed over the years [12, 1, 10, 2]. Recently, dropout
was shown to be a form of approximate Bayesian infer-
ence [8]. The approach we will use is based on stochas-
tic gradient Langevin dynamics (SGLD) [28], a general-
purpose method to convert SGD into an MCMC sampler
by adding noise to the iterates. Li et al. [14] describe a pre-

5444

101102103104105Iteration (log scale)0.000.010.020.030.040.05MSESGD, 2=0SGLD, 2=0SGD, 2=0.01SGLD, 2=0.010.0000.0050.01020.0000.0020.0040.0060.008MSESGLDSGDconditioned SGLD method for deep networks.

the covariance. This is given by

Kz(t1, t2) = E[z(t1)z(t2)]

3. Limiting GP for Convolutional Networks

Previous work focused on the covariance of (scalar-
valued) network outputs for two different inputs (i.e., im-
ages). For the deep image prior, we are interested in the
spatial covariance structure within each layer of a convo-
lutional network. As a basic building block, we consider
a multi-channel input image X transformed through a con-
volutional layer, an elementwise non-linearity, and then a
second convolution to yield a new multi-channel “image”
Z, and derive the limiting distribution of a representative
channel z as the number of input channels and ﬁlters go to
inﬁnity. First, we derive the limiting distribution when X
is ﬁxed, which mimics derivations from previous work. We
then let X be a stationary random process, and show how
the spatial covariance structure propagates to z, which is our
main result. We then apply this argument inductively to an-
alyze multi-layer networks, and also analyze other network
operations such as upsampling, downsampling, etc.

3.1. Limiting Distribution for Fixed X

For simplicity, consider an image X ∈ Rc×T with c

channels and only one spatial dimension. The derivations
are essentially identical for two or more spatial dimensions.
The ﬁrst layer of the network has H ﬁlters denoted by
U = (u1, u2, . . . uH ) where uk ∈ Rc×d and the second
layer has one ﬁlter v ∈ RH (corresponding to a single chan-

nel of the output of this layer). The output of this network
is:

H

z = v ∗ h(X ∗ U ) =

vkh(X ∗ uk).

Xk=1

The output z = (z(1), z(2), . . . , z(T ′)) also has one spatial
dimension. Following [19, 29] we derive the distribution of

v2

= Hσ2
v

= E" H
kh(cid:0)(X ∗ uk)(t1)(cid:1)h(cid:0)(X ∗ uk)(t2)(cid:1)#
Xk=1
E(cid:2)h(cid:0)(X ∗ u1)(t1)(cid:1)h(cid:0)(X ∗ u1)(t2)(cid:1)(cid:3) .
The last two steps follow from the independence of u and
v and that v is drawn from a zero mean Gaussian. Let
¯x(t) = vec ([X(:, t), X(:, t − 1), . . . , X(:, t − d + 1)]) be
the ﬂattened tensor with elements within the window of size
d at position t of X. Similarly denote ¯u = vec(u). Then
the expectation can be written as

Kz(t1, t2) = Hσ2

vEu(cid:2)h(¯x(t1)T ¯u)h(¯x(t2)T ¯u)(cid:3) .

be computed analytically for various transfer functions. For

Williams [29] showed V (x, y) = Eu(cid:2)h(xT u)h(yT u)(cid:3) can
example, when h(x) = erf(x) = 2/√πR x

0 e−s2

ds, then

xT Σy

Verf (x, y) =

sin−1

.

(2)

(1)

2
π

Here Σ = σ2I is the covariance of u. Williams also de-
rived kernels for the Gaussian transfer function h(x, u) =
exp{−(x− u)T (x− u)/2σ2}. For the ReLU non-linearity,
i.e., h(t) = max(0, t), Cho and Saul [5] derived the expec-
tation as:

1

(3)

Vrelu(x, y) =

where θ = cos−1(cid:16) xT y

2πkxkkyk(cid:0) sin θ + (π − θ) cos θ(cid:1),
kxkkyk(cid:17). We refer the reader to [5, 29]
for expressions corresponding to other transfer functions.
v scale as 1/H and H → ∞ and for any
input X, the output z of our basic convolution-nonlinearity-
convolution building block converges to a Gaussian distri-
bution with zero mean and covariance

Thus, letting σ2

Kz(t1, t2) = V (¯x(t1), ¯x(t2)) .

(4)

p(xT Σx) (yT Σy)

I). The mean is

3.2. Limiting Distribution for Stationary X

v

u

z when U ∼ N (0, σ2
E[z(t)] = E" H
Xk=1
= E
Xk=1


I) and v ∼ N (0, σ2
vkh ((X ∗ uk)(t))#
vkh


Xi=1,j=1

c,d

H

x(i, t + 1 − j)uk(i, j)



 .

By linearity of expectation and independence of u and v,

H

Xk=1

E[z(t)] =

E[vk]E [h ((X ∗ uk)(t))] = 0,

since v has a mean of zero. The central limit theorem (CLT)
can be applied when h is bounded to show that z(t) ap-
proaches in distribution to a Gaussian as H → ∞ and σ2
v is
scaled as 1/H. Note that u and v don’t need to be Gaussian
for the CLT to apply, but we will use this property to derive

We now consider the case when channels of X are drawn
i.i.d. from a stationary distribution. A signal x is stationary
(in the weak- or wide-sense) if the mean is position invariant
and the covariance is shift invariant, i.e.,

mx = E[x(t)] = E[x(t + τ )], ∀τ

and

Kx(t1, t2) = E[(x(t1) − mx)(x(t2) − mx)]

= Kx(t1 − t2),∀t1, t2.

An example of a stationary distribution is white noise
where x(i) is i.i.d.
from a zero mean Gaussian distribu-
tion N (0, σ2) resulting in a mean mx = 0 and covariance
Kx(t1, t2) = σ21[t1 = t2]. Note that the input for the deep
image prior is drawn from this distribution.

(5)

(6)

5445

Theorem 1. Let each channel of X be drawn independently
from a zero mean stationary distribution with covariance
function Kx. Then the output of a two-layer convolutional
network with the sigmoid non-linearity, i.e., h(t) = erf(t),
converges to a zero mean stationary Gaussian process as
the number of input channels c and ﬁlters H go to inﬁnity
sequentially. The stationary covariance Kz is given by

K erf

z (t1, t2) = Kz(r) =

2
π

sin−1 Kx(r)
Kx(0)

.

where r = t2 − t1.

The full proof is included in the supplementary mate-
rial and is obtained by applying the continious mapping
thorem [16] on the formula for the sigmoid non-linearity.
The theorem implies that the limiting distribution of Z is a
stationary GP if the input X is stationary.

Lemma 1. Assume the same conditions as Theorem 1 ex-
cept the non-linearity is replaced by ReLU. Then the output
converges to a zero mean stationary Gaussian process with
covariance Kz

K relu

z

(t1, t2) =

Kx(0)

2π (cid:16) sin θx

t1,t2 +(π−θx

t1,t2 ) cos θx

t1,t2(cid:17),

(7)
t1,t2 = cos−1 (Kx(t1, t2)/Kx(0)). In terms of the

where θx
angles we get the following:

cos θz

t1,t2 =

t1,t2 + (π − θx

t1,t2 ) cos θx

1

π(cid:16) sin θx

t1,t2(cid:17).

This can be proved by applying the recursive formula for
ReLU non-linearity [5]. One interesting observation is that,
for both non-linearities, the output covariance Kz(r) at a
given offset r only depends on the input covariance Kx(r)
at the same offset, and on Kx(0).
Two or more dimensions. The results of this section hold
without modiﬁcation and essentially the same proofs for in-
puts with c channels and two or more spatial dimensions by
letting t1, t2, and r = t2 − t1 be vectors of indices.
3.3. Beyond Two Layers

So far we have shown that the output of our basic two-
layer building block converges to a zero mean stationary
Gaussian process as c → ∞ and then H → ∞. Below we
discuss the effect of adding more layers to the network.

Convolutional layers. A proof of GP convergence for deep
networks was presented in [18], including the case for trans-
fer functions that can be bounded by a linear envelope, such
as ReLU. In the convolutional setting, this implies that the
output converges to GP as the number of ﬁlters in each
layer simultaneously goes to inﬁnity. The covariance func-
tion can be obtained by recursively applying Theorem 1 and
Lemma 1; stationarity is preserved at each layer.

Bias term. Our analysis holds when a bias term b sampled
from a zero-mean Gaussian is added, i.e., zbias = z + b. In

this case the GP is still zero-mean but the covariance func-
tion becomes: K bias
b + Kz(t1, t2), which is
still stationary.

(t1, t2) = σ2

z

Upsampling and downsampling layers. Convolutional
networks have upsampling and downsampling layers to in-
duce hierarchical representations.
It is easy to see that
downsampling (decimating) the signal preserves stationar-
ity since K ↓
x(t1, t2) = Kx(τ t1, τ t2) where τ is the down-
sampling factor. Downsampling by average pooling also
preserves stationarity. The resulting kernel can be obtained
by applying a uniform ﬁlter corresponding to the size of the
pooling window, which results in a stationary signal, fol-
lowed by downsampling. However, upsampling in general
does not preserve stationarity. Therrien [25] describes the
conditions under which upsampling a signal with a linear
ﬁlter maintains stationarity. In particular, the upsampling
ﬁlter must be band limited, such as the sinc ﬁlter: sinc(x) =
sin(x)/x. If stationarity is preserved the covariance in the
next layer is given by K ↑

x(t1, t2) = Kx(t1/τ, t2/τ ).

Skip connections. Modern convolutional networks have
skip connections where outputs from two layers are added
Z = X +Y or concatenated Z = [X; Y ]. In both cases if X
and Y are stationary GPs so is Z. See [9] for a discussion.

4. Bayesian Inference for Deep Image Prior

Let’s revisit the deep image prior for a denoising task.

Given an noisy image ˆy the deep image prior solves

θ,x ||ˆy − f (x, θ)||2
2,
min

where x is the input and θ are the parameters of an appro-
priately chosen convolutional network. Both x and θ are
initialized randomly from a prior distribution. Optimization
is performed using stochastic gradient descent (SGD) over
x and θ (optionally x is kept ﬁxed) and relying on early
stopping to avoid overﬁtting (see Figures 1 and 2). The de-
noised image is obtained as y∗ = f (x∗, θ∗).

The inference procedure can be interpreted as a max-
imum likelihood estimate (MLE) under a Gaussian noise
model: ˆy = y+ǫ, where ǫ = N (0, σ2
I). Bayesian inference
n
suggests we add a suitable prior p(x, θ) over the parameters
and reconstruct the image by integrating the posterior, to

get y∗ = R p(x, θ | ˆy)f (x, θ)dxdθ, The obvious compu-

tational challenge is computing this posterior average. An
intermediate option is maximum a posteriori (MAP) infer-
ence where the argmax of the posterior is used. However
both MLE and MAP do not capture parameter uncertainty
and can overﬁt to the data.

In standard MCMC the integral is replaced by a sam-
ple average of a Markov chain that converges to the true
posterior. However convergence with MCMC techniques is
generally slower than backpropagation for deep networks.
Stochastic gradient Langevin dyanamics (SGLD) [28] pro-

5446

or downsampling. We use ReLU non-linearity after each
conv layer in both cases. We also vary the input covariance
Kx. Each channel of X is ﬁrst sampled iid from a zero-
mean Gaussian with a variance σ2. A simple way to obtain
inputs with a spatial covariance Kx equal to a Gaussian with
standard deviation σ is to then spatially ﬁlter channels of X
with a Gaussian ﬁlter with standard deviation √2σ.

Figure 3 shows the covariance function cos θt1,t2 =
Kz(t1 − t2)/Kz(0), induced by varying the σ and depth d
of the two architectures (Figure 3a-b). We empirically esti-
mated the covariance function by sampling many networks
and inputs from the prior distribution. The covariance func-
tion for the convolutional-only architecture is also calcu-
lated using the recursion in Equation 7. For both architec-
tures increasing σ and d introduce longer-range spatial co-
variances. For the auto-encoder upsampling induces longer-
range interactions even when σ is zero shedding some light
on the role of upsampling in the deep image prior. Our net-
work architectures have 128 ﬁlters, even so, the match be-
tween the empirical covariance and the analytic one is quite
good as seen in Figure 3(b).

Figure 3(c) shows samples drawn from the prior of the
convolutional-only architecture.
Figure 3(d) shows the
posterior mean and variance with SGLD inference where
we randomly dropped 90% of the data from a 1D signal.
Changing the covariance inﬂuences the mean and variance
which is qualitatively similar to choosing the scale of sta-
tionary kernel in the GP: larger scales (bigger input σ or
depth) lead to smoother interpolations.

5.2. Natural images

Throughout our experiments we adopt the network archi-
tecture reported in [26] for image denoising and inpainting
tasks for a direct comparison with their results. These ar-
chitectures are 5-layer auto-encoders with skip-connections
and each layer contains 128 channels. We consider images
from the standard image reconstruction datasets [6, 11]. For
inference we use a learning rate of 0.01 for image denoising
and 0.001 for image inpainting. We compare the following
inference schemes:

1. SGD+Early: Vanilla SGD with early stopping.

2. SGD+Early+Avg: Averaging the predictions with ex-

ponential sliding window of the vanilla SGD.

3. SGD+Input+Early: Perturbing the input x with an
additive Gaussian noise with mean zero and standard
deviation σp at each learning step of SGD.

4. SGD+Input+Early+Avg: Averaging the predictions

of the earlier approach with a exponential window.

5. SGLD: Averaging after burn-in iterations of posterior

samples with SGLD inference.

5447

Figure 2. The PSNR curve for different learning methods on the
“peppers” image of Figure 1. The SGD and its variants use early
stopping to avoid overﬁtting. MAP inference by adding a prior
term (WD: weight decay) shown as the black curve doesn’t avoid
overﬁtting. Moving averages (dashed lines) and adding noise to
the input improves performance. By contrast, samples from SGLD
after “burn-in” remains stable and the posterior mean improves
over the highest PSNR of the other approaches.

vides a general framework to derive an MCMC sampler
from SGD by injecting Gaussian noise to the gradient up-
dates. Let w = (x, θ). The SGLD update is:

ǫ

∆w =

2(cid:16)∇w log p(ˆy | w) + ∇w log p(w)(cid:17) + ηt

ηt ∼ N (0, ǫ).
P ǫt = ∞ and P ǫ2

where ǫ is the step size. Under suitable conditions, e.g.,
t < ∞ and others, it can be shown
that w1, w2, . . . converges to the posterior distribution. The
log-prior term is implemented as weight decay.

(8)

Our strategy for posterior inference with the deep image
prior thus adds Gaussian noise to the gradients at each step
to estimate the posterior sample averages after a “burn in”
phase. As seen in Figure 1(a), due to the Gaussian noise
in the gradients, the MSE with respect to the noisy image
does not go to zero, and converges to a value that is close
to the noise level as seen in Figure 1(b). It is also important
to note that MAP inference alone doesn’t avoid overﬁtting.
Figure 2 shows a version where weight decay is used to reg-
ularize parameters, which also overﬁts to the noise. Further
experiments with inference procedures for denoising are de-
scribed in Section 5.2.

5. Experiments

5.1. Toy examples

We ﬁrst study the effect of the architecture and input dis-
tribution on the covariance function of the stationary GP
using 1D convolutional networks. We consider two archi-
tectures: (1) AutoEncoder: where d conv + downsampling
blocks are followed by d conv + upsampling blocks, and (2)
Conv: where convolutional blocks without any upsampling

05K10K15K20KIteration202224262830PSNR (dB)SGDSGD+AvgSGD+WDSGD+InputSGD+Input+AvgSGLDSGLD Avg w.r.t. ItersSGLD Avg(a) cos θt1,t2 (AE)

(b) cos θt1,t2 (Conv)

(c) Prior

(d) Posterior

Figure 3. Priors and posterior with 1D convolutional networks. The covariance function cos θt1 ,t2 = K(t1 − t2)/K(0) for the (a)
AutoEncoder and (b) Conv architectures estimated empirically for different values of depth and input covariance. For the Conv architecture
we also compute the covariance function analytically using recursion in Equation 7 shown as dashed lines in panel (b). The empirical
estimates were obtained with networks with 256 ﬁlters. The agreement is quite good for small values of sigma. For larger offsets the
convergence towards a Gaussian is approximate. Panel (c) shows samples from the prior of the Conv architecture with two different
conﬁgurations, and panel (d) shows the posterior means and variances estimated using SGLD.

We manually set the stopping iteration in the ﬁrst four
schemes to one with essentially the best reconstruction error
— note that this is an oracle scheme and cannot be imple-
mented in real reconstruction settings. For image denois-
ing task, the stopping iteration is set as 500 for the ﬁrst two
schemes, and 1800 for the third and fourth methods. For im-
age inpainting task, this parameter is set as 5000 and 11000
respectively.

The third and fourth variants were described in the sup-
plementary material of [26] and in the released codebase.
We found that injecting noise to the input during inference
consistently improves results. However, as observed in [26],
regardless of the noise variance σp, the network is able to
drive the objective to zero, i.e., it overﬁts to the noise. This
is also illustrated in Figure 1 (a-b).

Since the input x can be considered as part of the pa-
rameters, adding noise to the input during inference can be
thought of as approximate SGLD. It is also not beneﬁcial
to optimize x in the objective and is kept constant (though
adding noise still helps). SGLD inference includes adding
noise to all parameters, x and θ, sampled from a Gaus-
sian distribution with variance scaled as the learning rate
η, as described in Equation 4. We used 7K burn-in itera-
tions and 20K training iterations for image denoising task,
20K and 30K for image inpainting tasks. Running SGLD
longer doesn’t improve results further. The weight-decay
hyper-parameter for SGLD is set inversely proportional to
the number of pixels in the image and equal to 5e-8 for a
1024×1024 image. For the baseline methods, we did not
use weight decay, which, as seen in Figure 2, doesn’t inﬂu-
ence results for SGD.

5.2.1

Image denoising

We ﬁrst consider the image denoising task using various in-
ference schemes. Each method is evaluated on a standard
dataset for image denoising [6], which consists of 9 colored
images corrupted with noise of σ = 25 .

Figure 2 presents the peak signal-to-noise ratio (PSNR)
values with respect to the clean image over the optimiza-
tion iterations. This experiment is on the “peppers” image
from the dataset as seen in Figure 1. The performance of
SGD variants (red, black and yellow curves) reaches a peak
but gradually degrades. By contrast, samples using SGLD
(blue curves) are stable with respect to PSNR, alleviating
the need for early stopping. SGD variants beneﬁt from ex-
ponential window averaging (dashed red and yellow lines),
which also eventually overﬁts. Taking the posterior mean
after burn in with SGLD (dashed blue line) consistently
achieves better performance. The posterior mean at 20K
iteration (dashed blue line with markers) achieves the best
performance among the various inference methods.

Figure 4 shows a qualitative comparison of SGD with
early stopping to the posterior mean of SGLD, which con-
tains fewer artifacts. More examples are available in the
supplementary material. Table 1 shows the quantitative
comparisons between the SGLD and the baselines. We
run each method 10 times and report the mean and stan-
dard deviations. SGD consistently beneﬁts from perturbing
the input signal with noise-based regularization, and from
moving averaging. However, as noted, these methods still
have to rely on early stopping, which is hard to set in prac-
tice. By contrast, SGLD outperforms the baseline methods
across all images. Our reported numbers (SGD + Input +

5448

1000100t1t2  (d=3)0.900.951.00cost1,t2=0=20=60=1201000100t1t2  (d=4)0.700.851.00cost1,t2=0=10=15=60050100input, x0.40.20.00.20.4output, f(x) = 2, d = 1050100input, x1.00.50.00.51.0output, f(x)=2, d=11000100t1t2  (=0)0.960.970.980.991.00cost1,t2d=3d=4d=5d=61000100t1t2  (=2)0.30.60.9cost1,t2d=1d=2d=3d=4050100input, x0.40.20.00.20.4output, f(x) = 15, d = 4050100input, x1.00.50.00.51.0output, f(x)=15, d=4Input

SGD (28.38)

SGLD (30.82)

Figure 4. Image denoising results. Denoising the input noisy im-
age with SGD and SGLD inference.

Early + Avg) are similar to the single-run results reported in
prior work (30.44 PSNR compared to ours of 30.33±0.03
PSNR.) SGLD improves the average PNSR to 30.81. As a
reference, BM3D [6] obtains an average PSNR of 31.68.

5.2.2

Image inpainting

For image inpainting we experiment on the same task
as [26] where 50% of the pixels are randomly dropped. We
evaluate various inference schemes on the standard image
inpainting dataset [11] consisting of 11 grayscale images.

Table 2 presents a comparison between SGLD and the
baseline methods. Similar to the image denoising task, the
performance of SGD is improved by perturbing the input
signal and additionally by averaging the intermediate sam-
ples during optimization. SGLD inference provides addi-
tional improvements; it outperforms the baselines and im-
proves over the results reported in [26] from 33.48 to 34.51
PSNR. Figure 5 shows qualitative comparisons between
SGLD and SGD. The posterior mean of SGLD has fewer
artifacts than the best result generated by SGD variants.

Besides gains in performance, SGLD provides estimates
of uncertainty. This is visualized in Figure 1(d). Ob-
serve that uncertainty is low in missing regions that are sur-
rounded by areas of relatively uniform appearance such as
the window and ﬂoor, and higher in non-uniform areas such
as those near the boundaries of different object in the image.

5.3. Equivalence between GP and DIP

We compare the deep image prior (DIP) and its Gaussian
process (GP) counterpart, both as prior and for posterior in-
ference, and as a function of the number of ﬁlters in the
network. For efﬁciency we used a U-Net architecture with
two downsampling and upsampling layers for the DIP.

(a) DIP prior samples

(b) GP prior samples

The above ﬁgure shows two samples each drawn from
the DIP (with 256 channels per layer) and GP with the
equivalent kernel. The samples are nearly identical sug-
gesting that the characterization of the DIP as a stationary
GP also holds for 2D signals. Next, we compare the DIP

and GP on an inpainting task shown in Figure 6. The im-
age size here is 64×64. Figure 6 top (a) shows the RBF
and DIP kernels as a function of the offset. The DIP kernels
are heavy tailed in comparison to Gaussian with support at
larger length scales. Figure 6 bottom (a) shows the per-
formance (PSNR) of the DIP as a function of the number
of channels from 16 to 512 in each layer of the U-Net, as
well as of a GP with the limiting DIP kernel. The PSNR of
the DIP approaches the GP as the number of channels in-
creases suggesting that for networks of this size 256 ﬁlters
are enough for the asymptotic GP behavior. Figure 6 (d-e)
show that a GP with the DIP kernel is more effective than
one with the RBF kernel, suggesting that the long-tail DIP
kernel is better suited for modeling natural images.

While DIPs are asymptotically GPs, the SGD optimiza-
tion may be preferable because GP inference is expensive
for high-resolution images. The memory usage is O(n2)
and running time is O(n3) for exact inference where n is
the number of pixels (e.g., a 500×500 image requires 233
GB memory). The DIP’s memory footprint, on the other
hand, scales linearly with the number of pixels, and infer-
ence with SGD is practical and efﬁcient. This emphasizes
the importance of SGLD, which addresses the drawbacks
of vanilla SGD and makes the DIP more robust and effec-
tive. Finally, while we showed that the prior distribution
induced by the DIP is asymptotically a GP and the posterior
estimated by SGD or SGLD matches the GP posterior for
small networks, it remains an open question if the posterior
matches the GP posterior for deeper networks.

6. Conclusion

We presented a novel Bayesian view of the deep image
prior, which parameterizes a natural image as the output of
a convolutional network with random parameters and a ran-
dom input. First, we showed that the output of a random
convolutional network converges to a stationary zero-mean
GP as the number of channels in each layer goes to inﬁn-
ity, and showed how to calculate the realized covariance.
This characterized the deep image prior as approximately
a stationary GP. Our work differs from prior work relating
GPs and neural networks by analyzing the spatial covari-
ance of network activations on a single input image. We
then use SGLD to conduct fully Bayesian posterior infer-
ence in the deep image prior, which improves performance
and prevents the need for early stopping. Future work can
further investigate the types of kernel implied by convolu-
tional networks to better understand the deep image prior
and the inductive bias of deep convolutional networks in
learning applications.

Acknowledgement This research was supported in part
by NSF grants #1749833, #1749854, and #1661259, and
the MassTech Collaborative for funding the UMass GPU
cluster.

5449

Table 1. Image denoising task. Comparison of various inference schemes with the deep image prior for image denoising (σ=25). Bayesian
inference with SGLD avoids the need for early stopping while consistently improves results. Details are described in Section 5.2.1.

House Peppers Lena Baboon

F16 Kodak1 Kodak2 Kodak3 Kodak12 Average

SGD + Early 26.74
±0.41
SGD + Early + Avg 28.78
±0.35
SGD + Input + Early 28.18
±0.32
SGD + Input + Early + Avg 30.61
±0.3
SGLD 30.86
±0.61
CMB3D [6] 33.03

28.42
±0.22
29.20
±0.08
29.21
±0.11
30.46
±0.03
30.82
±0.01
31.20

29.17
±0.25
30.26
±0.12
30.17
±0.07
31.81
±0.03
32.05
±0.03
32.27

23.50
±0.27
23.82
±0.11
22.65
±0.08
23.69
±0.09
24.54
±0.04
25.95

29.76
±0.49
31.17
±0.1
30.57
±0.09
32.66
±0.06
32.90
±0.08
32.78

26.61
±0.19
27.14
±0.07
26.22
±0.14
27.32
±0.06
27.96
±0.06
29.13

28.68
±0.18
29.88
±0.12
30.29
±0.13
31.70
±0.03
32.05
±0.05
32.44

30.07
±0.33
31.00
±0.11
31.31
±0.08
32.86
±0.08
33.29
±0.17
34.54

29.78
±0.17
30.64
±0.12
30.66
±0.12
31.87
±0.1
32.79
±0.06
33.76

28.08
±0.09
29.10
±0.05
28.81
±0.04
30.33
±0.03
30.81
±0.08
31.68

Table 2. Image inpainting task. Comparison of various inference schemes with the deep image prior for image inpainting. SGLD
estimates are more accurate while also providing a sensible estimate of the variance. Details are described in Section 5.2.2.

Method Barbara Boat House Lena Peppers C.man Couple Finger Hill Man Montage Average

±0.7

±0.99

±0.28 ±0.46 ±0.18

±0.23 ±0.45 ±0.25

SGD + Early 28.48 31.54 35.34 35.00 30.40
±0.59
SGD + Early + Avg 28.71 31.64 35.45 35.15 30.48
±0.6
SGD + Input + Early 32.48 32.71 36.16 36.91 33.22
±0.24
SGD + Input + Early + Avg 33.18 33.61 37.00 37.39 33.53
±0.31

27.05 30.55 32.24 31.37 31.32
±0.35
±0.16 ±0.35 ±0.29
27.12 30.63 32.39 31.44 31.50
±0.39
±0.12 ±0.31 ±0.39
29.66 32.40 32.79 33.27 32.59
±0.25
±0.94 ±0.07 ±0.14
29.96 33.30 33.17 33.58 32.95
±0.3
±0.77 ±0.19 ±0.16
SGLD 33.82 34.26 40.13 37.73 33.97 30.33 33.72 33.41 34.03 33.54
±0.15
±0.04 ±0.03 ±0.06
29.80 32.52 32.84 32.77 32.2
27.90 31.18 31.34 32.35 31.92

±0.15
Ulyanov et al. [26] 32.22 33.06 39.16 36.16 33.05
Papyan et al. [21] 28.44 31.44 34.58 35.04 31.11

±1.12 ±2.14 ±0.19

±0.12 ±0.16 ±0.05

±0.3 ±2.01 ±0.14

±0.19

±0.18

±2.07

±0.15

±0.48

±0.45

±0.19

±0.1

30.21
±0.82
30.25
±0.82
33.15
±0.46
33.80
±0.6
34.65
±0.72
34.54
28.05

31.23
±0.11
31.34
±0.08
33.21
±0.36
33.77
±0.23
34.51
±0.08
33.48
31.19

(a) Input

(d) SGLD mean (21.86 dB)
Figure 5. (Best viewed magniﬁed.) Image inpainting using the deep image prior. The posterior mean using SGLD (Panel (d)) achieves
higher PSNR values and has fewer artifacts than SGD variants. See the supplementary material for more comprisons.

(c) SGD + Input (19.59 dB)

(b) SGD (19.23 dB)

(a)

(b) GT

(c) Corrupted

(d) GP RBF (25.78)

(e) GP DIP (26.34)

(f) DIP (26.43)

Inpainting with a Gaussian process (GP) and deep image prior (DIP). Top (a) Comparison of the Radial basis function
Figure 6.
(RBF) kernel with the length scale learned on observed pixels in (c) and the stationary DIP kernel. Bottom (a) PSNR of the GP posterior
with the DIP kernel and DIP as a function of the number of channels. DIP approaches the GP performance as the number of channels
increases from 16 to 512. (d - f) Inpainting results (with the PSNR values) from GP with the RBF (GP RBF) and DIP (GP DIP) kernel, as
well as the deep image prior. The DIP kernel is more effective than the RBF.

5450

21212325|t1t2|0.000.05CovarianceGP-DIPGP-RBF2425262728#Channels2426PSNR (dB)GP-DIPDIPReferences

[1] David Barber and Christopher Bishop. Ensemble Learning
in Bayesian Neural Networks. In Generalization in Neural
Networks and Machine Learning, pages 215–237. Springer
Verlag, January 1998.

[2] Charles Blundell, Julien Cornebise, Koray Kavukcuoglu,
and Daan Wierstra. Weight Uncertainty in Neural Network.
In International Conference on Machine Learning, pages
1613–1622, 2015.

[3] Anastasia Borovykh. A Gaussian Process Perspective on

Convolutional Neural Networks. arXiv:1810.10798, 2018.

[4] Antoni Buades, Bartomeu Coll, and J-M Morel. A Non-
local Algorithm for Image Denoising. In IEEE Conference
on Computer Vision and Pattern Recognition, 2005.

[5] Youngmin Cho and Lawrence K Saul. Kernel Methods for
Deep Learning. In Advances in Neural Information Process-
ing Systems, pages 342–350, 2009.

[6] Kostadin Dabov, Alessandro Foi, Vladimir Katkovnik,
Image Denoising by Sparse 3-D
IEEE Transac-

and Karen Egiazarian.
Transform-domain Collaborative Filtering.
tions on image processing, 16(8):2080–2095, 2007.

[7] John S Denker and Yann LeCun. Transforming Neural-
net Output Levels to Probability Distributions. In Advances
in Neural Information Processing Systems, pages 853–859,
1991.

[8] Yarin Gal and Zoubin Ghahramani. Dropout as a Bayesian
Approximation: Representing Model Uncertainty in Deep
Learning. In International Conference on Machine Learn-
ing, pages 1050–1059, 2016.

[9] Adri`a Garriga-Alonso, Laurence Aitchison, and Carl Edward
Rasmussen. Deep Convolutional Networks as Shallow Gaus-
sian Processes. arXiv:1808.05587, 2018.

[10] Alex Graves. Practical Variational Inference for Neural Net-
works. In Advances in Neural Information Processing Sys-
tems, pages 2348–2356, 2011.

[11] Felix Heide, Wolfgang Heidrich, and Gordon Wetzstein. Fast
and Flexible Convolutional Sparse Coding. In Computer Vi-
sion and Pattern Recognition (CVPR), 2015.

[12] Geoffrey E Hinton and Drew Van Camp. Keeping the Neu-
ral Networks Simple by Minimizing the Description Length
of the Weights. In Conference on Computational Learning
Theory, pages 5–13. ACM, 1993.

[13] Jaehoon Lee, Yasaman Bahri, Roman Novak, Sam Schoen-
holz, Jeffrey Pennington, and Jascha Sohl-dickstein. Deep
Neural Networks as Gaussian Processes. International Con-
ference on Learning Representations, 2018.

[14] Chunyuan Li, Changyou Chen, David E Carlson, and
Preconditioned Stochastic Gradient
In AAAI,

Lawrence Carin.
Langevin Dynamics for Deep Neural Networks.
volume 2, page 4, 2016.

[15] David JC MacKay. A Practical Bayesian Framework for
Backpropagation Networks. Neural computation, 4(3):448–
472, 1992.

[16] Henry B Mann and Abraham Wald. On Stochastic Limit and
Order Relationships. The Annals of Mathematical Statistics,
14(3):217–226, 1943.

[17] Georges Matheron. The Intrinsic Random Functions and
Advances in applied probability,

Their Applications.
5(3):439–468, 1973.

[18] Alexander G de G Matthews, Mark Rowland, Jiri Hron,
Richard E Turner, and Zoubin Ghahramani.
Gaus-
sian Process Behaviour in Wide Deep Neural Networks.
arXiv:1804.11271, 2018.

[19] Radford M Neal. Bayesian Learning for Neural Networks.

PhD thesis, University of Toronto, 1995.

[20] Roman Novak, Lechao Xiao, Yasaman Bahri, Jaehoon Lee,
Greg Yang, Jiri Hron, Daniel A Abolaﬁa, Jeffrey Penning-
ton, and Jascha Sohl-Dickstein. Bayesian Deep Convo-
lutional Networks with Many Channels are Gaussian Pro-
cesses. In International Conference on Learning Represen-
tations, 2019.

[21] Vardan Papyan, Yaniv Romano, Michael Elad, and Jeremias
Sulam. Convolutional Dictionary Learning via Local Pro-
cessing.
In International Conference on Computer Vision,
pages 5306–5314, 2017.

[22] Carl Edward Rasmussen. Evaluation of Gaussian Processes
and Other Methods for Non-linear Regression. University of
Toronto, 1999.

[23] Carl Edward Rasmussen. Gaussian Processes in Machine
Learning. In Advanced lectures on machine learning, pages
63–71. Springer, 2004.

[24] Andrew M. Saxe, Pang Wei Koh, Zhenghao Chen, Maneesh
Bhand, Bipin Suresh, and Andrew Y. Ng. On Random
Weights and Unsupervised Feature Learning.
In Interna-
tional Conference on Machine Learning, 2011.

[25] Charles W Therrien.

Issues in Multirate Statistical Signal
Processing. In Signals, Systems and Computers, 2001. Con-
ference Record of the Thirty-Fifth Asilomar Conference on,
volume 1, pages 573–576. IEEE, 2001.

[26] Dmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky.
Deep Image Prior. In Computer Vision and Pattern Recogni-
tion (CVPR), 2018.

[27] Ivan Ustyuzhaninov, Wieland Brendel, Leon A Gatys, and
Matthias Bethge. Texture Synthesis using Shallow Convo-
lutional Networks with Random Filters. arXiv:1606.00021,
2016.

[28] Max Welling and Yee W Teh. Bayesian Learning via
In International

Stochastic Gradient Langevin Dynamics.
Conference on Machine Learning, 2011.

[29] Christopher KI Williams. Computing with Inﬁnite Net-
works. In Advances in Neural Information Processing Sys-
tems, 1997.

[30] Christopher KI Williams and David Barber. Bayesian Classi-
ﬁcation with Gaussian Processes. IEEE Transactions on Pat-
tern Analysis and Machine Intelligence, 20(12):1342–1351,
1998.

[31] Christopher K. I. Williams and Carl Edward Rasmussen.
Gaussian Processes for Regression. In Advances in Neural
Information Processing Systems, pages 514–520, 1996.

5451

