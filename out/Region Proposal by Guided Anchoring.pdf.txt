Region Proposal by Guided Anchoring

Jiaqi Wang1 ∗ Kai Chen1∗

Shuo Yang2 Chen Change Loy3 Dahua Lin1

1CUHK - SenseTime Joint Lab, The Chinese University of Hong Kong

2Amazon Rekognition

3Nanyang Technological University

{wj017,ck015,dhlin}@ie.cuhk.edu.hk

shuoy@amazon.com

ccloy@ntu.edu.sg

Abstract

Region anchors are the cornerstone of modern object
detection techniques. State-of-the-art detectors mostly rely
on a dense anchoring scheme, where anchors are sampled
uniformly over the spatial domain with a predeﬁned set of
scales and aspect ratios. In this paper, we revisit this foun-
dational stage. Our study shows that it can be done much
more effectively and efﬁciently. Speciﬁcally, we present an
alternative scheme, named Guided Anchoring, which lever-
ages semantic features to guide the anchoring. The pro-
posed method jointly predicts the locations where the cen-
ter of objects of interest are likely to exist as well as the
scales and aspect ratios at different locations. On top of
predicted anchor shapes, we mitigate the feature incon-
sistency with a feature adaption module. We also study
the use of high-quality proposals to improve detection per-
formance. The anchoring scheme can be seamlessly inte-
grated into proposal methods and detectors. With Guided
Anchoring, we achieve 9.1% higher recall on MS COCO
with 90% fewer anchors than the RPN baseline. We also
adopt Guided Anchoring in Fast R-CNN, Faster R-CNN
and RetinaNet, respectively improving the detection mAP
by 2.2%, 2.7% and 1.2%. Code is available at https:
//github.com/open-mmlab/mmdetection.

1. Introduction

Anchors are regression references and classiﬁcation can-
didates to predict proposals (for two-stage detectors) or ﬁnal
bounding boxes (for single-stage detectors). Modern object
detection pipelines usually begin with a large set of densely
distributed anchors. Take Faster RCNN [27], a popular ob-
ject detection framework, for instance, it ﬁrst generates re-
gion proposals from a dense set of anchors and then classi-
ﬁes them into speciﬁc classes and reﬁnes their locations via
bounding box regression.

There are two general rules for a reasonable anchor de-

∗Equal contribution.

sign: alignment and consistency. Firstly, to use convo-
lutional features as anchor representations, anchor centers
need to be well aligned with feature map pixels. Secondly,
the receptive ﬁeld and semantic scope should be consistent
with the scale and shape of anchors on different locations of
a feature map. The sliding window is a simple and widely
adopted anchoring scheme following the rules. For most de-
tection methods, the anchors are deﬁned by such a uniform
scheme, where every location in a feature map is associated
with k anchors with predeﬁned scales and aspect ratios.

Anchor-based detection pipelines have been shown ef-
fective in both benchmarks [6, 20, 7, 5] and real-world sys-
tems. However, the uniform anchoring scheme described
above is not necessarily the optimal way to prepare the an-
chors. This scheme can lead to two difﬁculties: (1) A neat
set of anchors of ﬁxed aspect ratios has to be predeﬁned for
different problems. A wrong design may hamper the speed
and accuracy of the detector. (2) To maintain a sufﬁciently
high recall for proposals, a large number of anchors are
needed, while most of them correspond to false candidates
that are irrelevant to the object of interests. Meanwhile, a
large number of anchors can lead to signiﬁcant computa-
tional cost especially when the pipeline involves a heavy
classiﬁer in the proposal stage.

In this work, we present a more effective method to pre-
pare anchors, with the aim to mitigate the issues of hand-
picked priors. Our method is motivated by the observation
that objects are not distributed evenly over the image. The
scale of an object is also closely related to the imagery con-
tent, its location and geometry of the scene. Following this
intuition, our method generates sparse anchors in two steps:
ﬁrst identifying sub-regions that may contain objects and
then determining the shapes at different locations.

Learnable anchor shapes are promising, but it breaks the
aforementioned rule of consistency, thus presents a new
challenge for learning anchor representations for accurate
classiﬁcation and regression. Scales and aspect ratios of an-
chors are now variable instead of ﬁxed, so different feature
map pixels have to learn adaptive representations that ﬁt the
corresponding anchors. To solve this problem, we introduce

2965

an effective module to adapt the features based on anchor
geometry.

We formulate a Guided Anchoring Region Proposal Net-
work (GA-RPN) with the aforementioned guided anchoring
and feature adaptation scheme. Thanks to the dynamically
predicted anchors, our approach achieves 9.1% higher re-
call with 90% substantially fewer anchors than the RPN
baseline that adopts dense anchoring scheme. By predict-
ing the scales and aspect ratios instead of ﬁxing them based
on a predeﬁned list, our scheme handles tall or wide ob-
jects more effectively. Besides region proposals, the guided
anchoring scheme can be easily integrated into any de-
tectors that depend on anchors. Consistent performance
gains can be achieved with our scheme. For instance,
GA-Fast-RCNN, GA-Faster-RCNN and GA-RetinaNet im-
prove overall mAP by 2.2%, 2.7% and 1.2% respectively
on COCO dataset over their baselines with sliding window
anchoring. Furthermore, we explore the use of high-quality
proposals, and propose a ﬁne-tuning schedule using GA-
RPN proposals, which can improve the performance of any
trained models, e.g., it improves a fully converged Faster
R-CNN model from 37.4% to 39.6%, in only 3 epochs.

The main contributions of this work lie in several as-
pects.
(1) We propose a new anchoring scheme with the
ability to predict non-uniform and arbitrary shaped anchors
other than dense and predeﬁned ones.
(2) We formulate
the joint anchor distribution with two factorized conditional
distributions, and design two modules to model them re-
spectively.
(3) We study the importance of aligning fea-
tures with the corresponding anchors and design a feature
adaption module to reﬁne features based on the underlying
anchor shapes. (4) We investigate the use of high-quality
proposals for two-stage detectors and propose a scheme to
improve the performance of trained models.

2. Related Work

Sliding window anchors in object detection. Generat-
ing anchors with the sliding window manner in feature
maps has been widely adopted by anchor-based various
detectors. The two-stage approach has been the leading
paradigm in the modern era of object detection. Faster R-
CNN [27] proposes the Region Proposal Network (RPN)
to generates object proposals.
It uses a small fully con-
volutional network to map each sliding window anchor to
a low-dimensional feature. This design is also adopted in
later two-stage methods [3, 18, 12]. MetaAnchor [32] in-
troduces meta-learning to anchor generation. There have
been attempts [8, 9, 23, 31, 33, 34, 1, 2] that apply cas-
cade architecture to reject easy samples at early layers or
stages, and regress bounding boxes iteratively for progres-
sive reﬁnement. Compared to two-stage approaches, the
single-stage pipeline skips object proposal generation and
predicts bounding boxes and class scores in one evaluation.

Although the proposal step is omitted, single-stage meth-
ods still use anchor boxes produced by the sliding window.
For instance, SSD [21] and DenseBox [14] generate anchors
densely from feature maps and evaluate them like a multi-
class RPN. RetinaNet [19] introduces focal loss to address
the foreground-background class imbalance. YOLOv2[26]
adopt sliding window anchors for classiﬁcation and spatial
location prediction so as to achieve a higher recall than its
precedent.
Comparison and difference. We summarize the differ-
ences between the proposed method and conventional meth-
ods as follows.
(i) Primarily, previous methods (single-
stage, two-stage and multi-stage) still rely on dense and
uniform anchors by sliding window. We discard the slid-
ing window scheme and propose a better counterpart to
guide the anchoring and generate sparse anchors, which
has not been explored before. (ii) Cascade detectors adopt
more than one stage to reﬁne detection bounding boxes pro-
gressively, which usually leads to more model parameters
and a decrease in inference speed. These methods adopt
RoI Pooling or RoI Align to extract aligned features for
bounding boxes, which is too expensive for proposal gen-
eration or single-stage detectors.
(iii) Anchor-free meth-
ods [14, 15, 25] usually have simple pipelines and produce
ﬁnal detection results within a single stage. Due to the ab-
sence of anchors and further anchor-based reﬁnement, they
lack the ability to deal with complex scenes and cases. Our
focus is the sparse and non-uniform anchoring scheme and
use of high-quality proposals to boost the detection perfor-
mance. Towards this goal, we have to solve the misalign-
ment and inconsistency issues which are speciﬁc to anchor-
based methods. (iv) Some single-shot detectors [33, 30] re-
ﬁne anchors by multiple regression and classiﬁcation. Our
method differs from them signiﬁcantly. We do not reﬁne an-
chors progressively, instead, we predict the distribution of
anchors, which is factorized as locations and shapes. Con-
ventional methods fail to consider the alignment between
anchors and features so they regress anchors (represented by
[x, y, w, h]) for multiple times and breaks the alignment as
well as consistency. On the contrary, we emphasize the im-
portance of the two rules, so we only predict anchor shapes
but ﬁx anchor centers and adapt features based on the pre-
dicted shapes.

3. Guided Anchoring

Anchors are the basis in modern object detection
pipelines. Mainstream frameworks, including two-stage
and single-stage methods, mostly rely on a uniform arrange-
ment of anchors. Speciﬁcally, a set of anchors with prede-
ﬁned scales and aspect ratios will be deployed over a fea-
ture map of size W × H, with a stride of s. This scheme
is inefﬁcient, as many of the anchors are placed in regions
where the objects of interest are unlikely to exist. In addi-

2966

Guided 
anchoring

Guided 
anchoring

Guided 
anchoring

Guided 
anchoring

anchors

anchors

anchors

anchors

𝐹𝐼

prediction

prediction

prediction

prediction

feature pyramid

Guided anchoring

Anchor generation

𝒩𝐿
𝒩𝑆

W×H×1

location

W×H×2

shape

anchors

Feature adaption

1x1 conv

offset field

𝒩T

𝐹𝐼′

Figure 1: An illustration of our framework. For each output feature map in the feature pyramid, we use an anchor generation module with
two branches to predict the anchor location and shape, respectively. Then a feature adaption module is applied to the original feature map
to make the new feature map aware of anchor shapes.

tion, such hand-picked priors unrealistically assume a set of
ﬁxed shape (i.e., scale and aspect ratio) for objects.

In this work, we aim to develop a more efﬁcient anchor-
ing scheme to arrange the anchors with learnable shapes,
considering the non-uniform distribution of objects’ loca-
tions and shapes. The guided anchoring scheme works as
follows. The location and the shape of an object can be
characterized by a 4-tuple in the form of (x, y, w, h), where
(x, y) is the spatial coordinate of the center, w the width,
and h the height. Suppose we draw an object from a given
image I, then its location and shape can be considered to
follow a distribution conditioned on I, as follows:

p(x, y, w, h|I) = p(x, y|I)p(w, h|x, y, I).

(1)

This factorization captures two important intuitions:
(1)
given an image, objects may only exist in certain regions;
and (2) the shape, i.e., scale and aspect ratio, of an object
closely relates to its location.

Following this formulation, we devise an anchor gener-
ation module as shown in the red dashed box of Figure 1.
This module is a network comprised of two branches for lo-
cation and shape prediction, respectively. Given an image I,
we ﬁrst derive a feature map FI . On top of FI , the location
prediction branch yields a probability map that indicates the
possible locations of the objects, while the shape predic-
tion branch predicts location-dependent shapes. Given the
outputs from both branches, we generate a set of anchors
by choosing the locations whose predicted probabilities are
above a certain threshold and the most probable shape at
each of the chosen locations. As the anchor shapes can vary,
the features at different locations should capture the visual
content within different ranges. With this taken into consid-
eration, we further introduce a feature adaptation module,
which adapts the feature according to the anchor shape.

The anchor generation process described above is based
on a single feature map. Recent advances in object detec-

tion [18, 19] show that it is often helpful to operate on mul-
tiple feature maps at different levels. Hence, we develop
a multi-level anchor generation scheme, which collects an-
chors at multiple feature maps, following the FPN architec-
ture [18]. Note that in our design, the anchor generation
parameters are shared across all involved feature levels thus
the scheme is parameter-efﬁcient.

3.1. Anchor Location Prediction

2 )s, (j + 1

As shown in Figure 1, the anchor location prediction
branch yields a probability map p(·|FI ) of the same size as
the input feature map FI , where each entry p(i, j|FI ) corre-
sponds to the location with coordinate ((i + 1
2 )s)
on I, where s is stride of the feature map, i.e., the distance
between neighboring anchors. The entry’s value indicates
the probability of an object’s center existing at that location.
In our formulation, the probability map p(i, j|FI ) is pre-
dicted using a sub-network NL. This network applies a
1 × 1 convolution to the base feature map FI to obtain a
map of objectness scores, which are then converted to prob-
ability values via an element-wise sigmoid function. While
a deeper sub-network can make more accurate predictions,
we found empirically that a convolutional layer followed
by a sigmoid transform strikes a good balance between ef-
ﬁciency and accuracy.

Based on the resultant probability map, we then deter-
mine the active regions where objects may possibly exist
by selecting those locations whose corresponding probabil-
ity values are above a predeﬁned threshold ǫL. This pro-
cess can ﬁlter out 90% of the regions while still maintain-
ing the same recall. As illustrated in Figure 4(b), regions
like sky and ocean are excluded, while anchors concentrate
densely around persons and surfboards. Since there is no
need to consider those excluded regions, we replace the en-
suing convolutional layers by masked convolution [17, 28]
for more efﬁcient inference.

2967

3.2. Anchor Shape Prediction

After identifying the possible locations for objects, our
next step is to determine the shape of the object that may
exist at each location. This is accomplished by the an-
chor shape prediction branch, as shown in Figure 1. This
branch is very different from conventional bounding box re-
gression, since it does not change the anchor positions and
will not cause misalignment between anchors and anchor
features. Concretely, given a feature map FI , this branch
will predict the best shape (w, h) for each location, i.e., the
shape that may lead to the highest coverage with the nearest
ground-truth bounding box.

While our goal is to predict the values of the width w and
the height h, we found empirically that directly predicting
these two numbers is not stable, due to their large range.
Instead, we adopt the following transformation:

w = σ · s · edw,

h = σ · s · edh.

(2)

The shape prediction branch will output dw and dh , which
will then be mapped to (w, h) as above, where s is the stride
and σ is an empirical scale factor (σ = 8 in our experi-
ments). This nonlinear transformation projects the output
space from approximate [0, 1000] to [−1, 1], leading to an
easier and stable learning target. In our design, we use a
sub-network NS for shape prediction, which comprises a
1 × 1 convolutional layer that yields a two-channel map
that contains the values of dw and dh, and an element-wise
transform layer that implements Eq.(2).

Note that this design differs essentially from the conven-
tional anchoring schemes in that every location is associated
with just one anchor of the dynamically predicted shape in-
stead of a set of anchors of predeﬁned shapes. Our experi-
ments show that due to the close relations between locations
and shapes, our scheme can achieve much higher recall than
the baseline scheme. Since it allows arbitrary aspect ratios,
our scheme can better capture those extremely tall or wide
objects.

3.3. Anchor Guided Feature Adaptation

In the conventional RPN or single stage detectors where
the sliding window scheme is adopted, anchors are uni-
form on the whole feature map, i.e., they share the same
shape and scale in each position. Thus the feature map can
learn consistent representation. In our scheme, however, the
shape of anchors varies across locations. Under this condi-
tion, we ﬁnd that it may not be a good choice to follow
the previous convention [27], in which a fully convolutional
classiﬁer is applied uniformly over the feature map. Ideally,
the feature for a large anchor should encode the content over
a large region, while those for small anchors should have
smaller scopes accordingly. Following this intuition, we
further devise an anchor-guided feature adaptation compo-

nent, which will transform the feature at each individual lo-
cation based on the underlying anchor shape, as

f ′
i = NT (fi, wi, hi),

(3)

where fi is the feature at the i-th location, (wi, hi) is the
corresponding anchor shape. For such a location-dependent
transformation, we adopt a 3 × 3 deformable convolutional
layer [4] to implement NT . As shown in Figure 1, we ﬁrst
predict an offset ﬁeld from the output of anchor shape pre-
diction branch, and then apply deformable convolution to
the original feature map with the offsets to obtain f ′
I . On
top of the adapted features, we can then perform further
classiﬁcation and bounding-box regression.

3.4. Training

Joint objective. The proposed framework is optimized in
an end-to-end fashion using a multi-task loss. Apart from
the conventional classiﬁcation loss Lcls and regression loss
Lreg, we introduce two additional losses for the anchor lo-
calization Lloc and anchor shape prediction Lshape. They
are jointly optimized with the following loss.

L = λ1Lloc + λ2Lshape + Lcls + Lreg.

(4)

g, y′

g, h′

g, w′

Anchor location targets. To train the anchor localization
branch, for each image we need a binary label map where 1
represents a valid location to place an anchor and 0 oth-
erwise.
In this work, we employ ground-truth bounding
boxes for guiding the binary label map generation. In par-
ticular, we wish to place more anchors around the vicin-
ity of an object’s center, while fewer of them far from
the center. Firstly, we map the ground-truth bounding box
(xg, yg, wg, hg) to the corresponding feature map scale, and
g). We denote R(x, y, w, h) as the
obtain (x′
rectangular region whose center is (x, y) and the size of
w ×h. Anchors are expected to be placed close to the center
of ground truth objects to obtain larger initial IoU, thus we
deﬁne three types of regions for each box.
(1) The center region CR = R(x′
g, σ1w′, σ1h′) deﬁnes
the center area of the box. Pixels in CR are assigned as
positive samples.
(2) The ignore region IR = R(x′
g, σ2w′, σ2h′)\CR is
a larger (σ2 > σ1) region excluding CR. Pixels in IR are
marked as “ignore” and excluded during training.
(3) The outside region OR is the feature map excluding CR
and IR. Pixels in OR are regarded as negative samples.

g, y′

g, y′

Previous work [14] proposed the “gray zone” for bal-
anced sampling, which has a similar deﬁnition to our loca-
tion targets but only works on a single feature map. Since
we use multiple feature levels from FPN, we also consider
the inﬂuence of adjacent feature maps. Speciﬁcally, each
level of feature map should only target objects of a speciﬁc
scale range, so we assign CR on a feature map only if the

2968

ground truth bounding box

center region (positive)

ignore region

outside region (negative)

Figure 2: Anchor location target for multi-level features. We
assign ground truth objects to different feature levels according
to their scales, and deﬁne CR, IR and OR respectively.
(Best
viewed in color.)

feature map matches the scale range of the targeted object.
The same regions of adjacent levels are set as IR, as shown
in Figure 2. When multiple objects overlap, CR can sup-
press IR, and IR can suppress OR. Since CR usually ac-
counts for a small portion of the whole feature map, we use
Focal Loss [19] to train the location branch.
Anchor shape targets. There are two steps to determine the
best shape target for each anchor. First, we need to match
the anchor to a ground-truth bounding box. Next, we will
predict the anchor’s width and height which can best cover
the matched ground-truth.

Previous work [27] assign a candidate anchor to the
ground truth bounding box that yields the largest IoU value
with the anchor. However, this process is not applicable in
our case, since w and h of our anchors are not predeﬁned but
variables. To overcome this problem, we deﬁne the IoU be-
tween a variable anchor awh = {(x0, y0, w, h)|w > 0, h >
0} and a ground truth bounding box gt = (xg, yg, wg, hg)
as follows, denoted as vIoU.

vIoU(awh, gt) = max

w>0,h>0

IoUnormal(awh, gt),

(5)

where IoUnormal is the typical deﬁnition of IoU and w and
h are variables. Note that for an arbitrary anchor loca-
tion (x0, y0) and ground-truth gt, the analytic expression of
vIoU(awh, gt) is complicated, and hard to be implemented
efﬁciently in an end-to-end network. Therefore we use an
alternative way to approximate it. Given (x0, y0), we sam-
ple some common values of w and h to simulate the enu-
meration of all w and h. Then we calculate the IoU of
these sampled anchors with gt, and use the maximum as
an approximation of vIoU(awh, gt). In our experiments, we
sample 9 pairs of (w, h) to estimate vIoU during training.
Speciﬁcally, we adopt the 9 pairs of different scales and as-
pect ratios used in RetinaNet[19]. Theoretically, the more
pairs we sample, the more accurate the approximation is,
while the computational cost is heavier. We adopt a vari-
ant of bounded iou loss [29] to optimize the shape predic-
tion, without computing the target. The loss is deﬁned in
Eq. (6), where (w, h) and (wg, hg) denote the predicted an-
chor shape and the shape of the corresponding ground-truth

Figure 3: IoU distribution of RPN and GA-RPN proposals. We
show the accumulated proposal number with decreasing IoUs.

bounding box. L1 is the smooth L1 loss.

Lshape = L1(1 − min( w
wg

, wg

w )) + L1(1 − min( h
hg

, hg

h )). (6)

3.5. The Use of High quality Proposals

RPN enhanced by the proposed guided anchoring
scheme (GA-RPN) can generate much higher quality pro-
posals than the conventional RPN. We explore how to
boost the performance of conventional two-stage detectors,
through the use of such high-quality proposals. Firstly, we
study the IoU distribution of proposals generated by RPN
and GA-RPN, as shown in Figure 3. There are two signiﬁ-
cant advantages of GA-RPN proposals over RPN proposals:
(1) the number of positive proposals is larger, and (2) the
ratio of high-IoU proposals is more signiﬁcant. A straight-
forward idea is to replace RPN in existing models with the
proposed GA-RPN and train the model end-to-end. How-
ever, this problem is non-trivial and adopting exactly the
same settings as before can only bring limited gain (e.g.,
less than 1 point). From our observation, the pre-requisite
of using high-quality proposals is to adapt the distribution of
training samples in accordance to the proposal distribution.
Consequently, we set a higher positive/negative threshold
and use fewer samples when training detectors end-to-end
with GA-RPN compared to RPN.

Besides end-to-end training, we ﬁnd that GA-RPN pro-
posals are capable of boosting a trained two-stage detec-
tor by a ﬁne-tuning schedule. Speciﬁcally, given a trained
model, we discard the proposal generation component, e.g.,
RPN, and use pre-computed GA-RPN proposals to ﬁnetune
it for several epochs (3 epochs by default). GA-RPN pro-
posals are also used for inference. This simple ﬁne-tuning
scheme can further improve the performance by a large mar-
gin, with only a time cost of a few epochs.

4. Experiments

4.1. Experimental Setting

Dataset. We perform experiments on the challenging MS
COCO 2017 benchmark [20]. We use the train split for

2969

1.00.90.80.70.60.5IoU01020304050proposals / imgRPNGA-RPNTable 1: Region proposal results on MS COCO.

Method

Backbone

AR100 AR300 AR1000 ARS ARM ARL

runtime (s/img)

SharpMask [24]
GCN-NS [22]

AttractioNet [10]

ZIP [16]

RPN

RPN+9 anchors

RPN+Focal Loss [19]

RPN+Bounded IoU Loss [29]

RPN+Iterative

ReﬁneRPN

ResNet-50

VGG-16 (SyncBN)

VGG-16

BN-inception

ResNet-50-FPN
ResNet-152-FPN
ResNeXt-101-FPN

ResNet-50-FPN
ResNet-50-FPN
ResNet-50-FPN
ResNet-50-FPN
ResNet-50-FPN

GA-RPN

ResNet-50-FPN

36.4
31.6
53.3
53.9

47.5
51.9
52.8

46.8
50.2
48.3
49.7
50.2

59.2

-
-
-
-

54.7
58.0
58.7

54.6
56.6
55.1
56.0
56.3

65.2

48.2
60.7
66.2
67.0

59.4
62.0
62.6

60.3
60.9
59.6
60.0
60.6

68.5

6.0

-

31.5
31.9

31.7
36.3
37.3

29.5
33.9
33.0
34.7
33.5

40.9

51.0

66.5

0.76 (unfair)

-

62.2
63.0

55.1
59.8
60.8

54.9
58.2
56.0
58.2
59.1

67.8

-

77.7
78.5

64.6
68.1
68.6

65.6
67.5
64.3
64.0
66.9

79.0

0.10
4.00
1.13

0.09
0.16
0.26

0.09
0.09
0.09
0.10
0.11

0.13

Table 2: Detection results on MS COCO 2017 test-dev.

Table 3: Fine-tuning results on a trained Faster R-CNN.

Method

AP AP50 AP75 APS APM APL

proposals AP AP50 AP75 APS APM APL

Fast R-CNN

37.1
GA-Fast-RCNN 39.4

Faster R-CNN

37.1
GA-Faster-RCNN 39.8

RetinaNet

GA-RetinaNet

35.9
37.1

59.6
59.4

59.1
59.2

55.4
56.9

39.7
42.8

40.1
43.5

38.8
40.0

20.7
21.6

21.3
21.8

19.4
20.1

39.5
41.9

39.8
42.6

38.9
40.1

47.1
50.4

46.5
50.7

46.5
48.0

training and report the performance on val split. Detection
results are reported on test-dev split.
Implementation details. We use ResNet-50 [13] with
FPN [18] as the backbone network, if not otherwise spec-
iﬁed. As a common convention, we resize images to the
scale of 1333 × 800, without changing the aspect ratio. We
set σ1 = 0.2, σ2 = 0.5. In the multi-task loss function, we
simply use λ1 = 1, λ2 = 0.1 to balance the location and
shape prediction branches. We use synchronized SGD over
8 GPUs with 2 images per GPU. We train 12 epochs in total
with an initial learning rate of 0.02, and decrease the learn-
ing rate by 0.1 at epoch 8 and 11. The runtime is measured
on TITAN X GPUs.
Evaluation metrics. The results of RPN are measured with
Average Recall (AR), which is the average of recalls at dif-
ferent IoU thresholds (from 0.5 to 0.95). AR for 100, 300,
and 1000 proposals per image are denoted as AR100, AR300
and AR1000. The AR for small, medium, and large objects
(ARS, ARM , ARL) are computed for 100 proposals. Detec-
tion results are evaluated with the standard COCO metric,
which averages mAP of IoUs from 0.5 to 0.95.

4.2. Results

We ﬁrst evaluate our anchoring scheme by comparing
the recall of GA-RPN with the RPN baseline and previ-

-

37.4
37.3
GA-RPN 39.6

RPN

58.9
58.6
59.3

40.3
40.1
43.0

20.8
20.4
22.0

41.1
40.6
42.8

49.5
49.8
52.6

ous state-of-the-art region proposal methods. Meanwhile,
we compare some variants of RPN. “RPN+9 anchors” de-
notes using 3 scales and 3 aspect ratios in each feature level,
while baselines use only 1 scale and 3 aspect ratios, fol-
lowing [18]. “RPN+Focal Loss” and “RPN+Bounded IoU
Loss” denotes adopting focal loss [19] and bounded IoU
Loss [29] to RPN by substituting binary cross-entropy loss
and smooth l1 loss, respectively. “RPN+Iterative” denotes
applying two RPN heads consecutively, with an additional
3 × 3 convolution between them. “ReﬁneRPN” denotes a
similar structure to [33], where anchors are regressed and
classiﬁed twice with features before and after FPN.

As shown in Table 1, our method outperforms the RPN
baseline by a large margin. Speciﬁcally, it improves AR300
by 10.5% and AR1000 by 9.1% respectively. Notably, GA-
RPN with a small backbone can achieve a much higher re-
call than RPN with larger backbones. Our encouraging re-
sults are supported by the qualitative results shown in Fig-
ure 4, where we show the sparse and arbitrary shaped an-
chors and visualize the outputs of two branches. It is ob-
served that the anchors concentrate more on objects and
provides a good basis for the ensuing object proposal. In
Figure 5, we show some examples of proposals generated
upon sliding window anchoring and guided anchoring.

Iterative regression and classiﬁcation (“RPN+Iterative”
and “ReﬁneRPN”) only brings limited gain to RPN, which
proves the importance of the aforementioned rule of align-
ment and consistency, and simply reﬁning anchors multiple

2970

Figure 4: Anchor prediction results. (a) input image and predict
anchors; (b) predicted anchor location probability map; (c) pre-
dicted anchor aspect ratio.

Figure 5: Examples of RPN proposals (top row) and GA-
RPN proposals (bottom row).

times is not effective enough. Keeping the center of anchors
ﬁxed and adapt features based on anchor shapes are crucial.
To investigate the generalization ability of guided an-
choring and its power to boost the detection performance,
we integrate it into both two-stage and single-stage de-
tection pipelines, including Fast R-CNN [11], Faster R-
CNN [27] and RetinaNet [19]. For two-stage detectors,
we replace the original RPN with GA-RPN, and for single-
stage detectors, the sliding window anchoring scheme is
replaced with the proposed guided anchoring. Results in
Table 2 show that guided anchoring not only increases the
proposal recall of RPN, but also improves the detection per-
formance by a large margin. With guided anchoring, the
mAP of these detectors are improved by 2.3%, 2.7% and
1.2% respectively.

To further study the effectiveness of high-quality propos-
als and investigate the ﬁne-tuning scheme, we take a fully
converged Faster R-CNN model and ﬁnetune it with pre-
computed RPN or GA-RPN proposals. We ﬁnetune the de-
tector for 3 epochs, with the learning rate of 0.02, 0.002
and 0.0002 respectively. The results are in Table 3 illustrate
that RPN proposals cannot bring any gain, while the high-
quality GA-RPN proposals bring 2.2% mAP improvement
to the trained model with only a time cost of 3 epochs.

4.3. Ablation Study

Model design. We omit different components in our design
to investigate the effectiveness of each component, includ-
ing location prediction, shape prediction and feature adap-
tion. Results are shown in Table 4. The shape prediction
branch is shown effective which leads to a gain of 4.2%.

Table 4: The effects of each module in our design. L., S., and
F.A. denote location, shape, and feature adaptation, respectively.

L. S. F.A. AR100 AR300 AR1000 ARS ARM ARL

X

X

X X

X X X

47.5
48.0
53.8
54.0
59.2

54.7
54.8
59.9
60.1
65.2

59.4
59.5
63.6
63.8
68.5

31.7
32.3
36.4
36.7
40.9

55.1
55.6
62.9
63.1
67.8

64.6
64.8
71.7
71.5
79.0

Table 5: Results of different location threshold ǫL.

ǫL

0

0.01
0.05
0.1

#anchors/image AR100 AR300 AR1000

fps

75583 (100.0%)
22274 (29.4%)

5251 (6.5%)
2375 (3.2%)

59.2
59.2
59.1
59.0

65.2
65.2
65.1
64.7

68.5
68.5
68.2
67.2

7.8
8.0
8.2
8.2

(a)

(b)

Figure 6: (a) Anchor scale and (b) aspect ratio distributions of
different anchoring schemes. The x-axis is reduced to log-space
by apply log2(·) operator. GT, GA, SW indicates ground truth,
guided anchoring, sliding window, respectively.

The location prediction branch brings marginal improve-
ment. Nevertheless, the importance of this branch is re-
ﬂected in its usefulness of obtaining sparse anchors leading
to more efﬁcient inference. The obvious gain brought by the
feature adaption module suggests the necessity of rearrang-
ing the feature map according to predicted anchor shapes.
This module helps to capture information corresponding to
anchor scopes, especially for large objects.
Anchor location. The location threshold ǫL controls the
sparsity of anchor distribution. Adopting different thresh-
olds will yield different numbers of anchors. To reveal the
inﬂuence of ǫL on efﬁciency and performance, we vary the
threshold and compare the following results:
the average
number of anchors per image, recall of ﬁnal proposals and
the inference runtime. From Table 5 we can observe that the
objectness scores of most background regions are close to 0,
so a small ǫL can greatly reduce the number of anchors by
more than 90%, with only a minor decrease on recall rate. It
is noteworthy that the head in RPN is just one convolutional
layer, so the speedup is not apparent. Nevertheless, a signif-
icant reduction in the number of anchors offers a possibility
to perform more efﬁcient inference with a heavier head.

2971

widetall(a)(b)(c)RPNGA -RPN23456789scale (sqrt(w*h))0.00.20.40.60.81.01.21.41.6GTGASW432101234aspect ratio (h/w)0.00.10.20.30.40.50.60.70.8GTGASWTable 6: The effects of alignment and consistency rules. C.A. and
F.A. denote center alignment (alignment rule) and feature adaption
(consistency rule) respectively.

C.A. F.A. AR100 AR300 AR1000 ARS ARM ARL

X

X

X

X

51.7
54.0
57.2
59.2

58.0
60.1
63.6
65.2

61.6
63.8
66.8
68.5

33.8
36.7
38.3
40.9

60.9
63.1
66.1
67.8

70.0
71.5
77.8
79.0

Anchor shape. We compare the set of generated anchors
of our method with sliding window anchors of pre-deﬁned
shapes. Since our method predicts only one anchor at each
location of the feature map instead of k (k = 3 in our base-
line) anchors of different scales and aspect ratios, the total
anchor number is reduced by 1
k . We present the scale and
aspect ratio distribution of our anchors with sliding window
anchors in Figure 6. The results show great advantages of
the guided anchoring scheme over predeﬁned anchor scales
and shapes. The predicted anchors cover a much wider
range of scales and aspect ratios, which have a similar dis-
tribution to ground truth objects and provide a pool of initial
anchors with higher coverage on objects.
Feature adaption. The feature adaption module improves
the recall by a large margin, proving that a remedy of
features consistency is essential. We claim that the im-
provement not only comes from adopting deformable con-
volution, but also results from our design of using an-
chor shape predictions to predict the offset of the de-
formable convolution layer. If we simply add a deformable
convolution layer after anchor generation, the results of
AR100/AR300/AR1000 are 56.1%/62.4%/66.1%, which
are inferior to results from our design.
Alignment and consistency rule. We verify the necessity
of the two proposed rules. The alignment rule suggests that
we should keep the anchor centers aligned with feature map
pixels. According to the consistency rule, we design the
feature adaption module to reﬁne the features. Results in
Table 6 show the importance of these rules. 1) From row
1 and 2, or row 3 and 4, we learn that predicting both the
shape and center offset instead of just predicting the shape
harms the performance. 2) The comparison between row 1
and 3, or row 2 and 4 shows the impact of consistency.
The use of high-quality proposals. Despite with high-
quality proposals, training a good detector remains a non-
trivial problem. As illustrated in Figure 3, GA-RPN propos-
als provide more candidates of high IoU. This suggests that
we can use fewer proposals for training detectors. We test
different numbers of proposals and different IoU thresholds
to assign labels for foreground/background on Fast R-CNN.
From the results in Table 7, we observe that: (1) Larger
IoU threshold is important for taking advantage of high-
quality proposals. By focusing on positive samples of

Table 7: Exploration of utilizing high-quality proposals.

proposal

num IoU thr AP AP50 AP75

RPN

GA-RPN

1000
1000
300
300

1000
1000
300
300

0.5
0.6
0.5
0.6

0.5
0.6
0.5
0.6

36.7
37.2
36.1
37.0

37.4
38.9
37.5
39.4

58.8
57.1
57.6
56.3

59.9
59.0
59.6
59.3

39.3
40.5
39.0
39.5

40.0
42.4
40.4
43.2

higher IoU, there will be fewer false positives and the fea-
tures for classiﬁcation are more discriminative. Since we
assign negative labels to proposals with IoU less than 0.6
during training, AP0.5 will decrease while AP of high IoUs
will increase by a large margin, and the overall AP is much
higher. (2) Using fewer proposals during training and test-
ing can beneﬁt the learning if the recall is high enough.
Fewer proposals lead to a lower recall, but will simplify
the learning process, since there are more hard samples
in low-score proposals. When training with RPN propos-
als, the performance will decrease if we use only 300 pro-
posals, because the recall is not sufﬁcient and many ob-
jects get missed. However, GA-RPN guarantees high recall
even with fewer proposals, thus training with 300 proposals
could still boost the ﬁnal mAP.
Hyper-parameters. Our method is insensitive to hyper-
parameters. (1) As we sample 3, 9, 15 pairs to approximate
Eq.(5), we respectively obtain AR@1000 68.3%, 68.5%,
68.5%. (2) We set λ2 = 0.1 to balance the loss terms by
default. We obtain 68.4% with λ2 = 0.2 or 0.05 and 68.3%
with λ2 = 0.02. (3) We vary σ1 within [0.1, 0.5] and σ2
within [0.2, 1.0], and the performance remains comparable
(between 68.1% and 68.5%).

5. Conclusion

We have proposed the Guided Anchoring scheme, which
leverages semantic features to guide the anchoring. It gen-
erates non-uniform anchors of arbitrary shapes by jointly
predicting the locations and anchor shapes dependent on lo-
cations. The proposed method achieves 9.1% higher recall
with 90% fewer anchors than the RPN baseline using the
sliding window scheme. It can also be applied to various
anchor-based detectors to improve the performance by as
much as 2.7%.

Acknowledgment This work is partially supported by
the Collaborative Research grant from SenseTime Group
(CUHK Agreement No. TS1610626 & No. TS1712093),
the General Research Fund (GRF) of Hong Kong (No.
14236516, No. 14203518 & No. 14224316), and Singa-
pore MOE AcRF Tier 1 (M4012082.020).

2972

References

[1] Zhaowei Cai and Nuno Vasconcelos. Cascade r-cnn: Delving
into high quality object detection. In IEEE Conference on
Computer Vision and Pattern Recognition, 2018. 2

[2] Kai Chen, Jiangmiao Pang, Jiaqi Wang, Yu Xiong, Xiaoxiao
Li, Shuyang Sun, Wansen Feng, Ziwei Liu, Jianping Shi,
Wanli Ouyang, Chen Change Loy, and Dahua Lin. Hybrid
task cascade for instance segmentation, 2019. 2

[3] Jifeng Dai, Yi Li, Kaiming He, and Jian Sun. R-fcn: Object
detection via region-based fully convolutional networks. In
Advances in Neural Information Processing Systems, 2016.
2

[4] Jifeng Dai, Yi Li, Kaiming He, and Jian Sun. R-FCN: Object
detection via region-based fully convolutional networks. In
Advances in Neural Information Processing Systems, 2016.
4

[5] Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li,
and Li Fei-Fei. Imagenet: A large-scale hierarchical image
database. In IEEE Conference on Computer Vision and Pat-
tern Recognition, 2009. 1

[6] Mark Everingham, SM Ali Eslami, Luc Van Gool, Christo-
pher KI Williams, John Winn, and Andrew Zisserman. The
pascal visual object classes challenge: A retrospective. Inter-
national Journal of Computer Vision, 111(1):98–136, 2015.
1

[7] Andreas Geiger, Philip Lenz, and Raquel Urtasun. Are we
ready for autonomous driving? the kitti vision benchmark
suite. In IEEE Conference on Computer Vision and Pattern
Recognition, 2012. 1

[8] Amir Ghodrati, Ali Diba, Marco Pedersoli, Tinne Tuyte-
laars, and Luc Van Gool. Deepproposal: Hunting objects by
cascading deep convolutional layers. In IEEE International
Conference on Computer Vision, 2015. 2

[9] Spyros Gidaris and Nikos Komodakis. Object detection
via a multi-region and semantic segmentation-aware cnn
model. In IEEE International Conference on Computer Vi-
sion, 2015. 2

[10] Spyros Gidaris and Nikos Komodakis. Attend reﬁne repeat:
In

Active box proposal generation via in-out localization.
British Machine Vision Conference, 2016. 6

[11] Ross Girshick. Fast r-cnn. In IEEE International Conference

on Computer Vision, 2015. 7

[12] Kaiming He, Georgia Gkioxari, Piotr Doll´ar, and Ross Gir-
In IEEE International Conference on

shick. Mask r-cnn.
Computer Vision, 2017. 2

[13] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
Deep residual learning for image recognition. In IEEE Con-
ference on Computer Vision and Pattern Recognition, 2016.
6

[14] Lichao Huang, Yi Yang, Yafeng Deng, and Yinan Yu. Dense-
box: Unifying landmark localization with end to end object
detection. arXiv preprint arXiv:1509.04874, 2015. 2, 4

[15] Zequn Jie, Xiaodan Liang, Jiashi Feng, Wen Feng Lu, Eng
Hock Francis Tay, and Shuicheng Yan. Scale-aware pixel-
wise object proposal networks. IEEE Transactions on Image
Processing, 25(10):4525–4539, 2016. 2

[16] Hongyang Li, Yu Liu, Wanli Ouyang, and Xiaogang Wang.
Zoom out-and-in network with map attention decision for re-
gion proposal and object detection. International Journal of
Computer Vision, pages 1–14, 2017. 6

[17] Xiaoxiao Li, Ziwei Liu, Ping Luo, Chen Change Loy, and
Xiaoou Tang. Not all pixels are equal: difﬁculty-aware se-
mantic segmentation via deep layer cascade. 2017. 3

[18] Tsung-Yi Lin, Piotr Dollar, Ross Girshick, Kaiming He,
Bharath Hariharan, and Serge Belongie. Feature pyramid
networks for object detection. In IEEE Conference on Com-
puter Vision and Pattern Recognition, July 2017. 2, 3, 6

[19] Tsung-Yi Lin, Priya Goyal, Ross Girshick, Kaiming He, and
Piotr Doll´ar. Focal loss for dense object detection. In IEEE
International Conference on Computer Vision, 2017. 2, 3, 5,
6, 7

[20] Tsung-Yi Lin, Michael Maire, Serge Belongie, James Hays,
Pietro Perona, Deva Ramanan, Piotr Doll´ar, and C Lawrence
Zitnick. Microsoft coco: Common objects in context.
In
European Conference on Computer Vision, 2014. 1, 5

[21] Wei Liu, Dragomir Anguelov, Dumitru Erhan, Christian
Szegedy, Scott Reed, Cheng-Yang Fu, and Alexander C
Berg. Ssd: Single shot multibox detector. In European Con-
ference on Computer Vision, 2016. 2

[22] Hsueh-Fu Lu, Xiaofei Du, and Ping-Lin Chang. Toward
scale-invariance and position-sensitive region proposal net-
works. European Conference on Computer Vision, 2018. 6

[23] Mahyar Najibi, Mohammad Rastegari, and Larry S Davis.
G-cnn: an iterative grid based object detector. In IEEE Con-
ference on Computer Vision and Pattern Recognition, pages
2369–2377, 2016. 2

[24] Pedro O. Pinheiro, Tsung-Yi Lin, Ronan Collobert, and Pi-
otr Dollr. Learning to reﬁne object segments. In European
Conference on Computer Vision, 2016. 6

[25] Joseph Redmon, Santosh Divvala, Ross Girshick, and Ali
Farhadi. You only look once: Uniﬁed, real-time object de-
tection. In IEEE Conference on Computer Vision and Pattern
Recognition, 2016. 2

[26] Joseph Redmon and Ali Farhadi. Yolo9000: Better, faster,
stronger. In IEEE Conference on Computer Vision and Pat-
tern Recognition, 2017. 2

[27] Shaoqing Ren, Kaiming He, Ross Girshick, and Jian Sun.
Faster r-cnn: Towards real-time object detection with region
proposal networks. In Advances in Neural Information Pro-
cessing Systems, 2015. 1, 2, 4, 5, 7

[28] Guanglu Song, Yu Liu, Ming Jiang, Yujie Wang, Junjie Yan,
and Biao Leng. Beyond trade-off: Accelerate fcn-based face
detector with higher accuracy. 2018. 3

[29] Lachlan Tychsen-Smith and Lars Petersson. Improving ob-
ject localization with ﬁtness nms and bounded iou loss. 2018.
5, 6

[30] Xiongwei Wu, Daoxin Zhang, Jianke Zhu, and Steven C. H.
Hoi. Single-shot bidirectional pyramid networks for high-
quality object detection, 2018. 2

[31] Bin Yang, Junjie Yan, Zhen Lei, and Stan Z. Li. Craft objects
from images. In IEEE Conference on Computer Vision and
Pattern Recognition, 2016. 2

2973

[32] Tong Yang, Xiangyu Zhang, Zeming Li, Wenqiang Zhang,
and Jian Sun. Metaanchor: Learning to detect objects with
customized anchors. In Advances in Neural Information Pro-
cessing Systems. 2018. 2

[33] Shifeng Zhang, Longyin Wen, Xiao Bian, Zhen Lei, and
Stan Z. Li. Single-shot reﬁnement neural network for ob-
ject detection. In IEEE Conference on Computer Vision and
Pattern Recognition, 2018. 2, 6

[34] Qiaoyong Zhong, Chao Li, Yingying Zhang, Di Xie, Shi-
cai Yang, and Shiliang Pu. Cascade region proposal and
global context for deep object detection.
arXiv preprint
arXiv:1710.10749, 2017. 2

2974

