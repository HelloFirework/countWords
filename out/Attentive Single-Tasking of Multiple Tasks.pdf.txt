Attentive Single-Tasking of Multiple Tasks

Kevis-Kokitsi Maninis*

Ilija Radosavovic

Iasonas Kokkinos∗

Computer Vision Lab, ETH Z¨urich

Facebook AI Research (FAIR)

Ariel AI, UCL

Abstract

Input Image

In this work we address task interference in universal
networks by considering that a network is trained on mul-
tiple tasks, but performs one task at a time, an approach
we refer to as “single-tasking multiple tasks”. The network
thus modiﬁes its behaviour through task-dependent feature
adaptation, or task attention. This gives the network the
ability to accentuate the features that are adapted to a task,
while shunning irrelevant ones. We further reduce task in-
terference by forcing the task gradients to be statistically in-
distinguishable through adversarial training, ensuring that
the common backbone architecture serving all tasks is not
dominated by any of the task-speciﬁc gradients.

Results in three multi-task dense labelling problems
(i) a large reduction in the number
consistently show:
of parameters while preserving, or even improving per-
formance and (ii) a smooth trade-off between computa-
tion and multi-task accuracy. We provide our system’s
code and pre-trained models at https://github.
com/facebookresearch/astmt.

1. Introduction

Real-world AI problems involve a multitude of visual
tasks that call for multi-tasking, universal vision systems.
For instance autonomous driving requires detecting pedes-
trians, estimating velocities and reading trafﬁc signs, while
identity recognition, pose, face and hand tracking are re-
quired for human-computer interaction.

A thread of works have introduced multi-task networks
[54, 13, 22, 28] handling an increasingly large number of
tasks. Still, it is common practice to train devoted networks
for individual tasks when single-task performance is criti-
cal. This is supported by negative results from recent works
that have aimed at addressing multiple problems with a sin-
gle network [22, 28] - these have shown that there is a limit
on performance imposed by the capacity of the network,
manifested as a drop in performance when loading a sin-
gle network with more tasks. Stronger backbones can uni-
formly improve multi-task performance, but still the per-
task performance can be lower than the single-task perfor-
mance with the same backbone.

*Work done while at Facebook AI Research.

Edge

Semantic

Detection

Segmentation

Human

Parts

Surface
Normals

Saliency 
Estimation

1
 
r
e
y
a
L

5
1
 
r
e
y
a
L

7
1
 
r
e
y
a
L

r
e
y
a

l
 
t
s
a
L

Figure 1. Learned representations across tasks and layers: We
visualize how features change spatially in different depths of our
multi-task network. For each layer (row) we compute a common
PCA basis across tasks (column) and show the ﬁrst three principal
components as RGB values at each spatial location. We observe
that the features are more similar in early layers and get more
adapted to speciﬁc tasks as depth increases, leading to disentan-
gled, task-speciﬁc representations in the later layers. We see for
instance that the normal task features co-vary with surface proper-
ties, while the part features remain constant in each human part.

This problem, known as task interference, can be under-
stood as facing a the dilemma of invariance versus sensitiv-
ity: the most crucial information for one task can be a nui-
sance parameter for another, which leads to potentially con-
ﬂicting objectives when training multi-task networks. An
example of such a task pair is pose estimation and object de-
tection: when detecting or counting people the detailed pose
information is a nuisance parameter that should be elimi-
nated at some point from the representation of a network
aiming at pose invariance [22]. At the same time, when
watching a dance performance, one needs the detailed pose
of the dancers, while ignoring the large majority of specta-
tors. More generally this is observed when combining a task

11851

RAA(.)

SEA(.)

Task Discriminator

RAB(.)

SEB(.)

*

*

LA

Task Discriminator

LB

Common Path

Task A

Task B

Gradient

Figure 2. While using a shared backbone network, every task
adapts its behavior in a separate, ﬂexible, and lightweight man-
ner, allowing us to customize computation for the task at hand.
We reﬁne features with a task-speciﬁc residual adapter branch
(RA), and attend to particular channels with task-speciﬁc Squeeze-
and-Excitation (SE) modulation. We also enforce the task gradi-
ents (dashed lines) to be statistically indistinguishable through ad-
versarial training, further promoting the separation between task-
speciﬁc and generic layers.

that is detail-oriented and requires high spatial acuity with a
task that requires abstraction from spatial details, e.g. when
one wants to jointly do low- and high-level vision. In other
words, one task’s noise is another one’s signal.

We argue that this dilemma can be addressed by single-
tasking, namely executing task a time, rather than getting all
task responses in a single forward pass through the network.
This reﬂects many practical setups, for instance when one
sees the results of a single computational photography task
at a time on the screen of a mobile phone, rather than all of
them jointly. Operating in this setup allows us to implement
an “attention to task” mechanism that changes the network’s
behaviour in a task-adapted manner, as shown in Fig. 1. We
use the exact same network backbone in all cases, but we
modify the network’s behavior according to the executed
task by relying on the most task-appropriate features. For
instance when performing a low-level task such as boundary
detection or normal estimation, the network can retain and
elaborate on ﬁne image structures, while shunning them for
a high-level task that requires spatial abstraction.

We explore two different task attention mechanisms, as
shown in Fig. 2. Firstly, we use data-dependent modulation
signals [42] that enhance or suppress neuronal activity in a
task-speciﬁc manner. Secondly, we use task-speciﬁc Resid-
ual Adapter [45] blocks that latch on to a larger architecture
in order to extract task-speciﬁc information which is fused
with the representations extracted by a generic backbone.
This allows us to learn a shared backbone representation
that serves all tasks but collaborates with task-speciﬁc pro-
cessing to build more elaborate task-speciﬁc features.

These two extensions can be understood as promoting a
disentanglement between the shared representation learned
across all tasks and the task-speciﬁc parts of the network.
Still, if the loss of a single task is substantially larger, its
gradients will overwhelm those of others and disrupt the
training of the shared representation.
In order to make
sure that no task abuses the shared resources we impose
a task-adversarial loss to the network gradients, requir-
ing that these are statistically indistinguishable across tasks.
This loss is minimized during training through double back-
propagation [10], and leads to an automatic balancing of
loss terms, while promoting compartmentalization between
task-speciﬁc and shared blocks.

2. Related Work

Our work draws ideas from several research threads.
Multiple Task Learning (MTL): Several works have
shown that jointly learning pairs of tasks yields fruitful re-
sults in computer vision. Successful pairs include detec-
tion and classiﬁcation [19, 46], detection and segmenta-
tion [22, 12], or monocular depth and segmentation [13, 59].
Joint learning is beneﬁcial for unsupervised learning [43],
when tasks provide complementary information (eg. depth
boundaries and motion boundaries [65]), in cases where
task A acts as regularizer for task B due to limited data [32],
or in order to learn more generic representations from syn-
thetic data [47]. Xiao et al. [58] unify inhomogeneous
datasets in order to train for multiple tasks, while [62]
explore relationships among a large amount of tasks for
transfer learning, reporting improvements when transfer-
ring across particular task pairs.

Despite these positive results, joint learning can be harm-
ful in the absence of a direct relationship between task pairs.
This was reported clearly in [28] where the joint learning of
low-, mid- and high-level tasks was explored, reporting that
the improvement of one task (e.g. normal detection) was to
the detriment of another (e.g. object detection). Similarly,
when jointly training for human pose estimation on top of
detection and segmentation, Mask R-CNN performs worse
than its two-task counterpart [22].

This negative result ﬁrst requires carefully calibrating the
relative losses of the different tasks, so that none of them
deteriorates excessively. To address this problem, Grad-
Norm [8] provides a method to adapt the weights such
that each task contributes in a balanced way to the loss,
by normalizing the gradients of their losses; a more recent
work [56] extends this approach to homogenize the task
gradients based on adversarial training. Following a proba-
bilistic treatment [25] re-weigh the losses according to each
task’s uncertainty, while Sener and Koltun [53] estimate an
adaptive weighting of the different task losses based on a
pareto-optimal formulation of MTL. Similarly, [20] provide
a MTL framework where tasks are dynamically sorted by

1852

difﬁculty and the hardest are learned ﬁrst.

A second approach to mitigate task interference consists
in avoiding the ‘spillover’ of gradients from one task’s loss
to the common features serving all tasks. One way of doing
this is explicitly constructing complementary task-speciﬁc
feature representations [51, 49], but results in an increase of
complexity that is linear in the number of tasks. An alter-
native, adopted in the related problem of lifelong learning
consists in removing from the gradient of a task’s loss those
components that would incur an increase in the loss of pre-
vious tasks [26, 33]. For domain adaptation [4] disentangle
the representations learned by shared/task-speciﬁc parts of
networks by enforcing similarity/orthogonality constraints.
Adversarial Training has been used in the context of domain
adaptation [17, 32] to the feature space in order to fool the
discriminator about the source domain of the features.

In our understanding these losses promote a compart-
mental operation of a network, achieved for instance when
a block-structured weight matrix prevents the interference
of features for tasks that should not be connected. A
deep single-task implementation of this would be the gat-
ing mechanism of [1]. For multi-tasking, Cross Stitch Net-
works [38] automatically learn to split/fuse two indepen-
dent networks in different depths according to their learned
tasks, while [40] estimate a block-structured weight matrix
during CNN training.

Attention mechanisms: Attention has often been used
in deep learning to visualize and interpret the inner work-
ings of CNNs [55, 63, 52], but has also been employed
to improve the learned representations of convolutional
networks for scale-aware semantic segmentation [5], ﬁne-
grained image recognition [16] or caption generation [60,
34, 2]. Squeeze and Excitation Networks [24] and their
variants [57, 23] modulate the information of intermedi-
ate spatial features according to a global representation and
be understood as implementing attention to different chan-
nels. Deep Residual Adapters [44, 45] modulate learned
representations depending on their source domain. Several
works study modulation for image retrieval [64] or classiﬁ-
cation tasks [42, 39], and embeddings for different artistic
styles [11]. [61] learns object-speciﬁc modulation signals
for video object segmentation, and [48] modulates features
according to given priors for detection and segmentation. In
our case we learn task-speciﬁc modulation functions that al-
low us to drastically change the network’s behaviour while
using identical backbone weights.

3. Attentive Single-Tasking Mechanisms

Having a shared representation for multiple tasks can
be efﬁcient from the standpoint of memory- and sample-
complexity, but can result in worse performance if the same
resources are serving tasks with unrelated, or even conﬂict-
ing objectives, as described above. Our proposed remedy to

SE(.)

pool

Bottleneck

SE-ResNet Block

Skip Connection

ASPP

Encoder

SE-ResNet

Block

Decoder

Figure 3. Single-task network architecture: We use Deeplab-
v3+ with a Squeeze-and-Excitation (SE)-ResNet backbone. SE
modules are present in all bottleneck blocks of the encoder and
the decoder. Attentive multi-tasking uses different SE layers per
task to modulate the network features in a task-speciﬁc manner.

this problem consists in learning a shared representation for
all tasks, while allowing each task to use this shared repre-
sentation differently for the construction of its own features.

3.1. Task speciﬁc feature modulation

In order to justify our approach we start with a minimal
example. We consider that we have two tasks A and B that
share a common feature tensor F(x, y, c) at a given network
layer, where x, y are spatial coordinates and c = 1, . . . , C
are the tensor channels. We further assume that a subset
SA of the channels is better suited for task A, while SB is
better for B. For instance if A is invariant to deformations
(detection) while B is sensitive (pose estimation), SA could
be features obtained by taking more context into account,
while SB would be more localized.

One simple way of ensuring that tasks A and B do not
interfere while using a shared feature tensor is to hide the
features of task B when training for task A:

FA(x, y, c) = mA[c] · F(x, y, c)

(1)

∂LA

where mA[c] ∈ {0, 1} is the indicator function of set SA. If
c /∈ SA then FA(x, y, c) = 0, which means that the gradient
∂F(x,y,c) sent by the loss LA of task A to c ∈ SA will be
zero. We thereby avoid task interference since Task A does
not inﬂuence nor use features that it does not need.

Instead of this hard choice of features per task we opt for
a soft, differentiable membership function that is learned in
tandem with the network and allows the different tasks to
discover during training which features to use. Instead of
a constant membership function per channel we opt for an
image-adaptive term that allows one to exploit the power of
the squeeze-and-excitation block [24].

1853

In particular we adopt the squeeze-and-excitation (SE)
block (also shown in Fig. 2), combining a global aver-
age pooling operation of the previous layer with a fully-
connected layer that feeds into a sigmoid function, yielding
a differentiable, image-dependent channel gating function.
We set the parameters of this layer to be task-dependent, al-
lowing every task to modulate the available channels differ-
ently. As shown in Section 5, this can result in substantial
improvements when compared to a baseline that uses the
same SE block for all tasks.

3.2. Residual Adapters

The feature modulation described above can be under-
stood as shunning those features that do not contribute to
the task while focusing on the more relevant ones.
Intu-
itively, this does not add capacity to the network but rather
cleans the signal that ﬂows through it from information that
the task should be invariant to. We propose to complement
this by appending task-speciﬁc sub-networks that adapt and
reﬁne the shared features in terms of residual operations of
the following form:

LA(x) = x + L(x) + RAA(x),

(2)

where L(x) denotes the default behaviour of a residual
layer, RAA is the task-speciﬁc residual adapter of task A,
and LA(x) is the modiﬁed layer. We note that if L(x) and
RAA(x) were linear layers this would amount to the classi-
cal regularized multi-task learning of [15].

These adapters introduce a task-speciﬁc parameter and
computation budget that is used in tandem with that of the
shared backbone network. We show in Section 5 that this is
typically a small fraction of the budget used for the shared
network, but improves accuracy substantially.

When employing disentangled computation graphs with
feature modulation through SE modules and/or residual
adapters, we also use task-speciﬁc batch-normalization lay-
ers, that come with a trivial increase in parameters (while
the computational cost remains the same).

4. Adversarial Task Disentanglement

The idea behind the task-speciﬁc adaptation mechanisms
described above is that even though a shared representation
has better memory/computation complexity, every task can
proﬁt by having its own ‘space’, i.e. separate modelling ca-
pacity to make the best use of the representation - by mod-
ulating the features or adapting them with residual blocks.

Pushing this idea further we enforce a strict separation
of the shared and task-speciﬁc processing, by requiring that
the gradients used to train the shared parameters are statis-
tically indistinguishable across tasks. This ensures that the
shared backbone serves all tasks equally well, and is not
disrupted e.g. by one task that has larger gradients.

x

y=Ax

A

L(y)

dy: ∂L/∂y

dA=xTg

dx=gAT

g=dy

forward pass

backward pass

x

x

A

A

y=Ax

L(y)

g=dy

dA=xTg

dx=gAT

y=Ax

L(y)

g=dy

h=D(g)

LD(h)

•(-λ)

-λ • ∂LD/∂h

∂LD/∂h

Figure 4. Double backprop [10] exposes the gradients computed
during backprop (row 1) by unfolding the computation graph of
gradient computation (row 2). Exposing the gradients allows us
to train them in an adversarial setting by using a discriminator,
forcing them to be statistically indistinguishable across tasks (row
3). The shared network features x then receive gradients that have
the same distribution irrespective of the task, ensuring that no task
abuses the shared network, e.g. due to higher loss magnitude. The
gradient of the discriminator is reversed (negated) during adver-
sarial training, and the parameter λ ∈ [0, 1] controls the amount
of negative gradient that ﬂows back to the network [17].

Database
PASCAL
NYUD
FSV

Type
Real
Real

# Train Im.

# Test Im.

Edge

S.Seg H. Parts Normals

Saliency Depth Albedo

4,998
795

5,105
654

50,080

X

X

X

X

X

X

X∗

X

X∗

X

X

X

Synthetic

223,197

Table 1. Multi-task benchmark statistics: We conduct the main
volume of experiments on PASCAL for 5 tasks (∗ labels obtained
via distillation). We also use the fully labelled subsets of NYUD,
and the synthetic FSV dataset.

We enforce this constraint through adversarial learning.
Several methods, starting from Adversarial Domain Adap-
tation [18], use adversarial learning to remove any trace of
a given domain from the learned mid-level features in a
network; a technique called Adversarial multi-task training
[32] falls in the same category.

Instead of removing domain-speciﬁc information from
the features of a network (which serves domain adaptation),
we remove any task-speciﬁc trace from the gradients sent
from different tasks to the shared backbone (which serves
a division between shared and task-speciﬁc processing). A
concurrent work [56] has independently proposed this idea.
As shown in Fig. 4 we use double back-propagation [10]
to ‘expose’ the gradient sent from a task t to a shared layer
l, say gt(l). By exposing the variable we mean that we un-
fold its computation graph, which in turn allows us to back-
propagate through its computation. By back-propagating on
the gradients we can force them to be statistically indistin-
guishable across tasks through adversarial training.

In particular we train a task classiﬁer on top of the gra-
dients lying at the interface of the task-speciﬁc and shared
networks and use sign negation to make the task classiﬁer
fail [17]. This amounts to solving the following optimiza-

1854

strong baseline

SE-bb #T Edge ↑ Seg ↑ Parts ↑ Norm ↓ Sal ↑

Task
Edge
S.Seg
H. Parts
Normals
Saliency
Depth

VOC

Dataset

BSDS500

Metric
odsF ↑
mIoU ↑
mIoU ↑
mErr ↓
PASCAL-S maxF ↑
RMSE ↓

P. Context

NYUD

NYUD

R-101
82.5
78.9
64.3
20.1
84.0
0.56

81.3 [27]
79.4 [6]
64.9* [5]
19.0 [3]
83.5 [28]
0.58 [59]

Table 2. Architecture capacity: We report upper-bounds of per-
formance that can be reached on various competitive (but inhomo-
geneous) datasets by our architecture, and compare to strong task-
speciﬁc baselines. All experiments are initialized from ImageNet
pre-trained weights (∗ means that COCO pre-training is included).
The arrow indicates better performance for each metric.

tion problem in terms of the discriminator weights, wD and
the network weights, wN :

minwD maxwN L(D(gt(wN ), wD), t),

(3)

where gt(wN ) is the gradient of task t computed with wN ,
D(·, wD) is the discriminator’s output for input ·, and L(·, t)
is the cross-entropy loss for label t that indicates the source
task of the gradient.

Intuitively this forces every task to do its own process-
ing within its own blocks, so that it does not need from the
shared network anything different from the other tasks. This
results in a separation of the network into disentangled task-
speciﬁc and shared compartments.

5. Experimental Evaluation

Datasets We validate our approach on different datasets
and tasks. We focus on dense prediction tasks that can be
approached with fully convolutional architectures. Most of
the experiments are carried out on the PASCAL [14] bench-
mark, which is popular for dense prediction tasks. We also
conduct experiments on the smaller NYUD [41] dataset of
indoor scenes, and the recent, large scale FSV [29] dataset
of synthetic images. Statistics, as well as the different tasks
used for each dataset are presented in Table 1.

Base architecture: We use our re-implementation of
Deeplab-v3+ [6] as the base architecture of our method,
due to its success on dense semantic tasks. Its architecture
is based on a strong ResNet encoder, with a-trous convo-
lutions to preserve reasonable spatial dimensions for dense
prediction. We use the latest version that is enhanced with
a parallel a-trous pyramid classiﬁer (ASPP) and a power-
ful decoder. We refer the reader to [6] for more details.
The ResNet-101 backbone used in the original work is re-
placed with its Squeeze-and-Excitation counterpart (Fig. 3),
pre-trained on ImageNet [50]. The pre-trained SE modules
serve as an initialization point for the task-speciﬁc modula-
tors for multi-tasking experiments.

The architecture is tested for a single task in various
competitive benchmarks for dense prediction: edge de-
tection, semantic segmentation, human part segmentation,

1
1
5
5

70.3
71.3
68.0
69.2

63.98
64.93
58.59
60.20

55.85
57.12
53.80
54.10

15.11
14.90
16.68
17.04

63.92
64.17
60.71
62.10

X

X

(a) Baselines. Using SE blocks in ResNet backbones (SE-bb) improves
results. In all our experiments we use SE-bb baselines for fair comparison.

SE RA #T Edge ↑ Seg ↑ Parts ↑ Norm ↓ Sal ↑ ∆m% ↓

1
5
X 5
5

71.3
69.2
70.5
71.1

64.93
60.20
62.80
64.00

57.12
54.10
56.41
56.84

14.90
17.04
15.27
15.05

64.17
62.10
64.84
64.35

X

6.62
1.42
0.59

(b) Modulation. Both SE and RA are effective modulation methods.

enc dec #T Edge ↑ Seg ↑ Parts ↑ Norm ↓ Sal ↑ ∆m% ↓

1
5
X 5
X X 5

71.3
69.2
70.6
71.1

64.93
60.20
63.33
64.00

57.12
54.10
56.73
56.84

14.90
17.04
15.14
15.05

64.17
62.1
63.23
64.35

6.62
1.44
0.59

(c) SE modulation. Modulating varying portions of the network (e.g. en-
coder or decoder) allows trading off performance and computation.

mod A #T Edge ↑ Seg ↑ Parts ↑ Norm ↓ Sal ↑ ∆m% ↓

1
5
X 5
5
X X 5

X

71.3
69.2
69.7
71.1
71.0

64.93
60.20
62.20
64.00
64.61

57.12
54.10
55.04
56.84
57.25

14.90
17.04
16.17
15.05
15.00

64.17
62.10
62.19
64.35
64.70

6.62
4.34
0.59
0.11

(d) Adversarial training is beneﬁcial both w/ and w/o SE modulation.

backbone SEA #T Edge ↑ Seg ↑ Parts ↑ Norm ↓ Sal ↑ ∆m% ↓
R-26
R-26
R-26
R-50
R-50
R-50
R-101
R-101
R-101

1
5
X 5
1
5
X 5
1
5
X 5

64.93
60.20
64.61
68.30
63.20
68.00
69.76
66.45
68.51

57.12
54.10
57.25
60.70
55.10
61.12
63.48
61.54
63.41

14.90
17.04
15.00
14.61
16.04
14.68
14.15
15.44
14.37

64.17
62.10
64.70
65.40
63.60
65.71
67.41
66.39
67.72

71.3
69.2
71.0
72.7
69.2
72.4
73.5
70.5
73.5

4.50
0.60

6.81
0.04

6.62
0.11

(e) Backbones. Improvements from SE modulation with adversarial train-
ing (SEA) are observed regardless of the capacity/depth of the backbones.

Table 3. Ablations on PASCAL. We report average relative per-
formance drop (∆m%) with respect to single task baselines. Back-
bone is R-26 unless otherwise noted.

surface normal estimation, saliency, and monocular depth
estimation. We compare the results obtained with vari-
ous competitive architectures. For edge detection we use
the BSDS500 [37] benchmark and its optimal dataset F-
measure (odsF) [36]. For semantic segmentation we train
on PASCAL VOC trainaug [14, 21] (10582 images),
and evaluate on the validation set of PASCAL using mean
intersection over union (mIoU). For human part segmenta-
tion we use PASCAL-Context [7] and mIoU. For surface
normals we train on the raw data of NYUD [41] and evalu-
ate on the test set using mean error (mErr) in the predicted

1855

Figure 5. Performance vs. Resources: Average relative drop (∆m%) as a function of the number of parameters (left), and multiply-adds
(right), for various points of operation of our method. We compare 3 different backbone architectures, indicated with different colors.
We compare against single-tasking baseline (ST baseline), and multi-tasking baseline (MT baseline). Performance is measured relative to
the best single-tasking model (R-101 backbone). An increase in performance comes for free with adversarial training (Adv). Modulation
per task (SE) results in large improvements in performance, thanks to the disentangled graph representations, albeit with an increase in
computational cost if used throughout the network, instead of only on the decoder (SE Dec-only vs. SE). We observe a drastic drop in
number of parameters needed for our model in order to reach the performance of the baseline (SE, Adv). By using both modulation and
adversarial training (Adv SE RA), we are able to reach single-task performance, with far fewer parameters.

SEA #T Edge ↑

Seg ↑ Norm ↓ Depth ↓ ∆m% ↓

1
4
X 4

74.4
73.2
74.5

32.82
30.95
32.16

23.30
23.34
23.18

0.61
0.70
0.57

5.44
-1.22

(a) Results on NYUD-v2.

SEA #T

Seg ↑ Albedo ↓ Disp ↓ ∆m% ↓

1
3
X 3

71.2
66.9
70.7

0.086
0.093
0.085

0.063
0.078
0.063

7.04
-0.02

(b) Results on FSV.

Table 4. Improvements from SE with modulation (SEA) transfer
to NYUD-v2 and FSV datasets. We report average performance
drop with respect to single task baselines. We use R-50 backbone.

angles as the evaluation metric. For saliency we follow [28]
by training on MSRA-10K [9], testing on PASCAL-S [31]
and using the maximal F-measure (maxF) metric. Finally,
for depth estimation we train and test on the fully anno-
tated training set of NYUD using root mean squared error
(RMSE) as the evaluation metric. For implementation de-
tails, and hyper-parameters, please refer to the Appendix.

Table 2 benchmarks our architecture against popular
state-of-the-art methods. We obtain competitive results,
for all tasks. We emphasize that these benchmarks are
inhomogeneous, i.e.
their images are not annotated with
all tasks, while including domain shifts when training for
multi-tasking (eg. NYUD contains only indoor images). In
order to isolate performance gains/drops as a result of multi-
task learning (and not domain adaptation, or catastrophic
forgetting), in the experiments that follow, we use homoge-
neous datasets.

Multi-task learning setup: We proceed to multi-tasking

experiments on PASCAL. We keep the splits of PASCAL-
Context, which provides labels for edge detection, seman-
tic segmentation, and human part segmentation.
In or-
der to keep the dataset homogeneous and the architec-
ture identical for all tasks, we did not use instance level
tasks (detection, pose estimation) that are provided with
the dataset. To increase the number of tasks we auto-
matically obtained ground-truth for surface normals and
saliency through label-distillation using pre-trained state-
of-the-art models ([3] and [6], respectively), since PAS-
CAL is not annotated with those tasks. For surface nor-
mals, we masked out predictions from unknown and/or in-
valid classes (eg. sky) during both training and testing. In
short, our benchmark consists of 5 diverse tasks, ranging
from low-level (edge detection, surface normals), to mid-
level (saliency) and high-level (semantic segmentation, hu-
man part segmentation) tasks.

Evaluation metric: We compute multi-tasking perfor-
mance of method m as the average per-task drop with re-
spect to the single-tasking baseline b (i.e different networks
trained for a single task each):

∆m =

1
T

T

X

i=1

(−1)li (Mm,i − Mb,i) /Mb,i

(4)

where li = 1 if a lower value means better for measure Mi
of task i, and 0 otherwise. Average relative drop is com-
puted against the baseline that uses the same backbone.

To better understand the effect of different aspects of
our method, we conduct a number of ablation studies and
present the results in Table 3.

1856

Figure 6. t-SNE visualization of task-dependent feature activations of a single image at increasing depths of the network (from left to
right). Features in early layers are more similar across tasks and progressively get more adapted to speciﬁc tasks in later layers.

We construct a second baseline, which tries to learn all
tasks simultaneously with a single network, by connecting
T task-speciﬁc convolutional classiﬁers (1 × 1 conv lay-
ers) at the end of the network. As also reported by [28], a
non-negligible average performance drop can be observed
(-6.6% per task for R-26 with SE). We argue that this drop
is mainly triggered by conﬂicting gradients during learning.
Effects of modulation and adversarial training: Next,
we introduce the modulation layers described in Section 3.
We compare parallel residual adapters to SE (Table 3b)
when used for task modulation. Performance per task re-
covers immediately by separating the computation used by
each task during learning (-1.4 and -0.6 vs. -6.6 for adapters
and SE, respectively). SE modulation results in better per-
formance, while using slightly fewer parameters per task.
We train a second variant where we keep the computation
graph identical for all tasks in the encoder, while using SE
modulation only in the decoder (Table 3c).
Interestingly,
this variant reaches the performance of residual adapters (-
1.4), while being much more efﬁcient in terms of number
of parameters and computation, as only one forward pass of
the encoder is necessary for all tasks.

In a separate experiment, we study the effects of adver-
sarial training described in Section 4. We use a simple, fully
convolutional discriminator to classify the source of the gra-
dients. Results in Table 3d show that adversarial training is
beneﬁcial for multi-tasking, increasing performance com-
pared to standard multi-tasking (-4.4 vs -6.6). Even though
the improvements are less signiﬁcant compared to modula-
tion, they come without extra parameters or computational
cost, since the discriminator is used only during training.

The combination of SE modulation with adversarial
training (Table 3d) leads to additional improvements (-0.1%
worse than the single-task baseline), while further adding
residual adapters surpasses single-tasking (+0.45%), at the
cost of 12.3% more parameters per task (Fig. 5).

Deeper Architectures: Table 3e shows how modulation
and adversarial training perform when coupled with deeper
architectures (R-50 and R-101). The results show that our
method is invariant to the depth of the backbone, consis-

tently improving the standard multi-tasking results.

Resource Analysis: Figure 5 illustrates the performance
of each variant as a function of the number of parameters, as
well as the FLOPS (multiply-adds) used during inference.
We plot the relative average per-task performance compared
to the single-tasking R-101 variant (blue cross), for the 5
tasks of PASCAL. Different colors indicate different back-
bone architectures. We see a clear drop in performance by
standard multi-tasking (crosses vs. circles), but with fewer
parameters and FLOPS. Improvements due to adversarial
training come free of cost (triangles) with only a small over-
head for the discriminator during training.

Including modulation comes with signiﬁcant improve-
ments, but also with a very slight increase of parameters and
a slight increase of computational cost when including the
modules on the decoder (rectangles). The increase becomes
more apparent when including those modules in the encoder
as well (diamonds). Our most accurate variant using all of
the above (hexagons) outperforms the single-tasking base-
lines by using only a fraction of their parameters.

We note that the memory and computational complex-
ities of the SE blocks and the adapters are negligible, but
since it affects the outputs of the layer it means that we can-
not share the computation of the ensuing layers across all
tasks, and thus the increased number of multiply-adds.

Learned Disentangled Representations:

In order to
highlight the importance of task modulation, we plot the
learned representations for different tasks in various depths
of our network. Figure 6 shows the t-SNE representa-
tions [35] of the SE activations in equally spaced levels of
the network. The activations are averaged for the ﬁrst 32
samples of the validation set, following [24], and they are
sorted per task. The resulting plots show that in the early
stages of the network the learned representations are almost
identical. They gradually become increasingly different as
depth grows, until they are completely different for differ-
ent tasks at the level of the classiﬁer. We argue that this
disentanglement of learned representations also translates
to performance gains, as shown in Table 3.

Validation on additional datasets: We validate our

1857

Edge DetectionSemantic SegmentationHuman PartsSurface NormalsSaliency EstimationInput Image

Edge Detection

Semantic Segmentation

Human Parts

Surface Normals

Saliency Estimation

s
r
u
O

e
n
i
l
e
s
a
B

Figure 7. Qualitative Results on PASCAL: We compare our model against standard multi-tasking. For the baseline, features from edge
detection appear in saliency estimation results, indicating the need to disentangle the learned representations.

Input Image

Edge Detection

Semantic Segmentation

Surface Normals

Monocular Depth

s
r
u
O

e
n
i
l
e
s
a
B

Figure 8. Qualitative Results on NYUD: We compare our model against standard multi-tasking. The baseline predicts blurry edges and
depth, as well as inconsistent labels on the pillow (where surface normals change). Our method is able to recover from these issues.

approach in two additional datasets, NYUD [41] and
FSV [29]. NYUD is an indoor dataset, annotated with la-
bels for instance edge detection, semantic segmentation into
41 classes, surface normals, and depth. FSV is a large-scale
synthetic dataset, labelled with semantic segmentation (3
classes), albedo, and depth (disparity).

Table 4 presents our ﬁndings for both datasets. As in
PASCAL, when we try to learn all tasks together, we ob-
serve a non-negligible drop compared to the single-tasking
baseline. Performance recovers when we plug in modula-
tion and adversarial training. Interestingly, in NYUD and
FSV we observe larger improvements compared to PAS-
CAL. Our ﬁndings are consistent with related works [59,
13] which report improved results for multi-tasking when
using depth and semantics.

Figures 7 and 8 illustrate some qualitative examples, ob-
tained by our method on PASCAL and NYUD, respectively.
Results in each row are obtained with a single network.
We compare our best model to the baseline architecture for
multi-tasking (without per-task modulation, or adversarial
training). We observe a quality degradation in the results of
the baseline. Interestingly, some errors are obtained clearly
as a result of standard multi-tasking. Edge features appear

during saliency estimation in Fig 7, and predicted seman-
tic labels change on the pillows, in areas where the surface
normals change, in Fig 8. In contrast, our method provides
disentangled predictions that are able to recover from such
issues, reach, and even surpass the single-tasking baselines.

6. Conclusions

In this work we have shown that we can attain, and
even surpass single-task performance through multi-task
networks, provided we execute one task at a time. We have
achieved this by introducing a method that allows a network
to ‘focus’ on the task at hand in terms of task-speciﬁc fea-
ture modulation and adaptation.

In a general vision architecture one can think of task
attention as being determined based on the operation cur-
rently being performed - e.g. using object detection to ﬁnd
an object, normal estimation and segmentation to grasp it.
Tasks can also be executed in an interleaved manner, with
low-level tasks interacting with high-level ones in a bottom-
up/top-down cascade [30]. We intend to explore these direc-
tions in future research.

1858

References

[1] K. Ahmed and L. Torresani. Maskconnect: Connectivity

learning by gradient descent. In ECCV, 2018. 3

[2] P. Anderson, X. He, C. Buehler, D. Teney, M. Johnson,
S. Gould, and L. Zhang. Bottom-up and top-down atten-
tion for image captioning and visual question answering. In
CVPR, 2018. 3

[3] A. Bansal, X. Chen, B. Russell, A. Gupta, and D. Ramanan.
Pixelnet: Representation of the pixels, by the pixels, and for
the pixels. arXiv:1702.06506, 2017. 5, 6

[4] K. Bousmalis, G. Trigeorgis, N. Silberman, D. Krishnan, and

D. Erhan. Domain separation networks. In NIPS, 2016. 3

[5] L.-C. Chen, G. Papandreou, I. Kokkinos, K. Murphy, and
A. L. Yuille. Deeplab: Semantic image segmentation with
deep convolutional nets, atrous convolution, and fully con-
nected CRFs. T-PAMI, 2017. 3, 5

[6] L.-C. Chen, Y. Zhu, G. Papandreou, F. Schroff, and H. Adam.
Encoder-decoder with atrous separable convolution for se-
mantic image segmentation. In ECCV, 2018. 5, 6

[7] X. Chen, R. Mottaghi, X. Liu, S. Fidler, R. Urtasun, and
A. Yuille. Detect what you can: Detecting and representing
objects using holistic models and body parts. In CVPR, 2014.
5

[8] Z. Chen, V. Badrinarayanan, C.-Y. Lee, and A. Rabinovich.
Gradnorm: Gradient normalization for adaptive loss balanc-
ing in deep multitask networks. arXiv:1711.02257, 2018. 2
[9] M.-M. Cheng, N. J. Mitra, X. Huang, P. H. Torr, and S.-M.
Hu. Global contrast based salient region detection. T-PAMI,
37(3):569–582, 2015. 6

[10] H. Drucker and Y. Le Cun. Double backpropagation increas-

ing generalization performance. In IJCNN, 1991. 2, 4

[11] V. Dumoulin, J. Shlens, and M. Kudlur. A learned represen-

tation for artistic style. In ICLR, 2017. 3

[12] N. Dvornik, K. Shmelkov, J. Mairal, and C. Schmid.
Blitznet: A real-time deep network for scene understanding.
In ICCV, 2017. 2

[13] D. Eigen and R. Fergus. Predicting depth, surface normals
and semantic labels with a common multi-scale convolu-
tional architecture. In ICCV, 2015. 1, 2, 8

[14] M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and
A. Zisserman. The PASCAL Visual Object Classes Chal-
lenge 2012 (VOC2012) Results. 5

[15] T. Evgeniou and M. Pontil. Regularized multi–task learning.

In KDD, 2004. 4

[16] J. Fu, H. Zheng, and T. Mei. Look closer to see better: Recur-
rent attention convolutional neural network for ﬁne-grained
image recognition. In CVPR, 2017. 3

[17] Y. Ganin and V. Lempitsky. Unsupervised domain adaptation

by backpropagation. In ICML, 2015. 3, 4

[18] Y. Ganin, E. Ustinova, H. Ajakan, P. Germain, H. Larochelle,
F. Laviolette, M. Marchand, and V. Lempitsky. Domain-
adversarial training of neural networks. In JMLR, 2016. 4

[19] R. Girshick. Fast R-CNN. In ICCV, 2015. 2
[20] M. Guo, A. Haque, D.-A. Huang, S. Yeung, and L. Fei-Fei.
Dynamic task prioritization for multitask learning. In ECCV,
2018. 2

[21] B. Hariharan, P. Arbel´aez, L. Bourdev, S. Maji, and J. Malik.
Semantic contours from inverse detectors. In ICCV, 2011. 5
[22] K. He, G. Gkioxari, P. Doll´ar, and R. Girshick. Mask R-

CNN. In ICCV, 2017. 1, 2

[23] J. Hu, L. Shen, S. Albanie, G. Sun, and A. Vedaldi. Gather-
excite: Exploiting feature context in convolutional neural
networks. arXiv:1810.12348, 2018. 3

[24] J. Hu, L. Shen, and G. Sun. Squeeze-and-excitation net-

works. In CVPR, 2018. 3, 7

[25] A. Kendall, Y. Gal, and R. Cipolla. Multi-task learning using
uncertainty to weigh losses for scene geometry and seman-
tics. In CVPR, 2018. 2

[26] J. Kirkpatrick, R. Pascanu, N. Rabinowitz, J. Veness, G. Des-
jardins, A. A. Rusu, K. Milan, J. Quan, T. Ramalho,
A. Grabska-Barwinska, et al. Overcoming catastrophic for-
getting in neural networks. Proceedings of the national
academy of sciences, 114(13):3521–3526, 2017. 3

[27] I. Kokkinos. Pushing the boundaries of boundary detection

using deep learning. In ICLR, 2016. 5

[28] I. Kokkinos. UberNet: Training a universal convolutional
neural network for low-, mid-, and high-level vision using
diverse datasets and limited memory. In CVPR, 2017. 1, 2,
5, 6, 7

[29] P. Kr¨ahenb¨uhl. Free supervision from video games.

In

CVPR, 2018. 5, 8

[30] T. S. Lee and D. Mumford. Hierarchical bayesian inference
in the visual cortex. J. Opt. Soc. Am. A, 20(7):1434–1448,
Jul 2003. 8

[31] Y. Li, X. Hou, C. Koch, J. M. Rehg, and A. L. Yuille. The

secrets of salient object segmentation. In CVPR, 2014. 6

[32] P. Liu, X. Qiu, and X. Huang. Adversarial multi-task learn-

ing for text classiﬁcation. In ACL, 2017. 2, 3, 4

[33] D. Lopez-Paz and M. Ranzato. Gradient episodic memory

for continual learning. In NIPS, 2017. 3

[34] J. Lu, J. Yang, D. Batra, and D. Parikh. Hierarchical
question-image co-attention for visual question answering.
In NIPS, 2016. 3

[35] L. v. d. Maaten and G. Hinton. Visualizing data using t-sne.

JMLR, 9(Nov):2579–2605, 2008. 7

[36] D. Martin, C. Fowlkes, and J. Malik. Learning to detect nat-
ural image boundaries using local brightness, color, and tex-
ture cues. T-PAMI, 26(5):530–549, 2004. 5

[37] D. Martin, C. Fowlkes, D. Tal, and J. Malik. A database
of human segmented natural images and its application to
evaluating segmentation algorithms and measuring ecologi-
cal statistics. In ICCV, 2001. 5

[38] I. Misra, A. Shrivastava, A. Gupta, and M. Hebert. Cross-

stitch networks for multi-task learning. In CVPR, 2016. 3

[39] P. K. Mudrakarta, M. Sandler, A. Zhmoginov,

and
A. Howard. K for the price of 1: Parameter efﬁcient multi-
task and transfer learning. In ICLR, 2019. 3

[40] C. Murdock, Z. Li, H. Zhou, and T. Duerig. Blockout: Dy-
In

namic model selection for hierarchical deep networks.
CVPR, 2016. 3

[41] P. K. Nathan Silberman, Derek Hoiem and R. Fergus. Indoor
segmentation and support inference from RGBD images. In
ECCV, 2012. 5, 8

1859

[42] E. Perez, F. Strub, H. De Vries, V. Dumoulin, and
A. Courville. FiLM: Visual reasoning with a general con-
ditioning layer. arXiv:1709.07871, 2017. 2, 3

[61] L. Yang, Y. Wang, X. Xiong, J. Yang, and A. K. Katsaggelos.
Efﬁcient video object segmentation via network modulation.
In CVPR, 2018. 3

[43] A. Ranjan, V. Jampani, K. Kim, D. Sun, J. Wulff, and M. J.
Black. Adversarial collaboration: Joint unsupervised learn-
ing of depth, camera motion, optical ﬂow and motion seg-
mentation. arXiv:1805.09806, 2018. 2

[62] A. R. Zamir, A. Sax, W. Shen, L. Guibas, J. Malik, and
S. Savarese. Taskonomy: Disentangling task transfer learn-
ing. In CVPR, 2018. 2

[63] M. D. Zeiler and R. Fergus. Visualizing and understanding

[44] S.-A. Rebufﬁ, H. Bilen, and A. Vedaldi. Learning multiple

convolutional networks. In ECCV, 2014. 3

visual domains with residual adapters. In NIPS, 2017. 3

[45] S.-A. Rebufﬁ, H. Bilen, and A. Vedaldi.

parametrization of multi-domain deep neural networks.
CVPR, 2018. 2, 3

Efﬁcient
In

[46] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: To-
wards real-time object detection with region proposal net-
works. In NIPS, 2015. 2

[47] Z. Ren and Y. J. Lee. Cross-domain self-supervised multi-
In CVPR,

task feature learning using synthetic imagery.
2018. 2

[48] A. Rosenfeld, M. Biparva, and J. K. Tsotsos. Priming neural

networks. arXiv, 2018. 3

[49] A. Rosenfeld and J. K. Tsotsos. Incremental learning through

deep adaptation. T-PAMI, 2018. 3

[50] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh,
S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,
A. C. Berg, and L. Fei-Fei.
ImageNet Large Scale Visual
Recognition Challenge. IJCV, 2015. 5

[51] A. A. Rusu, N. C. Rabinowitz, G. Desjardins, H. Soyer,
J. Kirkpatrick, K. Kavukcuoglu, R. Pascanu, and R. Hadsell.
Progressive neural networks. arXiv:1606.04671, 2016. 3

[52] R. R. Selvaraju, M. Cogswell, A. Das, R. Vedantam,
D. Parikh, D. Batra, et al. Grad-CAM: Visual explana-
tions from deep networks via gradient-based localization. In
ICCV, 2017. 3

[53] O. Sener and V. Koltun. Multi-task learning as multi-

objective optimization. In NIPS, 2018. 2

[54] P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus,
and Y. LeCun. Overfeat: Integrated recognition, localization
and detection using convolutional networks. In ICLR, 2014.
1

[55] K. Simonyan, A. Vedaldi, and A. Zisserman. Deep in-
side convolutional networks: Visualising image classiﬁca-
tion models and saliency maps. arXiv:1312.6034, 2013. 3

[56] A. Sinha, Z. Chen, V. Badrinarayanan, and A. Rabi-
novich. Gradient adversarial training of neural networks.
arXiv:1806.08028, 2018. 2, 4

[57] S. Woo, J. Park, J.-Y. Lee, and I. S. Kweon. CBAM: Convo-

lutional block attention module. In ECCV, 2018. 3

[58] T. Xiao, Y. Liu, B. Zhou, Y. Jiang, and J. Sun. Uniﬁed per-
ceptual parsing for scene understanding. In ECCV, 2018. 2
[59] D. Xu, W. Ouyang, X. Wang, and N. Sebe. PAD-Net: Multi-
tasks guided prediction-and-distillation network for simulta-
neous depth estimation and scene parsing. In CVPR, 2018.
2, 5, 8

[60] K. Xu, J. Ba, R. Kiros, K. Cho, A. Courville, R. Salakhudi-
nov, R. Zemel, and Y. Bengio. Show, attend and tell: Neural
image caption generation with visual attention.
In ICML,
2015. 3

[64] X. Zhao, H. Li, X. Shen, X. Liang, and Y. Wu. A modulation
module for multi-task learning with applications in image
retrieval. In ECCV, 2018. 3

[65] Y. Zou, Z. Luo, and J.-B. Huang. DF-Net: Unsupervised
joint learning of depth and ﬂow using cross-task consistency.
In ECCV, 2018. 2

1860

