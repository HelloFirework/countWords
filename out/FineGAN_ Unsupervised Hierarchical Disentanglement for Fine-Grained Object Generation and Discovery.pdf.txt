FineGAN: Unsupervised Hierarchical Disentanglement for

Fine-Grained Object Generation and Discovery

Krishna Kumar Singh∗

Utkarsh Ojha∗

Yong Jae Lee

University of California, Davis

Abstract

Background	code

We propose FineGAN, a novel unsupervised GAN frame-
work, which disentangles the background, object shape,
and object appearance to hierarchically generate images
of ﬁne-grained object categories. To disentangle the fac-
tors without supervision, our key idea is to use informa-
tion theory to associate each factor to a latent code, and
to condition the relationships between the codes in a spe-
ciﬁc way to induce the desired hierarchy. Through exten-
sive experiments, we show that FineGAN achieves the de-
sired disentanglement to generate realistic and diverse im-
ages belonging to ﬁne-grained classes of birds, dogs, and
cars. Using FineGAN’s automatically learned features,
we also cluster real images as a ﬁrst attempt at solving
the novel problem of unsupervised ﬁne-grained object cat-
egory discovery. Our code/models/demo can be found at
https://github.com/kkanshul/finegan

1. Introduction

Consider the ﬁgure above: if tasked to group any of the
images together, as humans we can easily tell that birds A
and B should not be grouped with C and D as they have
completely different backgrounds and shapes. But how
about C and D? They share the same background, shape,
and rough color. However, upon close inspection, we see
that even C and D should not be grouped together as C’s
beak is yellow and its tails have large white spots while D’s
beak is black and its tails have thin white strips.1 This ex-
ample demonstrates that clustering ﬁne-grained object cate-
gories requires not only disentanglement of the background,

∗Equal contribution.
1The ground-truth ﬁne-grained categories are A: Barrow’s Goldeneye,

B: California Gull, C: Yellow-billed Cuckoo, D: Black-billed Cuckoo.

Parent	code

Child	code

Figure 1. FineGAN disentangles the background, object shape
(parent), and object appearance (child) to hierarchically generate
ﬁne-grained objects, without mask or ﬁne-grained annotations.

shape, and appearance (color/texture), but that it is naturally
facilitated in a hierarchical fashion.

In this work, we aim to develop a model that can do
just that: model ﬁne-grained object categories by hierar-
chically disentangling the background, object’s shape, and
its appearance, without any manual ﬁne-grained annota-
tions. Speciﬁcally, we make the ﬁrst attempt at solving the
novel problem of unsupervised ﬁne-grained object cluster-
ing (or “discovery”). Although both unsupervised object
discovery and ﬁne-grained recognition have a long history,
prior work on unsupervised object category discovery focus
only on clustering entry-level categories (e.g., birds vs. cars
vs. dogs) [17, 42, 31, 51, 47, 15], while existing work on
ﬁne-grained recognition focus exclusively on the supervised
setting in which ground-truth ﬁne-grained category annota-
tions are provided [35, 52, 34, 4, 13, 33, 12, 7, 46].

Why unsupervised discovery for such a difﬁcult prob-
lem? We have two key motivations. First, ﬁne-grained an-
notations require domain experts. As a result, the overall
annotation process is very expensive and standard crowd-
sourcing techniques cannot be used, which restrict the
amount of training data that can be collected. Second, un-
supervised learning enables the discovery of latent structure
in the data, which may not have been labeled by annotators.
For example, ﬁne-grained image datasets often have an in-

6490

ADBCherent hierarchical organization in which the categories can
ﬁrst be grouped based on one feature (e.g., shape) and then
differentiated based on another (e.g., appearance).

Main Idea. We hypothesize that a generative model with
the capability of hierarchically generating images with ﬁne-
grained details can also be useful for ﬁne-grained grouping
of real images. We therefore propose FineGAN, a novel
hierarchical unsupervised Generative Adversarial Networks
framework to generate images of ﬁne-grained categories.

FineGAN generates a ﬁne-grained image by hierarchi-
cally generating and stitching together a background image,
a parent image capturing one factor of variation of the ob-
ject, and a child image capturing another factor. To disen-
tangle the two factors of variation of the object without any
supervision, we use information theory, similar to InfoGAN
[9]. Speciﬁcally, we enforce high mutual information be-
tween (1) the parent latent code and the parent image, and
(2) the child latent code, conditioned on the parent code,
and the child image. By imposing constraints on the rela-
tionship between the parent and child latent codes (speciﬁ-
cally, by grouping child codes such that each group has the
same parent code), we can induce the parent and child codes
to capture the object’s shape and color/texture details, re-
spectively; see Fig. 1. This is because in many ﬁne-grained
datasets, objects often differ in appearance conditioned on
a shared shape (e.g., ‘Yellow-billed Cuckoo’ and ‘Black-
billed Cuckoo’, which share the same shape but differ in
their beak color and wing patterns).

Moreover, FineGAN automatically generates masks at
both the parent and child stages, which help condition the
latent codes to focus on the relevant object factors as well
as to stitch together the generated images across the stages.
Ultimately, the features learned through this unsupervised
hierarchical image generation process can be used to cluster
real images into their ﬁne-grained classes.

Contributions. Our work has two main contributions:

(1) We introduce FineGAN, an unsupervised model that
learns to hierarchically generate the background, shape, and
appearance of ﬁne-grained object categories. Through var-
ious qualitative evaluations, we demonstrate FineGAN’s
ability to accurately disentangle background, object shape,
and object appearance. Furthermore, quantitative evalua-
tions on three benchmark datasets (CUB [45], Stanford-
dogs [27], and Stanford-cars [29]) demonstrate FineGAN’s
strength in generating realistic and diverse images.

(2) We use FineGAN’s learned disentangled represen-
tation to cluster real images for unsupervised ﬁne-grained
object category discovery. It produces ﬁne-grained clusters
that are signiﬁcantly more accurate than those of state-of-
the-art unsupervised clustering approaches (JULE [51] and
DEPICT [15]). To our knowledge, this is the ﬁrst attempt to
cluster ﬁne-grained categories in the unsupervised setting.

2. Related work

Fine-grained category recognition involves classifying
subordinate categories within entry-level categories (e.g.,
different species of birds), which requires annotations from
domain experts [35, 52, 34, 4, 13, 8, 33, 12, 28, 58, 46].
Some methods require additional part [56, 6, 53], at-
tribute [14], or text [37, 19] annotations. Our work makes
the ﬁrst attempt to overcome the dependency on expert an-
notations by performing unsupervised ﬁne-grained category
discovery without any class annotations.

Visual object discovery and clustering. Early work on
unsupervised object discovery [41, 17, 42, 31, 32, 39] use
handcrafted features to cluster object categories from un-
labeled images. Others explore the use of natural language
dialogue for object discovery [10, 59]. Recent unsupervised
deep clustering approaches [51, 47, 15] demonstrate state-
of-the-art results on datasets whose objects have large vari-
ations in high-level detail like shape and background. On
ﬁne-grained category datasets, we show that FineGAN sig-
niﬁcantly outperforms these methods as it is able to focus
on the ﬁne-grained object details.

Disentangled representation learning
has a vast litera-
ture (e.g., [3, 44, 22, 49, 9, 21, 11, 23]). The most re-
lated work in this space is InfoGAN [9], which learns dis-
entangled representations without any supervision by max-
imizing the mutual information between the latent codes
and generated data. Our work builds on the same prin-
ciples of information theory, but we extend it to learn a
hierarchical disentangled representation. Speciﬁcally, un-
like InfoGAN in which all details of an object are gener-
ated together, FineGAN provides explicit distentanglement
and control over the generation of background, shape, and
appearance, which we show is especially important when
modeling ﬁne-grained categories.

GANs and Stagewise image generation. Unconditional
GANs [16, 36, 43, 57, 1, 18] can generate realistic images
without any supervision. However, unlike our approach,
these methods do not generate images hierarchically and
do not have explicit control over the background, object’s
shape, and object’s appearance. Some conditional super-
vised approaches [38, 54, 55, 5] learn to generate ﬁne-
grained images with text descriptions. One such approach,
FusedGAN [5], generates ﬁne-grained objects with speciﬁc
pose and shape but it cannot decouple them, and lacks ex-
plicit control over the background. In contrast, FineGAN
can generate ﬁne-grained images without any text supervi-
sion and with full control over the background, pose, shape,
and appearance. Also related are stagewise image gener-
ators [24, 30, 50, 26]. In particular, LR-GAN [50] gener-
ates the background and foreground separately and stitches
them. However, both are controlled by a single random vec-

6491

tor, and it does not disentangle the object’s shape from ap-
pearance.

a duck, then the list of c’s tied to this p would all share the
same duck shape, but vary in their color and texture.

3. Approach

Let X = {x1, x2, . . . , xN } be a dataset containing unla-
beled images of ﬁne-grained object categories. Our goal
is to learn an unsupervised generative model, FineGAN,
which produces high quality images matching the true data
distribution pdata(x), while also learning to disentangle the
relevant factors of variation associated with images in X .

We consider background,

shape, appearance, and
pose/location of the object as the factors of variation in this
work. If FineGAN can successfully associate each latent
code to a particular ﬁne-grained category aspect (e.g., like
a bird’s shape and wing color), then its learned features can
also be used to group the real images in X for unsupervised
ﬁnd-grained object category discovery.

3.1. Hierarchical ﬁne grained disentanglement

Fig. 2 shows our FineGAN architecture for modeling and
generating ﬁne-grained object images. The overall process
has three interacting stages: background, parent, and child.
The background stage generates a realistic background im-
age B. The parent stage generates the outline (shape) of the
object and stitches it onto B to produce parent image P. The
child stage ﬁlls in the object’s outline with the appropriate
color and texture, to produce the ﬁnal child image C. The
objective function of the complete process is:

L = λLb + βLp + γLc

where Lb, Lp and Lc denote the objectives for the back-
ground, parent, and child stage respectively, with λ, β and
γ denoting their weights. We train all stages end-to-end.

The different stages get conditioned with different latent
codes, as seen from Fig. 2. FineGAN takes as input:
i)
a continuous noise vector z ∼ N (0, 1); ii) a categorical
background code b ∼ Cat(K = Nb, p = 1/Nb); iii) a cate-
gorical parent code p ∼ Cat(K = Np, p = 1/Np); and iv)
a categorical child code c ∼ Cat(K = Nc, p = 1/Nc).

Relationship between latent codes:
(1) Parent code and
child code. We assume the presence of an implicit hierarchy
in X – as mentioned previously, ﬁne-grained categories can
often be grouped ﬁrst based on a common shape and then
differentiated based on appearance. To help discover this
hierarchy, we impose two constraints: (i) the number of cat-
egories of parent code is set to be less than that of child code
(Np < Nc), and (ii) for each parent code p, we tie a ﬁxed
number of child codes c to it (multiple child codes share
the same parent code). We will show that these constraints
help push p to capture shape and c to capture appearance.
For example, if the shape identity captured by p is that of

(2) Background code and child code. There is usually
some correlation between an object and the background in
which it is found (e.g., ducks in water). Thus, to avoid con-
ﬂicting object-background pairs (which a real/fake discrim-
inator could easily exploit to tell that an image is fake), we
set the background code to be the same as the child code
during training (b = c). However, we can easily relax this
constraint during testing (e.g., to generate a duck in a tree).

3.1.1 Background stage

The background stage synthesizes a background image B,
which acts as a canvas for the parent and child stages to
stitch different foreground aspects on top of B. Since we
aim to disentangle background as a separate factor of vari-
ation, B should not contain any foreground information.
We hence separate the background stage from the parent
and child stages, which share a common feature pipeline.
This stage consists of a generator Gb and a discriminator
pair, Db and Daux. Gb is conditioned on latent background
code b, which controls the different (unknown) background
classes (e.g., trees, water, sky), and on latent code z, which
controls intra-class background details (e.g., positioning of
leaves). To generate the background, we assume access to
an object bounding box detector that can detect instances
of the super-category (e.g., bird). We use the detector
to locate non-object background patches in each real im-
age xi. We then train Gb and Db using two objectives:
Lb = Lbg adv + Lbg aux, where Lbg adv is the adversarial
loss [16] and Lbg aux is the auxiliary background classiﬁ-
cation loss.

For the adversarial loss Lbg adv, we employ the discrim-
inator Db on a patch level [25] (we assume background can
easily be modeled as texture) to predict an N × N grid with
each member indicating the real/fake score for the corre-
sponding patch in the input image:

Lbg adv = min
Gb

max
Db

Ex[log(Db(x))] + Ez,b[log(1 − Db(Gb(z, b)))]

The auxiliary classiﬁcation loss Lbg aux makes the back-
ground generation task more explicit, and is also computed
on a patch level. Speciﬁcally, patches inside (ri) and outside
(ro) the detected object in real images constitute the training
set for foreground (1) and background (0) respectively, and
is used to train a binary classiﬁer Daux with cross-entropy
loss. We then use Daux to train the generator Gb:

Lbg aux = min
Gb

Ez,b[log(1 − Daux(Gb(z, b)))]

This loss updates Gb so that Daux assigns a high back-

ground probability to the generated background patches.

6492

Stitching process

Generative modules

Discriminative modules

Element wise multiplication

Element wise addition

b - Background code

p - Parent code

c - Child code

Background stage

b

z

Gb

Background: B

Daux

Lbg_aux

Db

Lbg_adv

p

z

Gp

Parent stage

Fp

c

Gc

Fc

Child  stage

Gp,m

Gp,f

Gc,m

Gc,f

Pm

Pf

Cm

Cf

Inverse

Inverse

Parent: P

Pf,m

Dp

Lp_info

Cf,m

Dc

Lc_info

Child: C

Dadv
Lc_adv

Figure 2. FineGAN architecture for hierarchical ﬁne-grained image generation. The background stage, conditioned on random vector z
and background code b, generates the background image B. The parent stage, conditioned on z and parent code p, uses B as a canvas to
generate parent image P , which captures the shape of the object. The child stage, conditioned on c, uses P as a canvas to generate the ﬁnal
child image C with the object’s appearance details stitched into the shape outline.

3.1.2 Parent stage

As explained previously, we model the real data distribution
pdata(x) through a two-level foreground generation process
via the parent and child stages. The parent stage can be
viewed as modeling higher-level information about an ob-
ject like its shape, and the child stage, conditioned on the
parent stage, as modeling lower-level information like its
color/texture.

Capturing multi-level information in this way can have
potential advantages. First, it makes the overall image gen-
eration process more principled and easier to interpret; dif-
ferent sub-networks of the model can focus only on syn-
thesizing entities they are concerned with, in contrast to the
case where the entire network performs single-shot image
generation. Second, for ﬁne-grained generation, it should
be easier for the model to generate appearance details condi-
tioned on the object’s shape, without having to worry about
the background and other variations. With the same reason-
ing, such hierarchical features—parent capturing shape and
child capturing appearance—should also be beneﬁcial for
ﬁne-grained categorization compared to a ﬂat-level feature
representation.

We now discuss the working details of the parent stage.
As shown in Fig. 2, Gp, which consists of a series of convo-
lutional layers and residual blocks, maps z and p to feature
representation Fp. As discussed previously, the requirement
from this stage is only to generate a foreground entity, and
stitch it to the existing background B. Consequently, two
generators Gp,f and Gp,m transform Fp into parent fore-
ground (Pf ) and parent mask (Pm) respectively, so that Pm
can be used to stitch Pf on B, to obtain the parent image P:

P = Pf,m + Bm

where Pf,m = Pm ⊙ Pf and Bm = (1 − Pm) ⊙ B denote
masked foreground and inverse masked background image
respectively; see green arrows in Fig. 2. This idea of gen-
erating a mask and using it for stitching is inspired by LR-
GAN [50].

We again employ a discriminator at the parent stage, and
denote it as Dp. Its functioning however, differs from the
discriminators employed at the other stages. This is because
in contrast to the background and child stages where we
know the true distribution to be modeled, the true distribu-
tion for P or Pf,m is unknown (i.e., we have real patch sam-
ples of background and real image samples of the object,
but we do not have any real intermediate image samples in
which the object exhibits one factor like shape but lacks an-
other factor like appearance). Consequently, we cannot use
the standard GAN objective to train Dp.

Thus, we only use Dp to induce the parent code p to rep-
resent the hierarchical concept i.e., the object’s shape. With
no supervision from image labels, we exploit information
theory to discover this concept in a completely unsupervised
manner, similar to InfoGAN [9]. Speciﬁcally, we maximize
the mutual information I(p, Pf,m), with Dp approximating
the posterior P (p|Pf,m):

Lp = Lp inf o =

max

Dp,Gp,f ,Gp,m

Ez,p[log Dp(p|Pf,m)]

We use Pf,m instead of P so that Dp makes its decision
solely based on the foreground object (shape) and not get
inﬂuenced by the background. In simple words, Dp is asked
to reconstruct the latent hierarchical category information
(p) from Pf,m, which already has this information encoded
during its synthesis. Given our constraints from Sec. 3.1
that there are less parent categories than child ones (Np <
Nc) and multiple child codes share the same parent code,

6493

FineGAN tries encoding p into Pf,m as an attribute that: (i)
by itself cannot capture all ﬁne-grained category details, and
(ii) is common to multiple ﬁne-grained categories, which is
the essence of hierarchy.

3.1.3 Child stage

The result of the previous stages is an image that is a com-
position of the background and object’s outline. The task
that remains is ﬁlling in the outline with appropriate tex-
ture/color to generate the ﬁnal ﬁne-grained object image.

As shown in Fig. 2, we encode the color/texture infor-
mation about the object with child code c, which is itself
conditioned on parent code p. Concatenated with Fp, the re-
sulting feature chunk is fed into Gc, which again consists of
a series of convolutional and residual blocks. Analogous to
the parent stage, two generators Gc,f and Gc,m map the re-
sulting feature representation Fc into child foreground (Cf )
and child mask (Cm) respectively. The stitching process to
obtain the complete child image C is:
C = Cf,m + Pc,m

where Cf,m = Cm ⊙ Cf , and Pc,m = (1 − Cm) ⊙ P.

We now discuss the requirements for the child stage dis-
criminative networks, Dadv and Dc: (i) discriminate be-
tween real samples from X and fake samples from the gen-
erative distribution using Dadv; (ii) use Dc to approximate
the posterior P (c|Cf,m) to associate the latent code c to a
ﬁne-grained object detail like color and texture. The loss
function can hence be broken down into two components
Lc = Lc adv + Lc inf o, where:

Lc adv = min
Gc

Lc inf o =

max
Dadv
max

Dc,Gc,f ,Gc,m

Ez,p,c[log Dc(c|Cf,m)].

Ex[log(Dadv(x))] + Ez,b,p,c[log(1 − Dadv(C))],

Again, we use Cf,m instead of C so that Dc makes its de-
cision solely based on the object (color/texture and shape)
and not get inﬂuenced by the background. With shape al-
ready captured though the parent code p, the child code c
can now solely focus to correspond to the texture/color in-
side the shape.

3.2. Fine grained object category discovery

Given our trained FineGAN model, we can now use it
to compute features for the real images xi ∈ X to cluster
them into ﬁne-grained object categories. In particular, we
can make use of the ﬁnal synthetic images {Cj} and their
associated parent and child codes to learn a mapping from
images to codes. Note that we cannot directly use the par-
ent and child discriminators Dp and Dc—which each cate-
gorize {Pf,m} and {Cf,m} into one of the parent and child
codes respectively—-on the real images due to the unavail-
ability of real foreground masks. Instead, we train a pair
of convolutional networks (φp and φc) to predict the parent
and child codes of the ﬁnal set of synthetic images {Cj}:

1. Randomly sample a batch of codes: z ∼ N (0, 1), p ∼

pp, c ∼ pc, b ∼ pb to generate child images {Cj}.

2. Feed forward this batch through φp and φc. Compute
cross-entropy loss CE(p, φp(Cj)) and CE(c, φc(Cj)).

3. Update φp and φc. Repeat till convergence.
To accurately predict parent code p from Cj , φp has to
solely focus on the object’s shape as no sensible supervision
can come from the randomly chosen background and child
codes. With similar reasoning, φc has to solely focus on the
object’s appearance to accurately predict child code c. Once
φp and φc are trained, we use them to extract features for
each real image xi ∈ X . Finally, we use their concatenated
features to group the images with k-means clustering.

4. Experiments

We ﬁrst evaluate FineGAN’s ability to disentangle and
generate images of ﬁne-grained object categories. We then
evaluate FineGAN’s learned features for ﬁne-grained object
clustering with real images.

Datasets and implementation details. We evaluate on
three ﬁne-grained datasets: (1) CUB [45]: 200 bird classes.
We use the entire dataset (11,788 images); (2) Stanford
Dogs [27]: 120 dog classes. We use its train data (12,000
images); (3) Stanford Cars [29]: 196 car classes. We use
its train data (8,144 images). We do not use any of the pro-
vided labels for training. The labels are only used for eval-
uation. Number of parents and children are set as: (1) CUB:
Np = 20, Nc = 200; (2) Stanford dogs: Np = 12, Nc = 120;
and (3) Cars: Np = 20, Nc = 196. Nc matches the ground-
truth number of ﬁne-grained classes per dataset. We set λ =
10, β = 1 and γ = 1 for all datasets.

4.1. Fine grained image generation

We ﬁrst analyze FineGAN’s image generation in terms

of realism and diversity. We compare to:

• Simple-GAN: Generates a ﬁnal image (C) in one shot
without the parent and background stages. Only has
Lc adv loss at the child stage. This baseline helps gauge
the importance of disentanglement learned by Lc inf o.
For fair comparison, we use FineGAN’s backbone archi-
tecture.

• InfoGAN [9]: Same as Simple-GAN but with addi-
tional Lc inf o. This baseline helps analyze the im-
portance of hierarchical disentanglement between back-
ground, shape, and appearance during image generation,
which is lacking in InfoGAN. Nc is set to be the same
as FineGAN for each dataset. We again use FineGAN’s
backbone architecture.

• LR-GAN [50]:

It also generates an image stagewise,
which is similar to our approach. But its stages only
consist of foreground and background, and that too con-
trolled by single random vector z.

6494

Back-
ground

Parent	
Mask

Parent	
Image

Child	
Mask

Child	
Image

CUB	Birds

Stanford	Cars

Stanford	Dogs

Figure 3. FineGAN’s stagewise image generation. Background stage generates a background which is retained over the child and parent
stages. Parent stage generates a hollow image with only the object’s shape, and child stage ﬁlls in the appearance to complete the image.

• StackGAN-v2 [55]: Its unconditional version generates
images at multiple scales with Lc adv at each scale. This
helps gauge how FineGAN fares against a state-of-the-art
unconditional image generation approach.

For LR-GAN and StackGAN-v2, we use the authors’
publicly-available code. We evaluate image generation us-
ing Inception Score (IS) [40] and Frechet Inception Dis-
tance (FID) [20], which are computed on 30K randomly
generated images (equal number of images for each child
code c), using an Inception Network ﬁne-tuned on the re-
spective datasets [2]. We evaluate on 128 x 128 generated
images for all methods except LR-GAN, for which 64 x 64
generated images give better performance.

4.1.1 Quantitative evaluation of image generation

FineGAN obtains Inception Scores and FIDs that are favor-
able when compared to the baselines (see Table 1), which
shows it can generate images that closely match the real data
distribution.

In particular, the lower scores by Simple-GAN, LR-
GAN, and StackGAN-v2 show that relying on a single ad-
versarial loss can be insufﬁcient to model ﬁne-grained de-
tails. Both FineGAN and InfoGAN learn to associate a c
code to a variation factor (Lc inf o) to generate more de-
tailed images. But by further disentangling the background
and object shape (parent), FineGAN learns to generate more
diverse images. LR-GAN also generates an image stage-
wise but we believe it has lower performance as it only sep-
arates foreground and background, which appears to be in-
sufﬁcient for capturing ﬁne-grained details. These results
strongly suggest that FineGAN’s hierarchical disentangle-
ment is important for better ﬁne-grained image generation.

How sensitive is FineGAN to the number of parents?
Table 2 shows the Inception Score (IS) on CUB of Fine-
GAN trained with varying number of parents while keeping

IS

FID
Birds Dogs

Cars

Dogs

Birds

6.75 ± 0.07

Simple-GAN
InfoGAN [9]
LR-GAN [50]

Cars
31.85 ± 0.17
20.92 ± 0.14 16.69 261.85 33.35
47.32 ± 0.77 43.16 ± 0.42 28.62 ± 0.44 13.20
17.63
13.50 ± 0.20 10.22 ± 0.21
34.91
88.80
StackGANv2 [55] 43.47 ± 0.74 37.29 ± 0.56 33.69 ± 0.44 13.60
16.28
52.53 ± 0.45 46.92 ± 0.61 32.62 ± 0.37 11.25
16.03
FineGAN (ours)
Table 1. Inception Score (higher is better) and FID (lower is bet-
ter). FineGAN consistently generates diverse and real images that
compare favorably to those of state-of-the-art baselines.

29.34
54.91
31.39
25.66

5.25 ± 0.05

Inception Score (CUB)

52.53

52.11

49.62

46.68

N

p=20 N

p=10 N

p=40 N

p=5 N

p=mixed
51.83

Table 2. Varying number of parent codes Np, with number of chil-
dren Nc ﬁxed to 200. FineGAN is robust to a wide range of Np.

the number of children ﬁxed (200). IS remains consistently
high unless we have very small (Np=5) or large (Np=40)
number of parents. With very small Np, we limit diversity
in the number of object shapes, and with very high Np, the
model has less opportunity to take advantage of the implicit
hierarchy in the data. With variable number of children
per parent (Np=mixed: 6 parents with 5 children, 3 parents
with 20 children, and 11 parents with 10 children), IS re-
mains high, which shows there is no need to have the same
number of children for each parent. These results show that
FineGAN is robust to a wide range of parent choices.

4.1.2 Qualitative evaluation of image generation

We next qualitatively analyze FineGAN’s (i) image genera-
tion process; (ii) disentanglement of the factors of variation;
and provide (iii) in-depth comparison to InfoGAN.

Image generation process. Fig. 3 shows the intermedi-
ate images generated for CUB, Stanford Cars, and Stanford
Dogs. The background images (1st row) capture the context
of each dataset well; e.g., they contain roads for cars, gar-
dens or indoor scene for dogs, leafy backgrounds for birds.
The parent stage produces parent masks that capture each
object’s shape (2nd row), and a textureless, hollow entity as

6495

Figure 4. Varying p vs. c vs. z. Every three rows correspond to the same parent code p and each row has a different child code c. For
the same parent, the object’s shape remains consistent while the appearance changes with different child codes. For the same child, the
appearance remains consistent. Each column has the same random vector z – we see that it controls the object’s pose and position.

the parent image (3rd row) together with the background.
The ﬁnal child stage produces a more detailed mask (4th
row) and the ﬁnal composed image (last row), which has
the same foreground shape as that of the parent image with
added texture/color details. Note that the generation of ac-
curate masks at each stage is important for the ﬁnal com-
posed image to retain the background, and is obtained with-
out any mask supervision during training. We present ad-
ditional quantitative analyses on the quality of the masks in
the supplementary material.

Disentanglement of factors of variation. Fig. 4 shows
the discovered grouping of parent and child codes by Fine-
GAN. Each row corresponds to different instances with the
same child code. Two observations can be made as we move
left to right: (i) there is a consistency in the appearance and
shape of the foreground objects; (ii) background changes
slightly, giving an impression that the background across a
row belongs to the same class, but with slight modiﬁcations.
For each dataset, each set of three rows corresponds to three
distinct children of the same parent, which is evident from
their common shape. Notice that different child codes for
the same parent can capture ﬁne-grained differences in the

appearance of the foreground object (e.g., dogs in the third
row differ from those in ﬁrst only because of small brown
patches; similarly, birds in the 7th and last rows differ only
in their wing color). Finally, the consistency in object view-
point and pose along each column shows that FineGAN has
learned to associate z with these factors.

Disentanglement of parent vs. child. Fig. 5 further ana-
lyzes the disentanglement of parent (shape) and child code
(appearance). Across the rows, we vary parent code p while
keeping child code c constant, which changes the bird’s
shape but keeps the texture/color the same. Across the
columns, we vary child code c while keeping parent code
p constant, which changes the bird’s color/texture but keeps
the shape the same. This result illustrates the control that
FineGAN has learned without any corresponding supervi-
sion over the shape and appearance of a bird. Note that we
keep background code b to be same across each column.

Disentanglement of background vs. foreground. The
ﬁgure below shows disentanglement of background from
object. In (a), we keep background code b constant and vary
the parent and child code, which generates different birds

6496

CUB BirdsStanford Dogssame child codesame parent codesame z vectorStanford Carssame child code, varying parent code

e
d
o
c
 
d

l
i

h
c
 
g
n
y
r
a
v
 
,

i

e
d
o
c
 
t

n
e
r
a
p
e
m
a
s

 

Figure 5. Disentanglement of parent vs. child codes. Shape is
retained over the column, appearance is retained over the row.

over the same background. In (b), we keep the parent and
child codes constant and vary the background code, which
generates an identical bird with different backgrounds.

Comparison with InfoGAN.
In InfoGAN [9], the latent
code prediction is based on the complete image, in contrast
to FineGAN which uses the masked foreground. Due to
this, InfoGAN’s child code prediction can be biased by the
background (see Fig. 6). Furthermore, InfoGAN [9] does
not hierarchically disentangle the latent factors. To enable
InfoGAN to model the hierarchy in the data, we tried condi-
tioning its generator on both the parent and child codes, and
ask the discriminator to predict both. This improves perfor-
mance slightly (IS: 48.06, FID: 12.84 for birds), but is still
worse than FineGAN. This shows that simply adding a par-
ent code constraint to InfoGAN does not lead it to produce
the hierarchical disentanglement that FineGAN achieves.

4.2. Fine grained object category discovery

We next evaluate FineGAN’s learned features for clus-
tering real images into ﬁne-grained object categories. We
compare against the state-of-the-art deep clustering ap-
proaches JULE [51] and DEPICT [15]. To make them
even more competitive, we also create a JULE variant
with ResNet-50 backbone (JULE-ResNet-50) and DE-
PICT with double the number of ﬁlters in each conv layer
(DEPICT-Large). We use code provided by the authors.
All methods cluster the same image regions.

For evaluation we use Normalized Mutual Information
(NMI) [48] and Accuracy (of best mapping between clus-

Figure 6. InfoGAN results. Images in each group have same child
code. The birds are the same, but so are their backgrounds. This
strongly suggests InfoGAN takes background into consideration
when categorizing the images. In contrast, FineGAN’s generated
images (Fig. 4) for same c show reasonable variety in background.

JULE [51]

JULE-ResNet-50 [51]

DEPICT [15]

DEPICT-Large [15]

Ours

NMI
Birds Dogs
0.142
0.204
0.148
0.203
0.182
0.290
0.183
0.297
0.403
0.233

Accuracy

Cars
0.232
0.237
0.329
0.330
0.354

Birds Dogs
0.043
0.045
0.044
0.044
0.052
0.061
0.054
0.061
0.126
0.079

Cars
0.046
0.050
0.063
0.062
0.078

Table 3. Our approach outperforms existing clustering methods.

ter assignments and true labels) following [15]. Our ap-
proach outperforms the baselines on all three datasets (see
Table 3). This indicates that FineGAN’s features learned for
hierarchical image generation are better able to capture the
ﬁne-grained object details necessary for ﬁne-grained object
clustering. JULE and DEPICT are unable to capture those
details to the same extent; instead, they focus more on high-
level details like background and rough shape (see supp.
for examples). Increasing their capacity (JULE-RESNET-
50 and DEPICT-Large) gives little improvement. Finally,
if we only use our child code features, then performance
drops (0.017 in Accuracy on birds). This shows that the
parent code and child code features are complementary and
capture different aspects (shape vs. appearance).

5. Discussion and limitations

There are some limitations of FineGAN worth dis-
cussing. First, although we have shown that our model
is robust to a wide range of number of parents (Table 2),
it along with the number of children are hyperparameters
that a user must set, which can be difﬁcult when the true
number of categories is unknown (a problem common to
most unsupervised grouping methods). Second, the latent
modes of variation that FineGAN discovers may not nec-
essarily correspond to those deﬁned/annotated by a human.
For example, our results in Fig. 4 for cars show that the
children are grouped based on color rather than car model
type. This highlights the importance of a good evaluation
metric for unsupervised methods. Finally, while we signiﬁ-
cantly outperform unsupervised clustering methods, we are
far behind fully-supervised ﬁne-grained recognition meth-
ods. Nonetheless, we feel that this paper has taken impor-
tant initial steps in tackling the challenging problem of un-
supervised ﬁne-grained object modeling.

Acknowledgments. This work was supported in part
by NSF IIS-1751206, IIS-1748387, AWS ML Research
Award, Google Cloud Platform research credits, and GPUs
donated by NVIDIA.

6497

(a) Fixed b, varying pand c(b) Fixed pand c, varying bReferences

[1] Martin Arjovsky, Soumith Chintala, and L´eon Bottou.

Wasserstein gan. arXiv preprint arXiv:1701.07875, 2017.

[2] Shane Barratt and Rishi Sharma. A note on the inception

score. In arXiv:1801.01973, 2018.

[3] Yoshua Bengio, Aaron Courville, and Pascal Vincent. Repre-
sentation learning: A review and new perspectives. TPAMI,
2013.

[4] Thomas Berg and Peter Belhumeur. Poof: Part-based one-
vs.-one features for ﬁne-grained categorization, face veriﬁ-
cation, and attribute estimation. In CVPR, 2013.

[5] Navaneeth Bodla, Gang Hua, and Rama Chellappa. Semi-
In

supervised fusedgan for conditional image generation.
ECCV, 2018.

[6] Steve Branson, Grant Van Horn, Serge Belongie, and Pietro
Perona. Bird species categorization using pose normalized
deep convolutional nets. BMVC, 2014.

[7] Sijia Cai, Wangmeng Zuo, and Lei Zhang. Higher-order in-
tegration of hierarchical convolutional activations for ﬁne-
grained visual categorization. In ICCV, 2017.

[8] Yuning Chai, Victor Lempitsky, and Andrew Zisserman.
localization for ﬁne-

Symbiotic segmentation and part
grained categorization. In ICCV, 2013.

[9] Xi Chen, Yan Duan, Rein Houthooft, John Schulman, Ilya
Sutskever, and Pieter Abbeel.
Infogan: Interpretable rep-
resentation learning by information maximizing generative
adversarial nets. In NIPS, 2016.

[10] Harm de Vries, Florian Strub, Sarath Chandar, Olivier
Pietquin, Hugo Larochelle, and Aaron Courville. Guess-
what?! visual object discovery through multi-modal dia-
logue. In CVPR, 2017.

[11] Emily L Denton and vighnesh Birodkar. Unsupervised learn-
In NIPS,

ing of disentangled representations from video.
2017.

[12] Yang Gao, Oscar Beijbom, Ning Zhang, and Trevor Darrell.

Compact bilinear pooling. In CVPR, 2016.

[13] Efstratios Gavves, Basura Fernando, Cees GM Snoek,
Arnold WM Smeulders, and Tinne Tuytelaars. Fine-grained
categorization by alignments. In ICCV, 2013.

[14] Timnit Gebru, Judy Hoffman, and Li Fei-Fei. Fine-grained
recognition in the wild: A multi-task domain adaptation ap-
proach. In ICCV, 2017.

[15] Kamran Ghasedi Dizaji, Amirhossein Herandi, Cheng Deng,
Weidong Cai, and Heng Huang. Deep clustering via joint
convolutional autoencoder embedding and relative entropy
minimization. In ICCV, 2017.

[16] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing
Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and
Yoshua Bengio. Generative adversarial nets. In NIPS, 2014.
[17] Kristen Grauman and Trevor Darrel. Unsupervised learning
of categories from sets of partially matching image features.
In CVPR, 2006.

[18] Ishaan Gulrajani, Faruk Ahmed, Martin Arjovsky, Vincent
Improved training of

Dumoulin, and Aaron C Courville.
wasserstein gans. In NIPS, 2017.

[19] Xiangteng He and Yuxin Peng. Fine-grained image classiﬁ-

cation via combining vision and language. In CVPR, 2017.

[20] Martin Heusel, Hubert Ramsauer, Thomas Unterthiner,
Bernhard Nessler, Gunter Klambauer, and Sepp Hochreiter.
Gans trained by a two time-scale update rule converge to a
local nash equilibrium. In NIPS, 2017.

[21] Irina Higgins, Loic Matthey, Arka Pal, Christopher Burgess,
Xavier Glorot, Matthew Botvinick, Shakir Mohamed, and
Alexander Lerchner. beta-vae: Learning basic visual con-
cepts with a constrained variational framework.
In ICLR,
2017.

[22] Geoffrey E. Hinton, Alex Krizhevsky, and Sida D. Wang.

Transforming auto-encoders. In ICANN, 2011.

[23] Qiyang Hu, Attila Szab, Tiziano Portenier, Paolo Favaro, and
Matthias Zwicker. Disentangling factors of variation by mix-
ing them. In CVPR, 2018.

[24] Daniel Jiwoong Im, Chris Dongjoo Kim, Hui Jiang, and
Roland Memisevic. Generating images with recurrent ad-
versarial networks. http://arxiv.org/abs/1602.05110, 2016.

[25] Phillip Isola, Jun-Yan Zhu, Tinghui Zhou, and Alexei A
Image-to-image translation with conditional adver-

Efros.
sarial networks. CVPR, 2017.

[26] Justin Johnson, Agrim Gupta, and Li Fei-Fei. Image genera-

tion from scene graphs. In CVPR, 2018.

[27] Aditya Khosla, Nityananda Jayadevaprakash, Bangpeng
Yao, and Li Fei-Fei. Novel dataset for ﬁne-grained image
categorization.
In First Workshop on Fine-Grained Visual
Categorization, 2011.

[28] Shu Kong and Charless Fowlkes. Low-rank bilinear pooling

for ﬁne-grained classiﬁcation. In CVPR, 2017.

[29] Jonathan Krause, Michael Stark, Jia Deng, and Li Fei-
Fei. 3d object representations for ﬁne-grained categorization.
In IEEE Workshop on 3D Representation and Recognition
(3dRR-13), 2013.

[30] Hanock Kwak and Byoung-Tak Zhang. Generating images
part by part with composite generative adversarial networks.
arXiv preprint arXiv:1607.05387, 2016.

[31] Yong Jae Lee and Kristen Grauman. Unsupervised learning
of categories from sets of partially matching image features.
In CVPR, 2010.

[32] Yong Jae Lee and Kristen Grauman. Learning the easy things
ﬁrst: Self-paced visual category discovery. In CVPR, 2011.
[33] Tsung-Yu Lin, Aruni RoyChowdhury, and Subhransu Maji.
Bilinear cnn models for ﬁne-grained visual recognition. In
ICCV, 2015.

[34] Jiongxin Liu, Angjoo Kanazawa, David Jacobs, and Peter
Belhumeur. Dog breed classiﬁcation using part localization.
In ECCV, 2012.

[35] M-E. Nilsback and A. Zisserman. Automated ﬂower classi-

ﬁcation over a large number of classes. In ICVGIP, 2008.

[36] Alec Radford, Luke Metz, and Soumith Chintala. Unsuper-
vised representation learning with deep convolutional gener-
ative adversarial networks. ICLR, 2016.

[37] Scott Reed, Zeynep Akata, Honglak Lee, and Bernt Schiele.
Learning deep representations of ﬁne-grained visual descrip-
tions. In CVPR, 2016.

[38] Scott Reed, Zeynep Akata, Xinchen Yan, Lajanugen Lo-
geswaran, Bernt Schiele, and Honglak Lee. Generative ad-
versarial text-to-image synthesis. In ICML, 2016.

6498

[59] Bohan Zhuang, Qi Wu, Chunhua Shen, Ian Reid, and An-
ton van den Hengel. Parallel attention: A uniﬁed framework
for visual object discovery through dialogs and queries. In
CVPR, 2018.

[39] Michael Rubinstein, Armand Joulin, Johannes Kopf, and Ce
Liu.. Unsupervised joint object discovery and segmentation
in internet images. In CVPR, 2013.

[40] Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki
Cheung, Alec Radford, and Xi Chen. Improved techniques
for training gans. In NIPS, 2016.

[41] Joseph Sivic, Bryan Russell, Alexei Efros, Andrew Zisser-
man, and William Freeman. Discovering objects and their
location in images. In ICCV, 2005.

[42] Joseph Sivic, Bryan Russell, Andrew Zisserman, William
Freeman, and Alexei Efros. Unsupervised discovery of vi-
sual object class hierarchies. In CVPR, 2008.

[43] Yaniv Taigman, Adam Polyak, and Lior Wolf. Unsupervised

cross-domain image generation. ICLR, 2017.

[44] J. Tenenbaum and W. Freeman. Separating style and content

with bilinear models. Neural Computation, 2000.

[45] C. Wah, S. Branson, P. Welinder, P. Perona, and S. Belongie.
The Caltech-UCSD Birds-200-2011 Dataset. Technical Re-
port CNS-TR-2011-001, 2011.

[46] Yaming Wang, Vlad I Morariu, and Larry S Davis. Weakly-
supervised discriminative patch learning via cnn for ﬁne-
grained recognition. CVPR, 2018.

[47] Junyuan Xie, Ross Girshick, and Ali Farhadi. Unsupervised

deep embedding for clustering analysis. In ICML, 2016.

[48] Wei Xu, Xin Liu, and Yihong Gong. Document clustering
based on non-negative matrix factorization. In SIGIR, 2003.
[49] Xinchen Yan, Jimei Yang, Kihyuk Sohn, and Honglak Lee.
Attribute2image: Conditional image generation from visual
attributes. In ECCV, 2016.

[50] Jianwei Yang, Anitha Kannan, Dhruv Batra, and Devi
Parikh. Lr-gan: Layered recursive generative adversarial net-
works for image generation. ICLR, 2017.

[51] Jianwei Yang, Devi Parikh, and Dhruv Batra. Joint unsuper-
vised learning of deep representations and image clusters. In
CVPR, 2016.

[52] Bangpeng Yao, Aditya Khosla, and Li Fei-Fei. Combining
randomization and discrimination for ﬁne-grained image cat-
egorization. In CVPR, 2011.

[53] Han Zhang, Tao Xu, Mohamed Elhoseiny, Xiaolei Huang,
Shaoting Zhang, Ahmed Elgammal, and Dimitris Metaxas.
Spda-cnn: Unifying semantic part detection and abstraction
for ﬁne-grained recognition. In CVPR, 2016.

[54] Han Zhang, Tao Xu, Hongsheng Li, Shaoting Zhang, and
Dimitris Metaxas. Stackgan: Text to photo-realistic im-
age synthesis with stacked generative adversarial networks.
ICCV, 2017.

[55] Han Zhang, Tao Xu, Hongsheng Li, Shaoting Zhang, Xi-
aogang Wang, Xiaolei Huang, and Dimitris Metaxas. Stack-
gan++: Realistic image synthesis with stacked generative ad-
versarial networks. arXiv: 1710.10916, 2017.

[56] Ning Zhang, Jeff Donahue, Ross Girshick, and Trevor Dar-
rell. Part-based r-cnns for ﬁne-grained category detection. In
ECCV, 2014.

[57] Junbo Zhao, Michael Mathieu, and Yann LeCun. Energy-

based generative adversarial network. ICLR, 2017.

[58] Heliang Zheng, Jianlong Fu, Tao Mei, and Jiebo Luo. Learn-
ing multi-attention convolutional neural network for ﬁne-
grained image recognition. In ICCV, 2017.

6499

