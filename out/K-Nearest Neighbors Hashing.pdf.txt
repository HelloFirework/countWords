K-Nearest Neighbors Hashing

Xiangyu He1

,

2, Peisong Wang1, Jian Cheng1

2

,

,

3

1 NLPR, Institute of Automation, Chinese Academy of Sciences, Beijing, China

2 University of Chinese Academy of Sciences, Beijing, China

3 Center for Excellence in Brain Science and Intelligence Technology, CAS, Beijing, China

{xiangyu.he, peisong.wang, jcheng}@nlpr.ia.ac.cn

Abstract

Hashing based approximate nearest neighbor search em-
beds high dimensional data to compact binary codes, which
enables efﬁcient similarity search and storage. However,
the non-isometry sign(·) function makes it hard to project
the nearest neighbors in continuous data space into the
closest codewords in discrete Hamming space. In this work,
we revisit the sign(·) function from the perspective of s-
pace partitioning. In speciﬁc, we bridge the gap between
k-nearest neighbors and binary hashing codes with Shan-
non entropy. We further propose a novel K-Nearest Neigh-
bors Hashing (KNNH) method to learn binary representa-
tions from KNN within the subspaces generated by sign(·).
Theoretical and experimental results show that the KNN re-
lation is of central importance to neighbor preserving em-
beddings, and the proposed method outperforms the state-
of-the-arts on benchmark datasets.

1. Introduction

Similarity search is a fundamental problem in machine
learning applications, such as clustering, matching, and
classiﬁcation. With the explosive growth of data size, tra-
ditional methods such as exhaustive search and Kd-tree,
ﬁnd themselves constrained by the huge size and high di-
mensionality. These problems lead to the boom of hashing
based approximate nearest neighbor search [7, 28, 29, 20].
Hashing methods encode high dimensional data into ver-
tices of binary hypercube while preserving the similarity in
original data space. Due to its low computational cost and
storage efﬁciency, the learning of similarity preserving bi-
nary codes has attracted much attention.

Traditional hashing methods consist of data independen-
t and data dependent approaches. The classic data inde-
pendent schemes include locality sensitive hashing (LSH)
family [1, 6, 26, 8], using random projections to construc-
t hashing functions. There is no doubt that LSH attains

the preponderant inﬂuence in the context of extremely high-
dimensional information retrieval. Nonetheless, LSH is still
an inefﬁcient learning strategy. Without considering the in-
put data, the efﬁcacy of LSH heavily relies on the coding
length. In contrast with the limitations of data independen-
t hashing, data dependent methods exploit the structure of
data or semantic information to learn the compact binary
representations.

Existing data dependent approaches can be further cate-
gorized into supervised and unsupervised schemes. Label-
based hashing, such as supervised hashing with kernels
[34], binary reconstruction embedding [25], supervised dis-
crete hashing [39] and order preserving hashing [42] utilize
semantic labels to optimize the binary hash codes or Ham-
ming distances between clusters. Recently, deep learning
has dramatically advanced the state-of-art [44, 46, 4, 45, 31,
30]. Both semantic representation and label information are
used in deep neural networks to learn hash codes. However,
high performance has been coupled with high computation-
al and storage overhead. As pointed out in [12], hashing al-
gorithms for learning binary codes and for encoding a new
test image should be efﬁcient and scalable.

Label-free hashing methods focus on the natural struc-
ture of data with no requirement on labels. Representa-
tive works include iterative quantization [12], anchor graph
hashing [35], spectral hashing [43], spherical hashing [18],
k-means hashing [17] and binary autoencoder [5]. Due to
the redundancy of input features, a common initial tech-
nique in hashing schemes is principal component analysis
(PCA) [43, 13, 22]. To deal with the variance (i.e., informa-
tion) imbalance among different PCA directions, ITQ [12]
utilizes an orthogonal rotation based on minimizing the
quantization error. Although ITQ is still the seminal method
in hashing, it is still unclear whether distortion minimiza-
tion leads to optimal binary codes.

In this paper, we demonstrate that learning hashing func-
tion only from quantization error minimization may remain
suboptimal. Inspired by Shannon entropy, we propose the

2839

Average quantization error: 0.9084

Average quantization error: 1.00

1

0

1

0

1

0

Average quantization error: 0.9094

-1
-1

0

1

-1
-1

0

1

-1
-1

0

1

(a) PCA aligned.

(b) ITQ rotation.

(c) KNNH transformation.

Figure 1: Toy illustration of K-Nearest Neighbors Hashing (KNNH). The basic idea of binary embedding is to quantize
data points to the closest vertex of the Hamming cube. (a) PCA leaves out the binary repesentation and splits each cluster
to different vertices. (b) ITQ found the optimized rotation, in the context of lowest quantization error. (c) KNN Hashing
endeavors to maintain the k-nearest neighbors within the same subspace during rotation (detailed in Section 2.4). Although
it yields even larger quantization error than ITQ, the proposed transfomation is closer to ideal space partitioning.

conditional entropy minimization, which eludes analysis on
sign(·) by transforming the hashing problem into a space
partitioning problem. With Kozachenko-Leonenko estima-
tor, we further prove that the conditional entropy minimiza-
tion encourages the data point and its k-nearest neighbors to
share the same hashing codes. As illustrated in Figure.1, the
proposed K-Nearest Neighbors Hashing (KNNH) transfor-
mation approaches optimum by preserving KNN within the
same subspaces (i.e., the same codewords). Extensive ex-
periments show that our method outperforms the state-of-
the-arts on benchmark datasets, which indicates the effec-
tiveness of the proposed theory in real-world applications.

2. Approach

2.1. Preliminary

Formally, denote input matrix X ∈ Rn×d as the con-
catenation of n vectors X = {xi}n
i=1. The vertices of an
axis-aligned c-dimensional hypercube is {−1, +1}c, denot-
ed as Bc. In general, the encoder bi = sign(xi) maps a
vector xi ∈ Rd to the closest vertexes bj ∈ Bc; hence, we
split Rd into 2c disjoint subspaces {S1, S2, ..., S2c} where
Sj = {x|sign(x) = bj}. Given i.i.d. samples {xi}n
i=1 from
the underlying probability density function p(x) for x ∈
Rd, we apply KNN estimator and re-substitution to non-
parametric estimation (described in Section 2.3). Then, we
p(x)dx.
For a discrete random variable Y with probability mass
function p(Y ), Shannon entropy is deﬁned as H(Y ) =

have p(bj) = Rx p(x, sign(x) = bj)dx = Rx∈Sj
−E{log p(y)} = −Py p(y) log p(y).

2.2. Mean square minimization

The authors of [11] formulated a variety of hashing
methods [12, 41, 43] and some other approximate nearest

neighbor search schemes [36, 21] within a uniﬁed frame-
work:

E = Xx

||x − d(e(x))||2
2

where e(·) and d(·) refers to encoder and decoder, e.g., x
is XR; e(·) is sign(·) and d(·) refers to scalar matrix in
ITQ [12]. A quantizer that minimizes E should map any x
to its nearest codeword in the codebook. We argure that this
objective is simple and intuitive but may not straight to the
hashing target.

It is common practice to turn E into well-known signal-

to-noise ratio (or signal-to-quantization-noise ratio) [14] :

SN R = 10 log10

E(||x||2)

E(||x − d(e(x))||2)

.

This target alone reﬂects the compressibility of data instead
of codewords similarity. In another word, distortion mini-
mization is a data compression system where E and SN R
focus on the minimization of reconstruction error. However,
hashing aims at the approximation of nearest neighbors us-
ing codewords. There is no guarantee that optimized com-
pression leads to the closest codewords since a cluster near
the endpoints of a quantization interval can be split into d-
ifferent codewords.

2.3. Conditional entropy minimization

Under the constraint of orthogonal transformation, the
relation of nearest neighbors can be preserved during rota-
tion. However, this beneﬁt may bring us to another pitfal-
l: orthogonality is the guarantee of order-preserving. This
condition holds when we relax our discrete hashing codes
to be a continuous variable ˜b ∈ Rc.
It is obvious that
||Rxi −Rxj||2 = ||xi −xj||2 when RT R = I. But the exis-
tence of non-smooth encoder makes ||e(Rxi)−e(Rxj)||2 ≤

2840

Estimated H(B|V): 0.078 bit

0

1

1

0

-1
-1

0.6
0.5
0.4
0.3
0.2
0.1
0

1

0

-1
-1

Estimated H(B|V): 0.074 bit

0

1

1.2

1

0.8

0.6

0.4

0.2

0

1

0

-1
-1

Estimated H(B|V): 0.042 bit

1.2

1

0.8

0.6

0.4

0.2

0

0

1

(a) Random rotation.

(b) ITQ rotation.

(c) KNNH transformation.

Figure 2: The contribution (i.e., ln ǫ(vi;Svi )
to lower conditional entropy than ITQ rotation due to less confusing points near boundary.

) of each data point to ˆH(B|V ), shown in colormap. KNN based shrinkage leads

ǫ(vi)

||xi − xj||2 an open problem (i, j in a neighborhood). To
overcome this issue, early works turn to relaxed hashing
function such as Sigmoid(·) [42] and tanh(·) [33] to ap-
proximate original problem. We show that it is feasible
to create the direct relation between features and hashing
codes without approximation.

To directly model the connections between binary code-
words and real-valued features, we circumvent the non-
smooth sign(·) function and become interested in the sub-
spaces partitioned by sign(·). Note that the number of com-
ponents in a space partition usually plays a central role in
probability and statistical learning theory, and the relation-
ship between minimum mean-square and mutual informa-
tion have been discussed in [38, 15, 16]. All those works
inspire us to describe the hashing process in information-
theoretic criteria :

min H(B|V );

V = f (X)

where B = sign(V ), the feature vi is from a continuous
distribution and bj is the discrete output gallery codes. This
target minimizes the uncertainty in B when V is known. In
other words, the optimal feature representation should make
it easy to determine their codewords.

The objective conforms to our intuition, but the plug-in
method heavily relies on the approximation of probability
density function over bins. Formally,

H(B|V ) ≡ Zv

p(v)H(B|V = v)dv

≈ −Xi,j

pv,b(i, j) log

pv,b(i, j)

pv(i)

(1)

(2)

where pv(i) = Ri µi(v)dv, the integration of estimated den-
sity µ(v) over ith bin and pv,b(i, j) = Ri µi(v ∈ Sj)dv.

Clearly, it would be impractical to set the right side of E-
q.(1) as the optimization target. To bridge over the obstacle,

we utilize the alternate format of H(B|V ),

H(B) − H(B|V ) = I(B; V ) = H(V ) − H(V |B)

H(B|V ) = H(B) − H(V ) + H(V |B).

(3)

For the estimation of differential entropy, we further intro-
duce the well-known Kozachenko-Leonenko estimator [23]

ˆH(V ) = −ψ(k) + ψ(n) + ln cd +

d
n

n

Xi=1

ln ǫk(vi)

(4)

where ψ(·) is the digamma function, cd is the volume of the
d-dimensional unit ball and ǫk(vi) is twice the disance from
vi to its kth nearest neighbor. Compared with conventional
estimators based on binnings, Eq.(4) has minimal bias and
estimates only from KNN distances. This property will ease
the later derivations and lead to our hashing method.

From Eq.(4), we further estimate ˆH(V |B) = Pj p(v ∈
Sj) ˆH(V |v ∈ Sj) in disjoint subspaces, which erases the
error made in the individual integration over deﬁnite bins
(E.q. (2)), so that

ˆH(B|V ) =(cid:0) −

2c

Xj=1

|Sj|
n

ln

|Sj|

n (cid:1)−

d
n

n

Xi=1

ln ǫk(vi)(cid:1)+

(cid:0) − ψ(k) + ψ(n) + ln cd +
Xj=1
(cid:0)

|Sj|

2c

n (cid:0) − ψ(k) + ψ(|Sj|) + ln cd+
Xi=1
ln ǫk(vi; v ∈ Sj)(cid:1)(cid:1).

n

d
|Sj|

Here |Sj| refers to the number of data points in space Sj
and ǫk(vi; v ∈ Sj) is twice the distance from vi to its KNN
in Sj , given sign(vi) = bj . Note that ǫk(vi; v ∈ Sj) makes

(5)

2841

Algorithm 1: Unconstrained KNN Hashing.
Data: A set of data points {Xi}n

i=1 ∈ Rd in the form

of X ∈ Rn×d.

Result: Codewords B ∈ {−1, +1}n×c and
transformation matrix W ∈ Rc×c.

X ∈ Rn×c ← φ(X);
// Dimensional reduction, PCA in this work;
while W not converged do

V = XW ; // Here, f (·) is a linear projection;
Ω ← Euclidean-KNNSearch(V ) ∈ Nn×k;
// Return the indexes of KNN;
for j = 1 : n do

Vj ← mean(V [Ωj]) ∈ R1×c;
// Update V , i.e. KNN Shrinkage;

end
W = arg min ||sign(V ) − XW ||2
F ;

end
B = sign(V );
return B, W ;

each feature point hold its KNN only when its KNN is in the
same space as vi. In this case, we simplify the double sum-

mationPj Pi ln ǫk(vi; v ∈ Sj) toPi ln ǫk(vi; Svi ) where

Svi = {v|sign(v) = bj = sign(vi)}. By substituting this
term into Eq.(5) and approximating digamma function as
ψ(n) = ln n − 1
n4 ) [2], H(B|V ) can be
further written as

12n2 + O( 1

2n − 1

ˆH(B|V ) =

d
n

n

Xi=1

ln

ǫk(vi; Svi )

ǫk(vi)

+

|

1 − m

2n

term I

{z

1
n

−

|

}

1

m

Xj=1
{z

term II

+ O(

12|Sj|

(6)

1
n2 )
}

where m is the number of Sj satisfying |Sj| 6= 0. For m ≪
n, it is clear that ˆH(B|V ) dominated by term I with term II
approaching zero. This result leaves us two insights: 1) the
information loss of binarization comes from the data near
the boundary, as shown in Figure.2 where warm colors are
distributed among coordinate axes; and 2) ˆH(B|V ) should
decrease when KNN of vi all come from the same space.
As for m < n, the second term is still lower bounded by
2n − n/12
1−n
12 , and we can deﬁne a larger ǫk(vi; Svi )
when k > |Sj| to penalize the singletons (spaces with few
samples) and to balance the contribution to the uncertainty
between two terms.

n ≈ − 7

2.4. K nearest neighbors hashing

Although Eq.(6) has been more concrete than Eq.(1), it is
still hard to put criteria into practice. Therefore, we propose

Algorithm 2: Orthogonal KNN Hashing.
Data: A set of data points {Xi}n

i=1 ∈ Rd in the form

of X ∈ Rn×d.

Result: Codewords B ∈ {−1, +1}n×c and rotation

matrix R ∈ Rc×c.

X ∈ Rn×c ← φ(X);
// Dimensional reduction, PCA in this work;
Ω ← Euclidean-KNNSearch(X) ∈ Nn×k;
// Return the indexes of KNN;
for j = 1 : n do

Xj ← mean(X[Ωj]) ∈ R1×c;
// Update X, i.e. KNN Shrinkage;

end
B, R = arg min
RT R=I

||sign(XR) − XR||2
F ;

// Classical hashing problem;
return B, R;

a simple heuristic method to construct V , which reduces
ˆH(B|V ) from the view of KNN distance. This idea begins
with an unconstrained method and reﬁned by an orthogonal
constraint.

Unconstrained method As shown in Eq.(6), the outlier
of the cluster is more likely to drop into different spaces
and is far more sensitive to its KNN than center points. In
another word, ǫ(vi; Svi ) of outliers may hugely change in a
small step towards cluster center, especially for each feature
dimension V (i) ∼ N (0, σ2). Hence, we propose the reduc-
tion in the volume of the cluster based on KNN, i.e., KNN
shrinkage. To alleviate the impact of outliers, we recon-
struct each feature point by the mean value of its k-nearest
neighbors recursively (from 2-nn to k+1-nn in case 1-nn
is still an outlier). That is, updated feature points ˆv will be
used in the following iterations (for loop in Algorithm 1,2).
In fact, every feature point can be viewed as the weight-
ed average with all the others. As illustrated in Figure.2,
shrinkage step plays a key role in the decrease of ˆH(B|V ).
Beneﬁting from this information gain, min ||sign(ˆv) − v||2
will better preserve the relation between original feature s-
pace and Hamming space. So far, we obtain the uncon-
strained KNNH, shown in Algorithm 1.

Orthogonal method Although the unconstrained method
has taken ǫ(vi; Svi ) into consideration, there are two in-
evitable problems in practice: 1) computational time, e.g.,
KNN search and shrinkage in while loop will take plenty of
time due to massive computation and memory read/writes;
and 2) without constraint, the only solution is the trivial one.
Transformation matrix W minimizes ||sign(V ) − XW ||F
at the cost of losing KNN relations, where most data points

2842

Table 1: Comparsions of different representative unsupervised hashing methods on the MNIST dataset. Each image was
represented as a 784-D (28 × 28) gray-scale feature vector by using its intensity.

Method

LSH[1]
SH[43]
PCAH[41]
SpH[18]
KMH[17]
ITQ[12]
KNNH

Hamming Ranking (mAP,%)

16

20.88
26.64
27.33
25.81
32.12
41.18
47.33

32

25.83
25.72
24.85
30.77
33.29
43.82
53.25

64

31.71
24.10
21.47
34.75
35.78
45.37
56.03

precision (%)@N=1000
16
64

32

37.77
56.29
56.56
49.48
60.43
66.39
67.95

50.16
61.29
59.99
61.27
67.19
74.04
75.89

61.73
61.98
57.97
69.85
72.65
77.42
79.04

precision (%)@r=2

16

25.10
57.52
36.36
51.71
61.88
65.73
71.82

32

55.61
65.31
65.54
64.26
68.85
73.14
69.08

are packed into few buckets. Fortunately, an orthogonal
constraint does address both problems simultaneously.

Pi∈Ωj

(XR)i is equivalent to (Pi∈Ωj

vectors and angles between vectors,
should be maintained during iterations.

Since orthogonal transformation preserves lengths of
the KNN relation
In this context,
Xi)R and we can
move KNN search and shrinkage outside of the loop. Note
that, the objective then becomes min ||sign(ˆv) − ˆv||2. That
is a natural two-stage scheme: KNN based shrinkage and
classical hashing problem, shown in Algorithm 2. Intuitive-
ly, one may argue that we just replace v by ˆv in original
hashing problem, but on the other hand, if we have V which
satisﬁes H(B|V ) = 0, a single ”sign(·)” should solve the
hashing problem. At inference time, we directly apply the
learned linear projections to unseen data points, i.e., testing
samples, without KNN shrinkage.

3. Results

3.1. Datasets & Evaluation protocol

We evaluate the proposed K-Nearest Neighbors Hashing
(KNNH) on three balanced benchmark datasets: CIFAR-
10 [24], MNIST [27] and Places205 [47, 3], and we fur-
ther verify the performance on an extremely imbalanced
dataset: LabelMe-12-50K [40]. CIFAR-10 dataset con-
sists of 60,000 images of 10 classes. Each class contains
6,000 32x32 colour images. MNIST is a dataset containing
70,000 gray handwritten digit images in 10 classes. Each
image is represented by a 28x28 gray-scale intensity matrix.
Different from former ones, LabelMe-12-50K consists of
50,000 256x256 JPEG images of 12 classes, the data dis-
tribution among classes is imbalanced. Five large sample
classes take 91% images and the smallest class contains on-
ly 0.6% samples. Besides, 50% of the images show a cen-
tered object and remaining 50% show a randomly selected
region of a randomly selected image. This attribute matches
the real-world challenge of image retrieval. As instances of
other object classes may also be present in the image, we
choose the object class with the largest label value as image

labels. Places205 is a very challenging dataset due to its
large size and number of categories, which contains 2.5M
images from 205 scene categories. Following [3], we use
the CNN features extracted from the fc7 layer of ImageNet
pre-trained AlexNet and reduce the dimensionality to 128
using PCA.

We use the following evaluation metrics to measure the
performance of methods: 1) mean Average Precision (mAP)
which evaluates the overall performance on different ob-
ject classes; 2) precision of Hamming radius of 2 (preci-
sion@r=2) which measures precision on retrieved images
having Hamming distance to query≤2 (we report zero pre-
cision for the queries if no image satisfy); 3) precision at
N samples (precision@N) which refers to the percentage of
true neighbors on top N retrieved samples. In our experi-
ments, we strictly follow the same comparison settings in
previous works, most of the results are directly reported by
the authors. Besides, in order to improve the statistical sta-
bility, we repeated the experiments 10 times and took the
average as the ﬁnal result. Since the performance on small
sample classes is more sensitive to the queries, we execute
the experiments on LabelMe-12-50K 50 times to get the re-
sults. To prove that min H(B|X) leads to better codewords
than straightforward quantization minimization, the hashing
problem in KNNH was solved by ITQ, and we fully com-
pare both methods on different datasets.

3.2. Results on balanced datasets

Following the same setting in [32, 9], we randomly se-
lected 1000 samples from CIFAR-10, 100 per class, as the
query data, and the remaining 59000 images as the gallery
set. For MNIST dataset, we randomly sampled 100 per
class, 1000 images in total, as the query data, and used
the remaining 69000 images as the gallery set. The ground
truths of queries are based on their class labels. Since hash-
ing methods are independent of input features, we compare
our method with representative hashing by using both hand-
crafted and deep features. In this subsection, we set k as 20
and make no effort on the ﬁne-tuning.

2843

Table 2: Comparsions of different representative unsupervised hashing methods on the CIFAR-10 dataset. Each image was
represented as a 512-D GIST feature vector.

Method

LSH[1]
SH[43]

PCAH[41]
SpH[18]
KMH[17]
ITQ[12]
KNNH

Hamming Ranking (mAP,%)

16

12.55
13.19
13.23
14.54
16.05
16.57
17.32

32

13.76
12.97
12.89
15.16
16.19
17.34
18.76

64

15.07
13.18
12.30
15.90
15.79
17.91
19.54

precision (%)@N=1000
16
64

32

16.21
17.74
17.86
19.68
21.21
22.08
22.52

19.10
17.93
17.91
21.30
22.56
23.98
25.48

22.25
18.43
16.91
23.00
22.83
25.21
27.08

precision (%)@r=2

16

16.73
19.42
21.80
21.92
23.48
23.92
23.36

32
7.07
21.73
3.00
14.53
12.80
16.90
15.05

Table 3: Comparsions with deep learning methods and supervised methods. The top section are the unsupervised methods
and the bottom section are the supervised methods (start from SDH).

Method

Hamming Ranking (mAP,%)

16

32

64

precision (%)@N=1000
64
16

32

Deepbit[31]

DH[32]

UHBDNN[9]

KNNH

DH[32]

UHBDNN[9]

KNNH

SDH[32]
SPLH[41]
BRE[25]

14.35
16.17
17.83
17.32

43.14
45.38
47.33

46.75
44.20
33.34

16.33
16.62
18.52
18.76

44.97
47.21
53.25

51.01
48.29
35.09

CIFAR-10 Query=1,000
–

–

17.97
16.96

23.79

26.00

27.70

–

–

–

–

22.52

19.54
MNIST Query=1,000
46.74

67.89

25.48

74.72

–

56.03

52.50
48.34
36.80

–

67.95

65.19
62.98
60.72

–

75.89

70.18
67.89
68.86

–

27.08

78.63

–

79.04

72.33
67.99
73.08

precision (%)@r=2

16

–

23.33
24.97
23.36

66.10
69.13
71.82

63.92
63.71
34.09

32

–

15.77
18.85
15.05

73.29
75.26
69.08

77.07
74.06
64.21

Table 1 shows the retrieval results of different hashing
methods on the MNIST dataset. Each image is represented
by a 784-dimensional gray-scale feature vector by using its
intensity [37]. It is obvious that KNNH outperforms other
representative unsupervised hashing methods on nearly ev-
ery criteria. Table 2 obtains the same results on the CIFAR-
10 dataset. KNNH mainly contributes to the increase of
mAP, which directly reﬂects the changes in the order of re-
calls. Note that the precision@r=2 values by KNNH are
not very good but p@r=2 is actually different from the
well-known R-precision which describes one point on the
precision-recall curve (we use p@r=2 because it is popular
in recent deep hashings). In our experiments, though the
p@r=2 values by KNNH are rather poor, the recall@r=2
of KNNH are much higher than baselines. It is common to
compare the precision of two points on different PR curves
with the same recall, otherwise the comparison is unfair.
Here is the same case. Since r=2 can be an empirical set-
ting to reduce the number of retrieval results, we also show
the values of precision@1K as an alternative.

Although deep unsupervised hashing methods have at-
tracted much attention, we show that linear transforma-
tion can achieve competitive results. Since Deepbit report-
ed mAP@1K rather than mAP in [31], we rerun the open
source codes and report the updated mAP in Table 3. Com-
pared with deep hashing, our approach is still in the lead of
mAP at 32/64bit. It is interesting that KNNH even surpasses
a few supervised methods on MNIST.

In [46, 45, 9, 19], the authors use pre-trained CNN fea-
tures as input for non-CNN-based hashing methods, all ap-
proaches achieve higher performances in most of evaluation
metrics. Follow that setting, we use VGG features as input
for CIFAR-10 and set up similar experiments. The query
set contains 6,000 randomly sampled images (10% images
per class) and the rest 54,000 image are used as the gallery
set. For MNIST dataset, we evaluate the performances on
GIST 512-D descriptor since MNIST is grayscale. Sim-
ilar to CIFAR-10, we randomly sample 10% images per
class, as the query data, and use the remaining images as
the training set and retrieval database. Table 4 shows that

2844

Table 4: mAP (%) for different unsupervised methods using high-level features. We reported the results on RGB dataset-
s (CIFAR-10, LabelMe) using VGG-FC7 descriptor and MNIST using GIST 512-D descriptor.

Method

VGG+SH[43]
VGG+SpH[18]
VGG+KMH[17]

VGG+BA[5]
VGG+ITQ[12]
VGG+KNNH

16

18.31
18.82
18.68
25.38
26.82
29.06

CIFAR-10

LabelMe-12-50K

MNIST

32

16.54
20.93
20.82
26.16
27.38
30.82

64

15.78
23.40
22.87
27.99
28.73
32.60

16

12.60
13.59
13.36
16.96
18.06
20.13

32

12.59
15.10
15.47
18.42
19.40
23.79

64

12.24
17.03
16.58
20.80
20.71
26.22

16

32.59
31.27
31.96
48.48
46.37
53.07

32

33.23
36.80
37.39
51.72
50.59
61.11

64

30.65
41.40
41.11
52.73
53.69
65.55

Table 5: Comparsions with ITQ[12] on the small sample classes of imbalanced dataset. mAP (%, 32-bit) using GIST 512-D
and VGG-FC7 descriptor was reported. Proportion reﬂects the number of each class accounts for the whole samples.

Class

Proportion

ITQ[12]
KNNH

VGG+ITQ[12]
VGG+KNNH

Increase

All Small Sample Classes in LabelMe-12-50K
table
0.6%

chair
1.1%

door
2.2%

bookshelf

1.0%

sign
2.5%

keyboard

0.9%

head
0.7%

Hamming Ranking (mAP,%)

3.46
3.80

5.44
7.19
1.32×

4.76
4.82

4.05
4.79
1.18×

2.43
2.50

12.33
19.42
1.58×

1.38
1.42

3.72
4.99
1.34×

0.74
0.75

1.31
1.42
1.08×

6.94
12.75

9.76
20.48
2.10×

1.56
1.86

7.92
14.61
1.84×

our method consistently outperforms others along with the
increase of bit-width.

3.3. Results on imbalanced dataset

Imbalanced data problem has always been a hot topic in
the machine learning community. In this section, we evalu-
ate the performance of KNNH on an extremely imbalanced
dataset: LabelMe-12-50K. As the smallest class contains
only ∼ 300 images, we randomly selected 10% images per
class, as the query data, and used the ∼ 45, 000 images as
the gallery set. The ground truths of queries are based on
their class labels.
In this subsection, we set k as 20 and
make no effort on the ﬁne-tuning.

To avoid the results dominated by the large sample class-
es, we report the mAP in Table 4 which is the macro aver-
age results for all classes. There is no doubt that KNNH
takes the lead at 16/32/64 bits. However, the overall perfor-
mance is not sufﬁciently convincing, we further report the
mAP at all small classes in Table 5. The results show that
KNNH does outperform the state-of-art method on difﬁcult
retrieval tasks. Besides, in combination with discriminating
features, KNNH further enhances the hashing quality with
the increase of bit-width. In some cases, we achieve 200%
improvement, but to be honest, our results are still poor.
1.42% mAP is clearly a large space to investigate.

3.4. Results on large scale dataset

To meet the real-world challenge, we further evaluate
KNNH on the large-scale Places205 dataset [47]. We ran-
domly sample 100 images from each class to construct a
test set of 20,500 images and use the rest ∼ 2.5M images as
the retrieval set. The ground truths of queries are based on
their class labels. Since Places205 is much larger than pre-
vious datasets, we change k to 200 and make no effort on
the ﬁne-tuning. As shown in Table 6, our approach consis-
tently surpasses representative unsupervised hashing meth-
ods on mAP .

3.5. Performance under various k

The performance of k-nn algorithms can be severely de-
graded by the selection of k. But, an effective method
should achieve the consistent performance in a wide range
of k.
Figure.3 shows the robustness of our approach.
KNNH consistently outperforms the leading method by
a large margin. The results are compelling that our 16-
bit KNNH has already surpassed 64-bit ITQ on MNIST
datasets.

3.6. Computation time

Lastly, we analyze the computation time in practice. S-
ince we did not introduce extra computation or storage at

2845

Table 6: Comparsions of different representative unsupervised hashing methods on the Places205 dataset. Each image was
represented by CNN features extracted from the AlexNet-FC7, and reduce the dimensionality to 128 using PCA.

Method

SpH[18]
SH[43]
PCAH[41]
KMH[17]

BA[5]
ITQ[12]
KNNH

Hamming Ranking (mAP,%)

16
3.36
4.44
4.66
4.78
5.73
5.89
7.60

32
5.15
6.67
7.60
7.65
9.65
9.69
12.17

64
7.45
8.50
10.74
10.60
13.44
13.53
15.92

32

precision (%)@N=1000
16
64
8.83
11.38
11.89
12.10
12.40
12.53
13.45

14.35
17.57
19.28
19.22
20.24
20.16
21.04

19.54
22.11
25.63
25.32
26.03
26.28
26.43

19.5

19.0

P
A
m

18.5

18.0

17.5

17.0

64 bits KNNH

32 bits KNNH

16 bits KNNH

64 bits ITQ

P
A
m

56

54

52

50

48

46

precision (%)@r=2

16
5.67
7.36
8.22
8.29
7.96
7.99
8.76

32

18.84
22.44
24.60
24.65
23.65
23.32
19.99

64 bits KNNH

32 bits KNNH

16 bits KNNH

64 bits ITQ

5

10

15
k

(a) CIFAR-10.

20

25

5

10

15
k

20

25

(b) MNIST.

Figure 3: Comparsions on CIFAR-10 and MNIST with ITQ under different k. We reported the results on CIFAR-10 dataset
using GIST 512-D descriptor and MNIST using 784-D (28 × 28) intensity feature vector. Since ITQ has no connection with
k, the performance remains the same as the blue solid line depicted in both ﬁgures.

inference time, KNNH keeps the same speed as the algo-
rithm to solve the second stage hashing problem.
In our
experiments, the testing time of KNNH on 32-bit Cifar-10
is 1.7 × 10−6 seconds with an Intel 3.0GHz CPU. Hence,
we focus on the training time of KNN search and KNN
shrinkage. Formally, given d dimensional features, KNN
shrinkage has the linear time complexity: O(n) (approx-
imately kn memory reads, n memory writes, (k − 1)nd
additions/subtractions and nd multiplications). Therefore,
the main issue of KNNH is its huge complexity in exhaus-
tive KNN search: O(n2d) for the distances computing and
O(n2 log n) for sortings.

By utilizing the power of GPU on parallel computing
[10], we reduce the search time on CIFAR-10 (32-bit) from
27.06s to 1.81s (3.00GHz Intel CPU vs. Nvidia TITAN
Xp). MNIST and LabelMe share a similar computation
time on 32-bit, which is 2.43s and 1.09s, respectively. For
Places205, the training time is about 110 minutes, since k is
10× larger than training on small datasets and the huge da-
ta size limits the further GPU speedup. Besides, we noticed
that the dimension of the feature points has only a smal-
l impact on the computation time, which makes it possible

to increase the bit-width to achieve higher performance. In
general, our training method can be implemented within a
reasonable time without losing the performance of runtime
speed.

4. Conclusion

We have introduced a hidden factor in learning hashing
codes, which is the k-nearest neighbors’ relation in sub-
spaces. By adopting the view of conditional entropy mini-
mization, we further propose a simple but effective method
to enhance hashing quality. In a word, we create a direc-
t connection between binary codewords and input features
through k-nearest neighbors. Future works should extend
those results to other datasets. The direct minimization of
H(B|V ) is also worthy of further discussions.

5. Acknowledgement

This work was supported in part by National Natural Sci-
ence Foundation of China (No.61876182, 61872364), the
Strategic Priority Research Program of Chinese Academy
of Science(No.XDB32050200).

2846

References

[1] Alexandr Andoni and Piotr Indyk. Near-optimal hashing al-
gorithms for approximate nearest neighbor in high dimen-
sions. Commun. ACM, 51(1):117–122, 2008.

[2] J. M. Bernardo. Algorithm as 103: Psi (digamma) function.
Journal of the Royal Statistical Society. Series C (Applied
Statistics), 25(3):315–317, 1976.

[3] Fatih C¸ akir, Kun He, Sarah Adel Bargal, and Stan Sclaroff.
Mihash: Online hashing with mutual information. In IEEE
International Conference on Computer Vision, ICCV 2017,
Venice, Italy, October 22-29, 2017, pages 437–445, 2017.

[4] Yue Cao, Mingsheng Long, Jianmin Wang, Han Zhu, and
Qingfu Wen. Deep quantization network for efﬁcient image
retrieval. In Proceedings of the Thirtieth AAAI Conference on
Artiﬁcial Intelligence, February 12-17, 2016, Phoenix, Ari-
zona, USA., pages 3457–3463, 2016.

[5] Miguel ´A. Carreira-Perpi˜n´an and Ramin Raziperchikolaei.
In IEEE Conference
Hashing with binary autoencoders.
on Computer Vision and Pattern Recognition, CVPR 2015,
Boston, MA, USA, June 7-12, 2015, pages 557–566, 2015.

[6] Moses Charikar.

Similarity estimation techniques from
rounding algorithms. In Proceedings on 34th Annual ACM
Symposium on Theory of Computing, May 19-21, 2002,
Montr´eal, Qu´ebec, Canada, pages 380–388, 2002.

[7] Jian Cheng, Cong Leng, Jiaxiang Wu, Hainan Cui, and Han-
qing Lu. Fast and accurate image matching with cascade
hashing for 3d reconstruction.
In 2014 IEEE Conference
on Computer Vision and Pattern Recognition, CVPR 2014,
Columbus, OH, USA, June 23-28, 2014, pages 1–8, 2014.

[8] Mayur Datar, Nicole Immorlica, Piotr Indyk, and Vahab S.
Mirrokni. Locality-sensitive hashing scheme based on p-
stable distributions. In Proceedings of the 20th ACM Sym-
posium on Computational Geometry, Brooklyn, New York,
USA, June 8-11, 2004, pages 253–262, 2004.

[9] Thanh-Toan Do, Anh-Dzung Doan, and Ngai-Man Cheung.
Learning to hash with binary deep neural network. In Com-
puter Vision - ECCV 2016 - 14th European Conference, Am-
sterdam, The Netherlands, October 11-14, 2016, Proceed-
ings, Part V, pages 219–234, 2016.

[10] Vincent Garcia, Eric Debreuve, and Michel Barlaud. Fast k
nearest neighbor search using GPU. In IEEE Conference on
Computer Vision and Pattern Recognition, CVPR Workshops
2008, Anchorage, AK, USA, 23-28 June, 2008, pages 1–6,
2008.

[11] Tiezheng Ge, Kaiming He, Qifa Ke, and Jian Sun. Opti-
mized product quantization for approximate nearest neigh-
bor search. In 2013 IEEE Conference on Computer Vision
and Pattern Recognition, Portland, OR, USA, June 23-28,
2013, pages 2946–2953, 2013.

[12] Yunchao Gong, Svetlana Lazebnik, Albert Gordo, and
Iterative quantization: A procrustean
large-scale im-
IEEE Trans. Pattern Anal. Mach. Intell.,

Florent Perronnin.
approach to learning binary codes for
age retrieval.
35(12):2916–2929, 2013.

[13] Albert Gordo, Florent Perronnin, Yunchao Gong, and Svet-
lana Lazebnik. Asymmetric distances for binary embed-

dings. IEEE Trans. Pattern Anal. Mach. Intell., 36(1):33–47,
2014.

[14] R. Gray. Vector quantization. IEEE ASSP Magazine, 1(2):4–

29, April 1984.

[15] Dongning Guo, Shlomo Shamai, and Sergio Verd´u. Mu-
tual information and minimum mean-square error in gaus-
sian channels. IEEE Trans. Information Theory, 51(4):1261–
1282, 2005.

[16] Dongning Guo, Yihong Wu, Shlomo Shamai (Shitz), and
Sergio Verd´u. Estimation in gaussian noise: Properties of
the minimum mean-square error. IEEE Trans. Information
Theory, 57(4):2371–2385, 2011.

[17] Kaiming He, Fang Wen, and Jian Sun. K-means hashing:
An afﬁnity-preserving quantization method for learning bi-
nary compact codes. In 2013 IEEE Conference on Comput-
er Vision and Pattern Recognition, Portland, OR, USA, June
23-28, 2013, pages 2938–2945, 2013.

[18] Jae-Pil Heo, Youngwoon Lee, Junfeng He, Shih-Fu Chang,
and Sung-Eui Yoon. Spherical hashing. In 2012 IEEE Con-
ference on Computer Vision and Pattern Recognition, Provi-
dence, RI, USA, June 16-21, 2012, pages 2957–2964, 2012.
[19] Tuan Hoang, Thanh-Toan Do, Dang-Khoa Le Tan, and Ngai-
Man Cheung. Enhancing feature discrimination for unsu-
pervised hashing.
In 2017 IEEE International Conference
on Image Processing, ICIP 2017, Beijing, China, September
17-20, 2017, pages 3710–3714, 2017.

[20] Qinghao Hu, Peisong Wang, and Jian Cheng. From hash-
ing to cnns: Training binary weight networks via hashing.
In Proceedings of the Thirty-Second AAAI Conference on
Artiﬁcial Intelligence, (AAAI-18), the 30th innovative Ap-
plications of Artiﬁcial Intelligence (IAAI-18), and the 8th
AAAI Symposium on Educational Advances in Artiﬁcial In-
telligence (EAAI-18), New Orleans, Louisiana, USA, Febru-
ary 2-7, 2018, pages 3247–3254, 2018.

[21] Herv´e J´egou, Matthijs Douze, and Cordelia Schmid. Prod-
IEEE Trans.

uct quantization for nearest neighbor search.
Pattern Anal. Mach. Intell., 33(1):117–128, 2011.

[22] Herve Jegou, Matthijs Douze, Cordelia Schmid, and Patrick
P´erez. Aggregating local descriptors into a compact image
representation.
In The Twenty-Third IEEE Conference on
Computer Vision and Pattern Recognition, CVPR 2010, San
Francisco, CA, USA, 13-18 June 2010, pages 3304–3311,
2010.

[23] Alexander Kraskov, Harald St¨ogbauer, and Peter Grassberg-
er. Estimating mutual information. Phys. Rev. E, 69:066138,
Jun 2004.

[24] Alex Krizhevsky and Geoffrey Hinton. Learning multiple

layers of features from tiny images. 2009.

[25] Brian Kulis and Trevor Darrell. Learning to hash with bina-
ry reconstructive embeddings. In Advances in Neural Infor-
mation Processing Systems 22: 23rd Annual Conference on
Neural Information Processing Systems 2009. Proceedings
of a meeting held 7-10 December 2009, Vancouver, British
Columbia, Canada., pages 1042–1050, 2009.

[26] Brian Kulis and Kristen Grauman. Kernelized locality-
sensitive hashing for scalable image search.
In IEEE 12th
International Conference on Computer Vision, ICCV 2009,

2847

[40] Rafael Uetz and Sven Behnke. Large-scale object recogni-
tion with cuda-accelerated hierarchical neural networks. In
Intelligent Computing and Intelligent Systems, 2009. ICIS
2009. IEEE International Conference on, volume 1, pages
536–541. IEEE, 2009.

[41] Jun Wang, Sanjiv Kumar, and Shih-Fu Chang.

Semi-
supervised hashing for large-scale search. IEEE Trans. Pat-
tern Anal. Mach. Intell., 34(12):2393–2406, 2012.

[42] Jianfeng Wang, Jingdong Wang, Nenghai Yu, and Shipeng
Li. Order preserving hashing for approximate nearest neigh-
bor search.
In ACM Multimedia Conference, MM ’13,
Barcelona, Spain, October 21-25, 2013, pages 133–142,
2013.

[43] Yair Weiss, Antonio Torralba, and Robert Fergus. Spec-
tral hashing. In Advances in Neural Information Processing
Systems 21, Proceedings of the Twenty-Second Annual Con-
ference on Neural Information Processing Systems, Vancou-
ver, British Columbia, Canada, December 8-11, 2008, pages
1753–1760, 2008.

[44] Huei-Fang Yang, Kevin Lin, and Chu-Song Chen. Super-
vised learning of semantics-preserving hash via deep convo-
lutional neural networks. IEEE Trans. Pattern Anal. Mach.
Intell., 40(2):437–451, 2018.

[45] Ting Yao, Fuchen Long, Tao Mei, and Yong Rui. Deep
semantic-preserving and ranking-based hashing for image
retrieval.
In Proceedings of the Twenty-Fifth International
Joint Conference on Artiﬁcial Intelligence, IJCAI 2016, New
York, NY, USA, 9-15 July 2016, pages 3931–3937, 2016.

[46] Ruimao Zhang, Liang Lin, Rui Zhang, Wangmeng Zuo,
and Lei Zhang. Bit-scalable deep hashing with regular-
ized similarity learning for image retrieval and person re-
identiﬁcation. IEEE Trans. Image Processing, 24(12):4766–
4779, 2015.

[47] Bolei Zhou, `Agata Lapedriza, Jianxiong Xiao, Antonio Tor-
ralba, and Aude Oliva. Learning deep features for scene
recognition using places database.
In Advances in Neural
Information Processing Systems 27: Annual Conference on
Neural Information Processing Systems 2014, December 8-
13 2014, Montreal, Quebec, Canada, pages 487–495, 2014.

Kyoto, Japan, September 27 - October 4, 2009, pages 2130–
2137, 2009.

[27] Yann LeCun, L´eon Bottou, Yoshua Bengio, and Patrick
Haffner. Gradient-based learning applied to document recog-
nition. Proceedings of the IEEE, 86(11):2278–2324, 1998.

[28] Cong Leng, Jiaxiang Wu, Jian Cheng, Xiao Bai, and Han-
qing Lu. Online sketching hashing.
In IEEE Conference
on Computer Vision and Pattern Recognition, CVPR 2015,
Boston, MA, USA, June 7-12, 2015, pages 2503–2511, 2015.
[29] Cong Leng, Jiaxiang Wu, Jian Cheng, Xi Zhang, and Han-
qing Lu. Hashing for distributed data. In Proceedings of the
32nd International Conference on Machine Learning, ICML
2015, Lille, France, 6-11 July 2015, pages 1642–1650, 2015.
[30] Qi Li, Zhenan Sun, Ran He, and Tieniu Tan. Deep super-
vised discrete hashing. In Advances in Neural Information
Processing Systems 30: Annual Conference on Neural Infor-
mation Processing Systems 2017, 4-9 December 2017, Long
Beach, CA, USA, pages 2479–2488, 2017.

[31] Kevin Lin, Jiwen Lu, Chu-Song Chen, and Jie Zhou. Learn-
ing compact binary descriptors with unsupervised deep neu-
ral networks. In 2016 IEEE Conference on Computer Vision
and Pattern Recognition, CVPR 2016, Las Vegas, NV, USA,
June 27-30, 2016, pages 1183–1192, 2016.

[32] Venice Erin Liong, Jiwen Lu, Gang Wang, Pierre Moulin,
and Jie Zhou. Deep hashing for compact binary codes learn-
ing.
In IEEE Conference on Computer Vision and Pat-
tern Recognition, CVPR 2015, Boston, MA, USA, June 7-12,
2015, pages 2475–2483, 2015.

[33] Hong Liu, Rongrong Ji, Yongjian Wu, and Wei Liu. Toward-
s optimal binary code learning via ordinal embedding.
In
Proceedings of the Thirtieth AAAI Conference on Artiﬁcial
Intelligence, February 12-17, 2016, Phoenix, Arizona, USA.,
pages 1258–1265, 2016.

[34] Wei Liu, Jun Wang, Rongrong Ji, Yu-Gang Jiang, and Shih-
Fu Chang. Supervised hashing with kernels. In 2012 IEEE
Conference on Computer Vision and Pattern Recognition,
Providence, RI, USA, June 16-21, 2012, pages 2074–2081,
2012.

[35] Wei Liu, Jun Wang, Sanjiv Kumar, and Shih-Fu Chang.
Hashing with graphs.
In Proceedings of the 28th interna-
tional conference on machine learning (ICML-11), pages 1–
8. Citeseer, 2011.

[36] James MacQueen et al. Some methods for classiﬁcation
and analysis of multivariate observations. In Proceedings of
the ﬁfth Berkeley symposium on mathematical statistics and
probability, volume 1, pages 281–297. Oakland, CA, USA,
1967.

[37] Aude Oliva and Antonio Torralba. Modeling the shape of
the scene: A holistic representation of the spatial envelope.
International Journal of Computer Vision, 42(3):145–175,
2001.

[38] Sudhakar Prasad. Certain relations between mutual infor-
mation and ﬁdelity of statistical estimation. CoRR, ab-
s/1010.1508, 2010.

[39] Fumin Shen, Chunhua Shen, Wei Liu, and Heng Tao Shen.
Supervised discrete hashing. In IEEE Conference on Com-
puter Vision and Pattern Recognition, CVPR 2015, Boston,
MA, USA, June 7-12, 2015, pages 37–45, 2015.

2848

