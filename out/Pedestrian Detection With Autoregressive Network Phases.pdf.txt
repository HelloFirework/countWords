Pedestrian Detection with Autoregressive Network Phases

Garrick Brazil, Xiaoming Liu

Michigan State University, East Lansing, MI

{brazilga, liuxm}@msu.edu

Abstract

We present an autoregressive pedestrian detection
framework with cascaded phases designed to progressively
improve precision. The proposed framework utilizes a novel
lightweight stackable decoder-encoder module which uses
convolutional re-sampling layers to improve features while
maintaining efﬁcient memory and runtime cost. Unlike pre-
vious cascaded detection systems, our proposed framework
is designed within a region proposal network and thus re-
tains greater context of nearby detections compared to inde-
pendently processed RoI systems. We explicitly encourage
increasing levels of precision by assigning strict labeling
policies to each consecutive phase such that early phases
develop features primarily focused on achieving high recall
and later on accurate precision. In consequence, the ﬁnal
feature maps form more peaky radial gradients emulating
from the centroids of unique pedestrians. Using our pro-
posed autoregressive framework leads to new state-of-the-
art performance on the reasonable and occlusion settings
of the Caltech pedestrian dataset, and achieves competitive
state-of-the-art performance on the KITTI dataset.

1. Introduction

Detecting pedestrians in urban scenes remains to be
a challenge in computer vision despite recent rapid ad-
vances [1, 15, 21, 26, 32, 36, 40–42]. The use of ensem-
ble [7, 34, 37] and recurrent [26, 33] networks has been suc-
cessful in top-performing approaches of pedestrian / object
detection. Recurrent networks reﬁne upon their own fea-
tures while ensemble networks gather features through sep-
arate deep classiﬁers. Both techniques offer a way to obtain
stronger and more robust features, thus better detection.

However, the characteristics of ensemble and recurrent
networks are distinct. Ensemble networks assume that sep-
arate networks will learn diversiﬁed features which when
combined will become more robust. In contrast, recurrent
networks inherit previous features as input while further
sharing weights between successive networks. Hence, re-
current networks are more capable of reﬁning than diversi-

Figure 1.
Illustration of our proposed autoregressive framework
with sample phase (P1→3) classiﬁcation prediction maps and box
visualizations under Caltech [5] dataset. Our method iteratively
re-scores predictions under incrementally more precise label poli-
cies, using a series of de-encoder modules comprised of decoder
and encoder pathways. Notice a heavy reduction in false positives
(red) as phases progress, while true positives (green) are retained.

fying. Intuitively, we expect that both feature diversiﬁcation
and reﬁnement are important components to pair together.

Therefore, we explore how to approximate an ensemble
of networks using a stackable lightweight decoder-encoder
module and incorporating an autoregressive1 ﬂow to con-
nect them, as illustrated in Fig. 1. We formulate our frame-
work as a series of phases where each is a function of the
previous phase feature maps and classiﬁcation predictions.
Our decoder-encoder module is made of bottom-up and top-
down pathways similar to [16, 19, 20, 23]. However, rather
than using bilinear or nearest neighbor re-sampling fol-
lowed by conventional convolution, we propose memory-
efﬁcient convolutional re-sampling layers to generate fea-
tures and re-sample simultaneously in a single step.

1We adopt naming distinction of autoregressive (vs. recurrent) as a
network conditioned on previous predictions without the constraint of re-
peated shared weights, inspired by terminology in WaveNet [35] which
uses casual convolution instead of conventional recurrence.

17231

IM CNN Decoder Pathway Encoder Pathway Label Policy:  IoU > 0.4 Label Policy:  IoU > 0.5 Label Policy:  IoU > 0.6 In essence, our approach aims to take the best world of
both the ensemble and recurrent approaches. For instance,
since past predictions and features are re-used, our network
is able to reﬁne features when necessary. Secondly, since
our phases incorporate inner-lateral convolutions and do not
share weights, they are also capable to learn new and di-
versiﬁed features. Furthermore, we are able to design the
network with an efﬁcient overhead due to the added ﬂexi-
bility of using non-shared network weights for each phase
and by using memory-efﬁcient convolutional re-sampling
layers. As a consequence, we are able to choose optimal
channel settings with respect to efﬁciency and accuracy.

To take full advantage of the autoregressive nature of
our network, we further assign each phase a distinct label-
ing policy which iteratively becomes more strict as phases
progress.
In this way, we expect that the predictions of
each consecutive phase will become less noisy and produce
tighter and more clusterable prediction maps. Under the ob-
servation that our proposed autoregressive region proposal
network (RPN) obtains a high recall in the ﬁnal phase, we
also incorporate a simple hard suppression policy into train-
ing and testing of our second-stage R-CNN classiﬁer. Such
a policy dramatically narrows the subset of proposals pro-
cessed in the second-stage pipeline (∼65%), and greatly al-
leviates the runtime efﬁciency accordingly.

We evaluate our framework on the Caltech [5] pedestrian
detection dataset under challenging occlusion settings, us-
ing both the original and newly proposed [39] annotations,
and further on the KITTI [9] benchmark. We achieve state-
of-the-art performance under each test setting and report a
marginal overhead cost in runtime efﬁciency.
To summarize, our contributions are the following:

• We propose a multi-phase autoregressive pedestrian
detection system inside a RPN, where each phase is
trained using increasingly precise labeling policies.

• We propose a lightweight decoder-encoder module to
facilitate feature map reﬁnement and message passing
using convolutional re-sampling layers for memory-
efﬁcient feature pathways.

• We achieve state-of-the-art performance on Caltech [5]
under various challenging settings, and competitive
performance on KITTI [9] pedestrian benchmark.

2. Related Work

Ensemble Networks: Recent top-performing methods [7,
34, 37] on detection have employed ensemble-based tech-
niques where predictions from multiple deep convolutional
neural networks (CNNs) are fused. For instance, [7] pro-
pose a soft-weighting scheme using an ensemble of inde-
pendent detectors, which demonstrate high accuracy with
fused scores. However, one drawback is having multiple
CNNs in memory and processing each in parallel. Thus,

Figure 2. Predictions of our autoregressive network (a) are directly
conditioned on past feature maps as recurrent network (c) and do
not share weights between phases as ensemble network (b). Unlike
either, our network is further conditioned on past predictions.

both the scalability as networks become larger and usability
in memory-constrained systems are lessened. Further, [1]
form a small ensemble by fusing RPN scores with the scores
of a R-CNN detector and demonstrates improved perfor-
mance. Compared to these methods, our single RPN func-
tions as an ensemble of inter-connected small networks,
which can improve the precision without critically obstruct-
ing runtime or memory efﬁciency.

Cascaded Networks: A similar line to ensemble net-
works take form of cascaded detection systems [3, 24, 25],
which build on a series of R-CNN detectors and function
on cropped region-of-interests (RoIs) generated by a static
proposal network. In contrast, our work focuses as a fully
convolutional cascade inside a proposal network. There-
fore, our network is more equipped to utilize contextual
cues of surrounding detections to inform suppression of du-
plicate detections, whereas cropped RoIs are processed in-
dependently of other proposals. Liu et al. [21] propose su-
pervision using incremental labeling policies similar to our
approach. However, rather than making immediate predic-
tions based only on previous predictions, we develop new
features through our decoder-encoder pathway.

Recurrent Networks: Recurrent networks are a power-
ful technique in many challenging procedural [11, 22] and
temporal [4, 29, 31] computer vision problems. Recently, it
has been further demonstrated in urban object detection [26]
and person head detection [33]. For instance, [33] uses
recurrent LSTM to iteratively detect a single person at a
time until reaching an end condition, thus side-stepping
the need to perform non-maximum suppression (NMS) in
post. In contrast, [26] proposes a rolling recurrent convolu-
tion (RRC) model which reﬁnes feature maps and produces
new detections at each step. From this respect, our pro-
posed method is similar to RRC, but with two critical dif-
ferences. Firstly, the networks of our phases are not shared.
This enables us to learn specialized (ensemble-like) features
in each phase and gives more freedom in network design
of a phase, which may aid runtime efﬁciency when using
conservative designs. Secondly, we base each phase con-
ditioned on previous feature maps and predictions, which
form a more potent autoregressive foundation. We show a
high-level comparison of our autoregressive network, en-
semble networks, and recurrent networks in Fig. 2.

7232

(a)Autoregressive Flow (b)  Ensemble (c)  Recurrent Shared weights Figure 3. Overview of our proposed AR-RPN framework (left) and detailed illustration of our de-encoder module (right). The de-encoder
module consist of top-down and bottom-up pathways with inner-lateral convolution between pathways to produce diversiﬁed features, as
well as convolutional re-sampling layers (s denotes convolutional stride) ei and di for memory-efﬁcient feature generation. We further
condition predictions on the previous phase predictions through concatenation within fk(·).

Encoder-Decoder Networks: Many recent works [16,
19, 20, 28] have explored multi-strided feature maps re-use
within computer vision. Each variant of architectures utilize
a series of convolution, feature aggregation (concat, resid-
ual), and up-sampling / pooling layers in order to form an
encoder-decoder structure. Similar to the network structure
in [23] for human pose estimation, we incorporate stackable
top-down and bottom-up pathways. However, in contrast
to prior work, we design our de-encoder module without
explicitly using bilinear or nearest neighbor re-sampling.
Instead, we uniquely blend the feature generation and re-
sampling into a single convolution layer using a fractional
stride (↑) or strided convolution (↓), making the travel nodes
in our streams as compact as possible. We show in ablation
that a single convolutional re-sampling layer consumes low
memory and performs better compared to the conventional
two-step techniques previously used.

3. Autoregressive Detector

Our proposed framework is made up of two stages: an
autoregressive RPN hence referred to as AR-RPN, and a
second-stage R-CNN detector each founded on [27,38]. We
collectively refer to both stages as AR-Ped. As shown in
Fig. 3, AR-RPN consists of multiple phases, where each
predicts classiﬁcation scores and passes these predictions
and their features into the next phase. Each phase is con-
nected to the last through a bottom-up and top-down path-
ways, which form a lightweight decoder-encoder module.
This module is stackable onto the backbone RPN and onto
itself repeating. We supervise each phase to jointly learn
increasingly more precise predictions by imposing a stricter
labeling policy to consecutive phases, thereby producing

more peaky and clusterable classiﬁcations in the ﬁnal phase.
We apply the box transformations, NMS, and a hard sup-
pression policy to the ﬁnal predictions for which the remain-
ing subset are used to train a specialized R-CNN detector.

3.1. De Encoder Module

To perform autoregressive detection in a single model,
we design a stackable decoder-encoder module, termed de-
encoder, where its top-down pathway leverages past feature
maps and its bottom-up pathway encodes stronger seman-
tics. Following [19], we give each pathway the ability to
learn from feature maps at multiple depths of the backbone
network.
Importantly, our design encourages the highest
level features to remain at the lowest resolution where ob-
ject detection functions most efﬁciently. Intuitively, the de-
encoder enables the network to look back at previous fea-
tures and learn more advanced features during re-encoding.
Let us recall that typical network architectures, e.g.,
VGG-16 [30] and ResNet-50 [12], function from low to
high stride levels using a series of convolution and pool-
ing layers. We denote the set of strides of a backbone net-
work as S, where 2i−1 is the down-sampling factor of the
ith stride level preceding a pooling operation. In pedestrian
detection, it is common to have n = 5 unique stride levels
such that S = {1, 2, 4, 8, 16}. The hyperparameters of the
de-encoder module include a designated target stride t and
channel width ci speciﬁc to each stride, which respectively
control how far up in resolution the phase should de-encode
and how many channels at each stride should be learned.

The primary goal of the de-encoder module is to produce
ﬁner features at each level from the target stride t to the ﬁ-
nal stride n of the network. Denoting Ck = {Ck
t , . . . , Ck
n}

7233

Backbone VGG-16 IM De-encoder Module as the reﬁned features of the kth phase at each stride, gk(·)
as the set of convolutional and ReLU layers, Φk the respec-
tive weights, and tk the target stride of feature maps to de-
encode and reﬁne, the autoregressive nature of the feature
generation can be expressed as:

Ck = gk(Ck−1 | Φk, tk).

(1)

Hence, each phase of the network takes as input the previ-
ous phase feature maps and produces more advanced fea-
tures. Initial features C1 are given from top-most layers at
corresponding strides from the backbone (e.g., in VGG-16
C1

5 = conv5 3, and so forth).

4 = conv4 3, C1

Top-down pathway: We design our top-down decoder for
phase k by attaching a convolutional layer with BN [13] to
{Ck−1
t...n} feature maps, which produce inner-lateral convolu-
tions Li with corresponding channel widths ci. Rather than
using a two-step process comprised of a bilinear / nearest
neighbor up-sampling followed by convolution as done in
prior work, we denote di(·) as a convolutional up-sampling
layer which simultaneously performs 2× up-sampling and
feature reduction into channel width ci using fractionally
strided convolution. The combined operation is more efﬁ-
cient in both memory and runtime. Starting with the highest
feature stride n, we use di(·) to iteratively decode features,
which are then fused with the lateral features at the decoded
stride Li through element-wise addition, denoted:

Di = di(Di+1) + Li.

(2)

We begin with the base case of Dn = Ln, and repeat this
procedure until the target stride feature map Dt is reached.
In theory, the top-down pathway enables high-level seman-
tics to be passed down through the decoded term di(Di+1)
and low-level features to be re-examined using Li.

Bottom-up pathway: We design the bottom-up encoder
in the opposite manner as the decoder. We ﬁrst attach a
convolutional layer with BN to each {Dk−1
t+1...n} which each
produce new laternal features L′
i with ci channels. Similar
to the decoder pathway, we denote ei(·) as a single con-
volutional down-sampling layer which simultaneously per-
forms 2× down-sampling and feature expansion into chan-
nel width ci using strided convolution, rather than conven-
tional two-step process used in previous work. We use ei(·)
to iteratively encode the features at each stride, which are
then fused with the lateral features of the encoded stride L′
i
via element-wise addition, denoted as:

Ei = ei(Ei−1) + L′
i.

(3)

As the name suggests, the bottom-up encoder starts with the
lowest stride t and repeats until the nth stride is reached,
such that lateral features at t is Et = Dt. The bottom-up
pathway enables the network to encode low-level features
from the lowest stride through the ei(Ei−1) term and for
higher-level features to be re-examined using L′
i.

3.2. Autoregressive RPN

We utilize the standard RPN head and multi-task loss
proposed in [10] following the practices in [38]. We pre-
deﬁne a set of anchor shapes which act as hyperparameters
describing the target pedestrian scales. The RPN head is
comprised of a proposal feature extraction (PFE) layer con-
nected to two sibling layers which respectively predict an-
chor classiﬁcation (cls) and bounding box regression (bbox)
output maps, hence forming a multi-task learning problem.

Multi-phase Network: Our RPN is comprised of a total
of Nk = 3 phases. The ﬁrst phase is simply the backbone
network starting with the modiﬁed VGG-16 [30] that has
strides of S = {1, 2, 4, 8, 16}. The second phase is a de-
encoder module which has a target stride t = 3 and channel
widths of c3 = 128, c4 = 256, c5 = 512. The ﬁnal phase is
another stack of the de-encoder module following the same
channel settings but uses a memory conservative lower tar-
get stride of t = 4. The spatial resolution at ith stride can
be denoted as wi × hi = W
2i−1 , where W × H is the
input image resolution. Thus, the ﬁnal proposal network
architecture forms a stair-like shape as in Fig. 3.

2i−1 × H

Autoregressive Flow: To enable the autoregressive ﬂow
between phases, we place a PFE layer and classiﬁcation
layer at the end of each phase encoder. For all phases except
the ﬁrst, we concatenate the previous phase predictions into
the input features for the corresponding phase PFE layer. In
doing so, each phase is able to start with strong compact
features by directly utilizing its previous phase predictions.
Further, the PFE layer of the ﬁnal phase Nk produces the
bounding box regression output map, since these features
are the most precise and peaky within the network.

Formally, we denote functions fk(·) and pk(·) as the kth
phase PFE layers and classiﬁcation layers respectively. We
build f (·) as a convolutional layer with 3 × 3 kernel and
512 output channels followed by a ReLU layer, while p(·)
a convolutional layer with 1 × 1 kernel and outputs chan-
nels 2× the number of anchors (A). Thus, pk(·) forms an
autoregressive function of previous phase predictions with
an output dimension of w5 × h5 × 2A, via:

Pk = pk(fk(Pk−1 k Ck

n)),

(4)

where Pk−1 is the classiﬁcation feature map of the previous
phase, aka, past predictions, k is the concatenation operator,
and Ck
n is the last encoded feature map of the kth phase.
As deﬁned, the PFE fk(·) and classiﬁcation layer pk(·) are
conditioned autoregressively on past predictions which log-
ically act as compact but powerful semantic features.
In
this way, each phase is more free to learn new features Ck
n
to directly complement the past predictions. In essence, the
autoregressive ﬂow can be seen as running memory of the
most compact and strong features within the network.

7234

Classiﬁcation Task: Each classiﬁcation layer which pro-
ceeds a PFE layer is formulated as proposed in [27] fol-
lowing experimental settings of [1]. Formally, given a PFE
layer with dimensions w × h, the designated classiﬁcation
layer predicts a score for every spatial location of the im-
age (x, y) ∈ Rw×h against every predeﬁned anchor shape
a ∈ A, and every target class. Every spatial location of the
prediction map is therefore treated as a distinct box with its
own corresponding classiﬁcation score. To produce labels
for each box, a labeling policy is adopted using a hyperpa-
rameter h that controls the box criteria of Intersection over
Union (IoU) with ground truths in order to be considered
foreground. After every box is assigned a label according
to the labeling policy, each classiﬁcation layer is supervised
using multinomial cross-entropy logistic loss as in [10].

Localization Task: The localization task is formed using
the same set of anchor boxes described in the classiﬁcation
task. The localization task aims to perform bounding box
regression that predicts a bounding box transformation for
each foreground box towards the nearest pedestrian. A pro-
posal box is considered nearby a pedestrian ground truth if
there is at least h intersection over union between the two
boxes. The box transformation is deﬁned by 4 variables
consisting of translation (tx, ty) and scale factors (tw, th)
such that when applied will transform the source box into
the target ground truth. We train the bounding box regres-
sion values using Smooth L1 loss [10].

Incremental Supervision:
In order to better leverage the
autoregressive and de-encoder properties of AR-RPN, we
choose to assign different classiﬁcation labeling policies
onto each consecutive phase. We emphasize that the de-
encoder modules enable the network to adapt and become a
stronger classiﬁer, which can be exploited to produce more
accurate and tighter classiﬁcation clusters when supervised
with incrementally stricter labeling policies.

Let us brieﬂy discuss the trade-offs regarding different
labeling policies. Consider using a labeling policy of h = 1,
which is approximately equivalent to requiring the network
output a single box for each pedestrian and thus the im-
balance of classes may be difﬁcult.
In contrast, as a la-
beling policy becomes more lenient at h = 0.5, the clas-
siﬁcation becomes more balanced but produces many false
positives as duplicate detections. In theory, bounding box
regression will reduce the impact of double detections by
transforming boxes into clusters which can be suppressed
by NMS. Ideally, a network has either high-performing
bounding box regression and/or tight clusterable classiﬁ-
cation maps, since both enable NMS to cluster duplicate
detections. Therefore, rather than using a single discrete la-
beling policy of h = 0.5, we assign lenient-strict policies
h1 = 0.4, h2 = 0.5, h3 = 0.6, to each phase classiﬁca-
tion layer respectively. In contrast to [21], we enforce in-
cremental supervision between de-encoder modules rather

than being applied immediately in quick succession. In con-
sequence, our classiﬁcation score maps are supervised to
gradually become more peaky and clusterable.

Loss Formulation:
In addition to the classiﬁcation and
bounding box regression losses, we further add auxiliary
losses in the form of weak semantic segmentation as in [1].
Speciﬁcally, during training we add a binary semantic seg-
mentation layer to each stride of the ﬁrst top-down pathway
to act as an auxiliary loss and accelerate training. We for-
mally deﬁne the joint loss terms incorporating phase classi-
ﬁcation softmax loss Lcls, ﬁnal phase localization Smooth
L1 loss Lbbox, and each softmax auxiliary loss Lseg as:

L =

Nk

X

k=1

λkLcls + λbLbbox + λs

5

X

i=3

Lseg,

(5)

where k corresponds to phases 1 → Nk of the full net-
work, and i represents stride for each auxiliary segmenta-
tion layer of the backbone network. We use Caffe [14] with
SGD following the settings in [38] in our training. We set
λ1 = λ2 = 0.1, λ3 = 1, λb = 5, and λs = 1.

3.3. R CNN Detector

Most pedestrian detection frameworks are derivatives of
Faster R-CNN [27], and hence incorporate a second-stage
scale-invariant region classiﬁer termed as R-CNN. Follow-
ing [1], we utilize a modiﬁed VGG-16 as a R-CNN that
functions on cropped RGB regions proposed by AR-RPN,
utilizes a strict labeling policy, and fuses its scores with the
RPN. However, unlike past methods we impose a simple
hard suppression policy that suppresses all box proposals
with a score less than a hyperparameter z. This has two
advantages. Firstly, it greatly improves runtime since only
a subset of proposals need to be processed. Secondly, by
focusing on only the hard samples leftover from the RPN,
the R-CNN learns specialized classiﬁcation similar to the
motivation of the AR-RPN.

Loss Formulation: As in the AR-RPN, we also use soft-
max loss to train the R-CNN. We use a strict labeling policy
requiring h ≥ 0.7 IoU for foreground, a weak segmentation
auxiliary loss Lseg, and height sensitive weighting scheme
w as detailed in [1]. We set z = 0.005 to impose a score
suppression of the RPN proposals and eliminate conﬁdent
background proposals from being re-processed. In practice,
the suppression dramatically reduces the search space for
both efﬁciency and accuracy while critically keeping recall
unaffected. Thus, we denote the R-CNN loss as:

L = X

j

wjLcls(cj, ˆcj) + Lseg,

if cj ≥ z,

(6)

where j corresponds to each proposal of AR-RPN, c is the
classiﬁcation result of the R-CNN, and ˆc is the class label.
We use Caffe to train the R-CNN following settings of [1].

7235

Caltech Reasonable

M RO
9.95

−2 M RO
22.45

−4 M RN
8.08

−2 M RN
17.42

−4

Caltech Occlusion
PartialO HeavyO RT (ms)
19.24

59.94

MS-CNN [2]
RRC [26]
RPN+BF [38]
F-DNN [7]
TLL(MRF)+LSTM [32]
ALFNet [21]
SDS-RCNN [1]
RepulsionLoss [36]
FRCNN+ATT-vbb [41]
PDOE+RPN [42]
GDFL [18]
DSSD [8]+Grid [15]

AR-RPN (ours)
AR-Ped (ours)

−

9.58
8.65
7.40

−

7 .36

−

10.33
7.60
7.85
10.85
8.01
6.45

−

18.60
19.92

−
−

17 .82

−
−
−

19.86
18.20
21.62
15.54

−

7.28
6.89

−

6.10
6.44
5 .00

−
−
−
−

−

16.76
14 .75

−
−

−

24.23
15.41

−
−

−

74.36
55 .13

−
−

15.76

14.86

58.55

−
−
−
−
−

−
−

13 .30
16.74
24.28
16.30
11.93

−

45.18
44.40
43 .18
42.42

58.06
48.80

5.78
4.36

15.86
11.39

64
75
88
−
−
−
95
−
−
−
−
−
86
91

KITTI
Mod.

73 .70
75.33
61.29

−
−
−

63.05

−
−
−

Hard

68.31

−

56.08

−
−
−
−
−
−
−

Easy

83 .92

−

75.58

−
−
−
−
−
−
−

84.61

68.62

66.86

−
−

−
−

−
−

83.66

73.44

68 .12

Table 1. Comprehensive comparison of our frameworks and the state-of-the-art on the Caltech and KITTI benchmarks, in both accuracy
and runtime (RT). We show the Caltech miss rates at multiple challenging settings, with both the original (O) and new (N ) annotations,
and at occlusion settings with the original annotations and FPPI range M RO
−2. Further, we evaluate the KITTI pedestrian class under easy,
moderate, and hard settings, with mean Average Precision (mAP) [9]. Boldface/italic indicate the best/second best performance.

4. Experiments

We evaluate our proposed AR-Ped framework on two
challenging datasets: Caltech [5, 6] and KITTI [9]. We per-
form experiments ablating our approach from the perspec-
tive of design choices and hyperparameters. We further ex-
amine the qualitative changes and analyze the quantitative
peakiness in detections across phases.

4.1. Caltech

The Caltech [5,6] dataset is a widely used benchmark on
pedestrian detection that contains 10 hours of video taken
from an urban driving environment with ∼350,000 bound-
ing box annotations and 2,300 unique pedestrians. We use
the Caltech10× for training and the Caltech reasonable set-
ting [6] for testing, unless otherwise speciﬁed. The evalua-
tion uses a miss rate (MR) metric averaged over a false pos-
itive per image (FPPI) range of [10−2, 100] and also a more
challenging metric over the range [10−4, 100], respectfully
referred to as MR−2 and MR−4. Recently, new annotations
are released [39] to correct the ofﬁcial annotations in terms
of consistency and box alignment. For completeness, we
evaluate on both the original and the new annotations, de-
noted respectively as MRO and MRN .

We compare our work to the state-of-the-art pedestrian
detection methods of Caltech with respect to the core ex-
perimental conﬁgurations of using each combination of
original/FPPI setting, and partial/heavily occlusion within
the original annotation space as deﬁned in [5]. We limit
our comparison to the top-2 methods of any sub-category
trained using Caltech10× dataset since these comprise the
most highly competitive methods. We also emphasize that

we are among the few methods to comprehensively evaluate
and report each setting, and release our source code avail-
able at http://github.com/garrickbrazil/AR-Ped.

−2 and new annotation MRN

Our method advances the state-of-the-art on all but one
evaluation setting, as detailed in Table 1. Under the most
common benchmark reasonable setting, we achieve a miss
rate of 6.45% (↓ 0.91) and 4.36% (↓ 0.64) on the ofﬁcial
annotations MRO
−2 respectively.
Further, our approach has increased robustness to partial oc-
clusion (↓ 1.37% miss rate). Compared to methods which
do not explicitly address occlusion [1, 2, 7, 38], our method
also improves w.r.t heavy occlusion (↓ 6.33% miss rate).
Yet, our method underperforms on heavy occlusion com-
pared to work specially designed to target occlusion prob-
lem [15, 18, 36, 42], which is orthogonal to our work.

We further produce a runtime analysis for state-of-the-art
works with public code using the same controlled machine
with NVIDIA 1080 Ti GPU, as summarized in Table 1. Our
method retains a competitive runtime efﬁciency due to the
light overhead design of our de-encoder module while still
improving accuracy in all but one setting.

4.2. KITTI

KITTI is a popular urban object detection dataset which
offers annotations for cars, pedestrians and cyclists. We use
the ofﬁcial training set of 7,481 images and evaluate on the
standard 7,518 test images. We adopt the settings and core
training code of [2] in order to initialize good starting hy-
perparameters. However, due to GPU memory constraints
we set the input image scale to 576 height resolution and
achieve competitive performance on the pedestrian class, as
reported in Table 1. As described in [1], high performing

7236

−2 MAC (G) Runtime (ms)

Nk c size M RO
1 M 10.16
8.32
2 M
8.62
3
S
3 M
8.01
8.33
3
L
4 M
8.68

217.9
429.3
255.3
321.3
429.3
355.9

68
80
74
86
115
97

Table 2. The performance with different parameters and num-
bers of phases under the Caltech reasonable M RO
−2 setting. We
further detail the efﬁciency of each setting in terms of multiply-
accumulate (MAC) and runtime on an NVIDIA 1080 Ti.

pedestrian detectors [1,17,38] on Caltech and KITTI do not
usually have high correlation. We emphasize that our AR-
Ped is among the ﬁrst to report high performance for both
datasets, which suggests the generalization of our model to
pedestrian detection rather than a speciﬁc dataset.

4.3. Ablations

All ablation experiments use our AR-RPN and the Cal-
−2 FPPI setting, as

tech test set under the reasonable M RO
this is the most widely tested setting on Caltech.

What are optimal de-encoder settings?
In order to an-
alyze the de-encoder module, we ablate its parameters in
each phase concerning channel widths at each feature stride
and target strides to de-encode. Our primary method of AR-
RPN uses what we refer to as medium channel width set-
tings of cM = {128, 256, 512}. We further denote small
and large channel settings such that cS = {64, 128, 256}
and cL = {256, 512, 512}, then train our AR-RPN with
other settings kept consistent. Surprisingly, the small and
large channel widths function similarly but neither as well
as the medium, which roughly follows the rules-of-thumb
channel settings outlined in VGG-16 [30]. For instance, the
cL and cS achieve 8.33% (↑ 0.32%) and 8.62% (↑ 0.61%)
miss rate, as detailed in Table 2. This suggests a difﬁculty
when over or under expanding channels compared to the c
width of source feature maps in C1.

We further analyze the runtime complexity of the de-
encoder modules under each proposed setting in Table 2.
Overall, we observe that channel width settings have a large
effect on both multiply-accumulate (MAC) and runtime ef-
ﬁciencies of the AR-RPN. Speciﬁcally, channel width set-
tings of cS, cM , and cL respectively slow down by 8%,
26%, and 69% compared to Nk = 1 baseline.

What is the effect of convolutional re-sampling? Un-
like previous decoder-encoder works [16, 19, 20, 23, 28],
our module combines its re-sampling and feature genera-
tion into single convolutional re-sampling layers using ei-
ther stride of 2 or fractional 1
2 strides. To better understand
the importance of this combined operation, we split every
convolutional re-sampling layer e(·) and d(·) into 2 separate
layers: a bilinear re-sampling layer and a convolution fea-

Labeling Policy
no autoregressive
strict → lenient

moderate → moderate

strict → strict
lenient → strict

M RO
−2
9.06
9.03
8.94
8.43
8.01

Table 3. The effects of labeling policies on the Caltech dataset
under the reasonable M RO

−2 setting.

ture generation layer. We observe that this separation causes
performance to degrade from 8.01% → 9.45% miss rate.
This degradation suggests that providing the network with
more freedom in re-sampling, as opposed to ﬁxing the ker-
nels to bilinear (or nearest neighbor), is beneﬁcial for detec-
tion. Moreover, separating the operations into 2-steps is nat-
urally less efﬁcient concerning memory usage and runtime.
Speciﬁcally, using the proposed convolutional re-sampling
layers within AR-RPN consumes 41% less GPU memory
compared to using a 2-step bilinear / convolution process
and maintains a 16% faster runtime speed at inference.

How many autoregressive phases to stack? The use of
autoregressive phases is clearly a critical component of our
framework. Therefore, to understand its impact we ablate
our framework by varying the number of phases while keep-
ing all other settings constant. We report the performance
of each setting in Table 2. Unsurprisingly, as fewer phases
are used the performance is steeply reduced. For instance,
recall that our 3-stage method achieves 8.01% miss rate. By
removing a single phase, the miss rate increases by ↑ 0.32%
while only gaining 6 ms in runtime efﬁciency. When an-
other phase is removed, an extreme degradation of ↑ 2.15%
is observed. Hence, the effect of additional phases seems
to diminish with Nk such that the ﬁrst additional phase has
the highest impact, as suggested by Fig. 4. We further add
a 4th phase following the same trend in incremental label-
ing (h4 = 0.7) and observe that the performance begins to
worsen. We suspect using more dense anchor sampling may
help train the very high IoU threshold.

How to choose incremental labeling policies?
Label-
ing policies are an important component to our autoregres-
sive framework. We demonstrate the level of sensitivity
and importance when using a variety of incremental label-
ing policies. Since high value IoU labeling policies only
admit very well localized boxes as foreground, we refer to
the IoU labeling policy of h ≥ 0.4 as lenient, h ≥ 0.5
as moderate, h ≥ 0.6 as strict. We train the AR-RPN
using labeling techniques of strict-to-lenient, moderate-to-
moderate, strict-to-strict, and our primary setting of lenient-
to-strict, as shown in Table 3. The strict-to-lenient method
performs the worse among all settings, degrading by 1.02%
MR. The moderate-to-moderate performs similarly and de-
grades by 0.80% MR. As shown in Fig. 4, the primary la-
beling policy of lenient-to-strict enables the network to start

7237

Figure 4. We visualize the prediction maps ˜Pk of each phase by taking the maximum of foreground scores across all A anchors at each
k . We use scaled blue →yellow colors to visualize ˜Pk, where
spatial location, i.e., denoting Pk = {Pbg
yellowness indicates high detection conﬁdence. The detections of each phase become increasingly tighter and more adept to non-maximum
suppression due to the incremental supervision for each phase (Sec. 3.2). We further analyze the prediction disagreements between phases
∆1 → 3, shown in the right column, where green represents the agreement of the foreground and magenta the regions suppressed.

k }, we deﬁne ˜Pk = maxA Pf g

k , Pf g

Figure 5. We analyze the mean prediction score ( ˜Pk) of 20 uni-
formly sampled points along the center lines of X-direction (left)
and Y-direction (right) averaged over all ground-truth pedestrians
in Caltech test dataset, using bilinear interpolation when neces-
sary. We note that successive phase scores form more peaky in-
clines radiating from the center of the pedestrian.

with large clusters of pedestrian box detections and itera-
tively suppress, resulting in more tight and peaky predic-
tion maps.
In contrast, strict-to-strict does not ease this
transition as well resulting in a degradation of 0.42% MR.
We further validate the effect by analyzing the score dis-
tributions across all pedestrians in the X/Y directions for
the Caltech test dataset, as shown in Fig. 5. We observe a
consistent trend in both directions where each successive
phase results in a sharper peak with respect to its mean
score. Each other labeling policy encourages the opposite
or encourages the same predictions but more accurately. On
a related point, we furhter examine the disagreements be-
tween phases (∆P1→3 colored magenta, Fig. 4) which re-
afﬁrms phases logically agree on centroids of pedestrians.
This analysis further shows that most suppression appears
to be due to poorly localized boxes primarily in Y-direction
(e.g., offset from the legs or head of a pedestrian).

For completeness, we further evaluate the extreme case
where there is no incremental supervision or autoregressive
ﬂow within the network as included in Table 3. In this case,
the core 3-phase network architecture is kept intact, except
the prediction layers and concatenation have been removed
from phases 1 → 2 and 2 → 3, therefore there is no in-
cremental labeling policy to be decided. In doing so, the
detection performance degrades by a considerable 2.14%
miss rate, which further suggests that making intermediate
predictions with the AR-RPN is a critical component to the
classiﬁcation power of our proposed framework.

5. Conclusion

In this work, we present an autoregressive pedestrian
detection framework which utilizes a novel stackable de-
encoder module with convolutional re-sampling layers. The
proposed AR-Ped framework is able to autoregressively
produce and reﬁne both features and classiﬁcation predic-
tions. In consequence, the collective phases approximate an
ensemble of increasingly more precise classiﬁcation deci-
sions and results in an overall improved classiﬁer for pedes-
trian detection. We speciﬁcally supervise each phase using
increasingly stricter labeling policies such that each phase
of the network has similar recall as the last but with tighter
and more clusterable prediction maps. We provide compre-
hensive ablation experiments to better understand and sup-
port each proposed component of our framework. We attain
new state-of-the-art results on the Caltech dataset through-
out many challenging experimental settings and achieve a
highly competitive accuracy on the KITTI benchmark.

7238

RGB Detection 0 20 20 0 References

[1] G. Brazil, X. Yin, and X. Liu. Illuminating pedestrians via
simultaneous detection segmentation. In ICCV. IEEE, 2017.
1, 2, 5, 6, 7

[2] Z. Cai, Q. Fan, R. S. Feris, and N. Vasconcelos. A uniﬁed
multi-scale deep convolutional neural network for fast object
detection. In ECCV. Springer, 2016. 6

[3] Z. Cai and N. Vasconcelos. Cascade R-CNN: Delving into

high quality object detection. In CVPR. IEEE, 2018. 2

[4] J. Carreira and A. Zisserman. Quo vadis, action recognition?
a new model and the kinetics dataset. In CVPR. IEEE, 2017.
2

[5] P. Doll´ar, C. Wojek, B. Schiele, and P. Perona. Pedestrian

detection: A benchmark. In CVPR. IEEE, 2009. 1, 2, 6

[6] P. Doll´ar, C. Wojek, B. Schiele, and P. Perona. Pedestrian
detection: An evaluation of the state of the art. PAMI,
34(4):743–761, 2012. 6

[7] X. Du, M. El-Khamy, J. Lee, and L. Davis. Fused DNN:
A deep neural network fusion approach to fast and robust
pedestrian detection. In WACV. IEEE, 2017. 1, 2, 6

[8] C.-Y. Fu, W. Liu, A. Ranga, A. Tyagi, and A. C. Berg.
DSSD: Deconvolutional single shot detector. arXiv preprint
arXiv:1701.06659, 2017. 6

[9] A. Geiger, P. Lenz, and R. Urtasun. Are we ready for au-
In

tonomous driving? the KITTI vision benchmark suite.
CVPR. IEEE, 2012. 2, 6

[10] R. Girshick. Fast R-CNN. In ICCV. IEEE, 2015. 4, 5
[11] A. Graves and J. Schmidhuber. Ofﬂine handwriting recog-
nition with multidimensional recurrent neural networks. In
NIPS, pages 545–552, 2009. 2

[12] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning

for image recognition. In CVPR. IEEE, 2016. 3

[13] S. Ioffe and C. Szegedy. Batch normalization: Accelerating
deep network training by reducing internal covariate shift. In
ICML, 2015. 4

[14] Y. Jia, E. Shelhamer, J. Donahue, S. Karayev, J. Long, R. Gir-
shick, S. Guadarrama, and T. Darrell. Caffe: Convolu-
tional architecture for fast feature embedding. arXiv preprint
arXiv:1408.5093, 2014. 5

[15] J. N. S. L. B. Kim and G. Kim.

Improving occlusion and
hard negative handling for single-stage pedestrian detectors.
In CVPR. IEEE, 2018. 1, 6

[16] T. Kong, F. Sun, W. Huang, and H. Liu. Deep feature pyra-
mid reconﬁguration for object detection. In ECCV. Springer,
2018. 1, 3, 7

[17] J. Li, X. Liang, S. Shen, T. Xu, J. Feng, and S. Yan. Scale-
aware fast R-CNN for pedestrian detection. arXiv preprint
arXiv:1510.08160, 2015. 7

[18] C. Lin, J. Lu, G. Wang, and J. Zhou. Graininess-aware deep
feature learning for pedestrian detection. In ECCV. Springer,
2018. 6

[19] T.-Y. Lin, P. Doll´ar, R. Girshick, K. He, B. Hariharan, and
S. Belongie. Feature pyramid networks for object detection.
In CVPR. IEEE, 2017. 1, 3, 7

[21] W. Liu, S. Liao, W. Hu, X. Liang, and X. Chen. Learning
efﬁcient single-stage pedestrian detectors by asymptotic lo-
calization ﬁtting. In ECCV, 2018. 1, 2, 5, 6

[22] B. McCann, J. Bradbury, C. Xiong, and R. Socher. Learned
in translation: Contextualized word vectors. In NIPS, 2017.
2

[23] A. Newell, K. Yang, and J. Deng. Stacked hourglass net-
works for human pose estimation. In ECCV. Springer, 2016.
1, 3, 7

[24] W. Ouyang, K. Wang, X. Zhu, and X. Wang. Chained cas-

cade network for object detection. In ICCV. IEEE, 2017. 2

[25] H. Qin, J. Yan, X. Li, and X. Hu. Joint training of cascaded

CNN for face detection. In CVPR. IEEE, 2016. 2

[26] J. Ren, X. Chen, J. Liu, W. Sun, J. Pang, Q. Yan, Y.-W. Tai,
and L. Xu. Accurate single stage detector using recurrent
rolling convolution. In CVPR. IEEE, 2017. 1, 2, 6

[27] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: To-
wards real-time object detection with region proposal net-
works. In NIPS, 2015. 3, 5

[28] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolu-
tional networks for biomedical image segmentation. In MIC-
CAI. Springer, 2015. 3, 7

[29] B. Shi, X. Bai, and C. Yao. An end-to-end trainable neural
network for image-based sequence recognition and its appli-
cation to scene text recognition. PAMI, 39(11):2298–2304,
2017. 2

[30] K. Simonyan and A. Zisserman. Very deep convolutional
networks for large-scale image recognition. arXiv preprint
arXiv:1409.1556, 2014. 3, 4, 7

[31] S. Song, C. Lan, J. Xing, W. Zeng, and J. Liu. An end-to-end
spatio-temporal attention model for human action recogni-
tion from skeleton data. In AAAI, 2017. 2

[32] T. Song, L. Sun, D. Xie, H. Sun, and S. Pu. Small-scale
pedestrian detection based on somatic topology localization
and temporal feature aggregation. In ECCV. Springer, 2018.
1, 6

[33] R. Stewart, M. Andriluka, and A. Y. Ng. End-to-end people

detection in crowded scenes. In CVPR. IEEE, 2016. 1, 2

[34] C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and A. Rabinovich.
Going deeper with convolutions. In CVPR. IEEE, 2015. 1, 2
[35] A. Van Den Oord, S. Dieleman, H. Zen, K. Simonyan,
O. Vinyals, A. Graves, N. Kalchbrenner, A. W. Senior, and
K. Kavukcuoglu. WaveNet: A generative model for raw au-
dio. In SSW, 2016. 1

[36] X. Wang, T. Xiao, Y. Jiang, S. Shao, J. Sun, and C. Shen.
Repulsion loss: Detecting pedestrians in a crowd. In CVPR.
IEEE, 2018. 1, 6

[37] S. Zagoruyko, A. Lerer, T.-Y. Lin, P. O. Pinheiro, S. Gross,
S. Chintala, and P. Doll´ar. A multipath network for object
detection. In BMVC, 2016. 1, 2

[38] L. Zhang, L. Lin, X. Liang, and K. He.

doing well for pedestrian detection?
2016. 3, 4, 5, 6, 7

Is faster R-CNN
In ECCV. Springer,

[20] S. Liu, L. Qi, H. Qin, J. Shi, and J. Jia. Path aggregation
network for instance segmentation. In CVPR. IEEE, 2018.
1, 3, 7

[39] S. Zhang, R. Benenson, M. Omran,

J. Hosang, and
B. Schiele. How far are we from solving pedestrian detec-
tion? In CVPR. IEEE, 2016. 2, 6

7239

[40] S. Zhang, L. Wen, X. Bian, Z. Lei, and S. Z. Li. Occlusion-
aware R-CNN: Detecting pedestrians in a crowd. In ECCV.
Springer, 2018. 1

[41] S. Zhang, J. Yang, and B. Schiele. Occluded pedestrian de-
tection through guided attention in CNNs. In CVPR. IEEE,
2018. 1, 6

[42] C. Zhou and J. Yuan. Bi-box regression for pedestrian detec-
tion and occlusion estimation. In ECCV. Springer, 2018. 1,
6

7240

