Deep Tree Learning for Zero-shot Face Anti-Spooﬁng

Yaojie Liu, Joel Stehouwer, Amin Jourabloo, Xiaoming Liu

Department of Computer Science and Engineering
Michigan State University, East Lansing MI 48824

{liuyaoj1, stay.jb, jourablo, liuxm}@msu.edu

Abstract

Face anti-spooﬁng is designed to prevent face recog-
nition systems from recognizing fake faces as the genuine
users. While advanced face anti-spooﬁng methods are de-
veloped, new types of spoof attacks are also being created
and becoming a threat to all existing systems. We deﬁne
the detection of unknown spoof attacks as Zero-Shot Face
Anti-spooﬁng (ZSFA). Previous ZSFA works only study 1-
2 types of spoof attacks, such as print/replay, which limits
the insight of this problem. In this work, we investigate the
ZSFA problem in a wide range of 13 types of spoof attacks,
including print, replay, 3D mask, and so on. A novel Deep
Tree Network (DTN) is proposed to partition the spoof sam-
ples into semantic sub-groups in an unsupervised fashion.
When a data sample arrives, being know or unknown at-
tacks, DTN routes it to the most similar spoof cluster, and
makes the binary decision. In addition, to enable the study
of ZSFA, we introduce the ﬁrst face anti-spooﬁng database
that contains diverse types of spoof attacks. Experiments
show that our proposed method achieves the state of the art
on multiple testing protocols of ZSFA.

1. Introduction

Face is one of the most popular biometric modalities due
to its convenience of usage, e.g., access control, phone un-
lock. Despite the high recognition accuracy, face recogni-
tion systems are not able to distinguish between real human
faces and fake ones, e.g., photograph, screen. Thus, they are
vulnerable to face spoof attacks, which deceives the systems
to recognize as another person. To safely use face recog-
nition, face anti-spooﬁng techniques are required to detect
spoof attacks before performing recognition.

Attackers can utilize a wide variety of mediums to
launch spoof attacks. The most common ones are replay-
ing videos/images on digital screens, i.e., replay attack, and
printed photograph, i.e., print attack. Different methods
are proposed to handle replay and print attacks, based on
either handcrafted features [7, 35, 38] or CNN-based fea-

Mask 1

Print

Replay

…

Makeup

s
k
c
a
t
t
A
 
f
o
o
p
S
n
w
o
n
K

 

Partial Paper

Partial Paper

Transparent 

Mask

s
k
c
a
t
t
A
 
f
o
o
p
S
n
w
o
n
k
n
U

 

Live

Known Spoof

Unknown Spoof

…

Figure 1: To detect unknown spoof attacks, we propose a Deep
Tree Network (DTN) to unsupervisely learn a hierarchic embed-
ding for known spoof attacks. Samples of unknown attacks will be
routed through DTN and classiﬁed at the destined leaf node.

tures [4, 18, 20, 32]. Recently, high-quality 3D custom mask
is also used for attacking, i.e., 3D mask attack. In [29–31],
methods for detecting print/replay attacks are found to be
less effective for this new spoof, and hence the authors
leverage the remote photoplethysmography (r-PPG) to de-
tect the heart rate pulse as the spooﬁng cue. Further, fa-
cial makeup may also inﬂuence the outcome of recognition,
i.e., makeup attack [12]. Many works [11–13] study facial
makeup, despite not as an anti-spooﬁng problem.

All aforementioned methods present algorithmic solu-
tions to the known spoof attack(s), where models are trained
and tested on the same type(s) of spoof attacks. However,
in real-world applications, attackers can also initiate spoof
attacks that we, the algorithm designers, are not aware of,
termed unknown spoof attacks1. Researchers increasingly
pay attention to the generalization of anti-spooﬁng models,
i.e., how well they are able to detect spoof attacks that have
never been seen during the training? We deﬁne the prob-

1There is subtle distinction between 1) unseen attacks, attack types that
are known to algorithm designers so that algorithms could be tailored to
them, but their data are unseen during training; 2) unknown attacks, attack
types that are neither known to designers nor seen during training. We do
not differentiate these two cases and term both unknown attacks.

14680

lem of detecting unknown face spoof attacks as Zero-Shot
Face Anti-spooﬁng (ZSFA). Despite the success of face
anti-spooﬁng on known attacks, ZSFA, on the other hand,
is a new and unsolved challenge to the community.

The ﬁrst attempts on ZSFA are [3, 45]. They address
ZSFA between print and replay attacks, and regard it as
an outlier detection problem for live faces (a.k.a. real hu-
man faces). With handcrafted features, the live faces are
modeled via standard generative models, e.g., GMM, auto-
encoder. During testing, an unknown attack is detected if
it lies outside the estimated live distribution. These ZSFA
works have three drawbacks:
Lacking spoof type variety: Prior models are developed
w.r.t. print and replay attacks only. The respective feature
design may not be applicable to different unknown attacks.
No spoof knowledge: Prior models only use live faces,
without leveraging the available known spoof data. While
the unknown attacks are different, the known spoof attacks
may still provide valuable information to learn the model.
Limitation of feature selection: They use handcrafted
features such as LBP to represent live faces, which were
shown to be less effective for known spoof detection [27,
32, 37, 48]. Recent deep learning models [20, 32] show the
advantage of CNN models for face anti-spooﬁng.

This work aims to address all three drawbacks. Since one
ZSFA model may perform differently when the unknown
spoof attack is different, it should be evaluated on a wide
range of unknown attacks types. In this work, we substan-
tially expand the study of ZSFA from 2 types of spoof at-
tacks to 13 types. Besides print and replay attacks, we in-
clude 5 types of 3D mask attacks, 3 types of makeup at-
tacks, and 3 partial attacks. These attacks cover both imper-
sonation spooﬁng, i.e., attempt to be authenticated as some-
one else, and obfuscation spooﬁng, i.e., attempt to cover at-
tacker’s own identity. We collect the ﬁrst face anti-spooﬁng
database that includes these diverse spoof attacks, termed
Spoof in the Wild database with Multiple Attack Types
(SiW-M).

To tackle the broader ZSFA, we propose a Deep Tree
Network (DTN). Assuming there are both homogeneous
features among different spoof types and distinct features
within each spoof type, a tree-like model is well-suited to
handle this case: learning the homogeneous features in the
early tree nodes and distinct features in later tree nodes.
Without any auxiliary labels of spoof types, DTN learns to
partition data in an unsupervised manner. At each tree node,
the partition is performed along the direction of the largest
data variation. In the end, it clusters the data into several
sub-groups at the leaf level, and learns to detect spoof at-
tacks for each sub-group independently, shown in Fig. 1.
During the testing, a data sample is routed to the most sim-
ilar leaf node to produce a binary decision of live vs. spoof.

In summary, our contributions in this work include :

• Conduct an extensive study of zero-shot face anti-

spooﬁng on 13 different types of spoof attacks;

• Propose a Deep Tree Network (DTN) to learn features

hierarchically and detect unknown spoof attacks;

• Collect a new database for ZSFA and achieve the state-

of-the-art performance on multiple testing protocols.

2. Prior Work

Face Anti-spooﬁng Image-based face anti-spooﬁng refers
to face anti-spooﬁng techniques that only take RGB im-
ages as input without extra information such as depth or
heat.
In early years, researchers utilize liveness cues,
such as eye blinking and head motion, to detect print at-
tacks [24, 36, 37, 39]. However, when encountering un-
known attacks, such as photograh with eye portion cut,
and video replay, those methods suffer from a total failure.
Later, research move to a more general texture analysis and
address print and replay attacks. Researchers mainly utilize
handcrafted features, e.g., LBP [7, 16, 17, 35], HoG [25, 47],
SIFT [38] and SURF [8], with traditional classiﬁers, e.g.,
SVM and LDA, to make a binary decision. Those methods
perform well on the testing data from the same database.
However, while changing the testing conditions such as
lighting and background, they often have a large perfor-
mance drop, which can be viewed as an overﬁtting issue.
Moreover, they also show limitations in handling 3D mask
attacks, mentioned in [30].

To overcome the overﬁtting issue, researchers make var-
ious attempts. Boulkenafet et al. extract the spooﬁng fea-
tures in HSV+YCbCR space [7]. Works in [2, 5, 6, 18, 46]
consider features in the temporal domain. Recent works [2,
4] augment the data by using image patches, and fuse the
scores from patches to a single decision. For 3D mask at-
tacks, the heart pulse rate is estimated to differentiate 3D
mask from real faces [28, 30]. In the deep learning era, re-
searchers propose several CNN works [4, 18, 20, 27, 32, 37,
48] that outperform the traditional methods.
Zero-shot learning and unknown spoof attacks Zero-
shot object recognition, or more generally, zero-shot learn-
ing, aims to recognize objects from unknown classes [40],
i.e., object classes unseen in training. The overall idea is
to associate the known and unknown classes via a semantic
embedding, whose embedding spaces can be attributes [26],
word vector [19], text description [49] and human gaze [22].
Zero-shot learning for unknown spoof attack, i.e., ZSFA,
is a relatively new topic with unique properties. Firstly,
unlike zero-shot object recognition, ZSFA emphasizes the
detection of spoof attacks, instead of recognizing speciﬁc
spoof types. Secondly, unlike generic objects with rich se-
mantic embedding, there is no explicit well-deﬁned seman-
tic embedding for spoof patterns [20]. As elaborated in
Sec. 1, prior ZSFA works [3,45] only model the live data via
handcrafted features and standard generative models, with

4681

Table 1: Comparing our SiW-M with existing face anti-spooﬁng datasets.

Dataset

CASIA-FASD [50]
Replay-Attack [15]
HKBU-MARs [30]
Oulu-NPU [9]
SiW [32]
SiW-M

Year

2012
2012
2016
2017
2018
2019

Num. of
subj./vid.
50/600
50/1, 200
35/1, 008
55/5, 940
165/4, 620
493/1, 630

pose

Frontal
Frontal
Frontal
Frontal

[−90◦, 90◦]
[−90◦, 90◦]

Face variations
expression

lighting

replay

print

3D mask makeup

partial

Spoof attack types

Total num. of
spoof types

No
No
No
No
Yes
Yes

No
Yes
Yes
No
Yes
Yes

1
1
0
1
1
1

2
1
0
1
1
1

0
0
2
0
0
5

0
0
0
0
0
3

0
0
0
0
0
3

3
2
2
2
2
13

In this work, we propose a deep tree
several drawbacks.
network to unsupervisely learn the semantic embedding for
known spoof attacks. The partition of the data naturally
associates certain semantic attributes with the sub-groups.
During the testing, the unknown attacks are projected to the
embedding to ﬁnd the closest attributes for spoof detection.
Deep tree networks Tree structure is often found help-
ful in tackling language-related tasks such as parsing and
translation [14], due to the intrinsic relation of words and
sentences. E.g., tree models are applied to joint vision and
language problems such as visual question reasoning [10].
Tree structure also has the property for learning features
hierarchically. Face alignment works [23, 41] utilize the
regression trees to estimate facial landmarks from coarse
to ﬁne. Xiong et al. propose a tree CNN to handle the
large-pose face recognition [44]. In [21], Kaneko et al. pro-
pose a GAN with decision trees to learn hierarchically in-
terpretable representations. In our work, we utilize tree net-
works to learn the latent semantic embedding for ZSFA.
Face anti-spooﬁng databases Given the signiﬁcance
of a good-quality database,
researchers have released
several face anti-spooﬁng databases, such as CASIA-
FASD [50], Replay-Attack [15], OULU-NPU [9], and
SiW [32] for print/replay attacks, and HKBU-MARs [30]
for 3D mask attacks. Early databases such as CASIA-
FASD and Replay-Attack [50] have limited subject variety,
pose/expression/lighting variations, and video resolutions.
Recent databases [9, 30, 32] improve those aspects, and also
set up diverse evaluation protocols. However, up to now, all
databases focus on either print/replay attacks, or 3D mask
attacks. To provide a comprehensive study of face anti-
spooﬁng, especially the challenging ZSFA, we for the ﬁrst
time collect the database with diverse types of spoof attacks,
as in Tab. 1. The details of our database are in Sec. 4.

3. Deep Tree Network for ZSFA

The main purposes of DTN are twofold: 1) discover the
semantic sub-groups for known spoofs; 2) learn the features
in a hierarchical way. The architecture of DTN is shown in
Fig. 2. Each tree node consists of a Convolutional Residual
Unit (CRU) and a Tree Routing Unit (TRU), while the leaf
node consists of a CRU and a Supervised Feature Learning
(SFL) module. CRU is a block with convolutional layers
and the short-cut connection. TRU deﬁnes a node routing
function to route a data sample to one of the child nodes.

The routing function partitions all visiting data along the
direction with the largest data variation. SFL module con-
catenates the classiﬁcation supervision and the pixel-wise
supervision to learn the spooﬁng features.

3.1. Unsupervised Tree Learning
3.1.1 Node Routing Function

For a TRU node, let’s assume the input x = f (I | θ) ∈ Rm
is the vectorized feature response, I is data input, θ is the pa-
rameters of the previous CRUs, and S is the set of data sam-
ples Ik, k = 1, 2, ..., K that visit this TRU node. In [44],
Xiong et al. deﬁne a routing function as:

ϕ(x) = xT · v + τ,

(1)

where v denotes the projection vector and τ is the bias. Data
S can then be split into Slef t : {Ik|ϕ(xk) < 0, Ik ∈ S} and
Sright : {Ik|ϕ(xk) ≥ 0, Ik ∈ S}, and directed to the left
and right child node, respectively. To learn this function,
they propose to maximize the distance between the mean of
Slef t and Sright, while keeping the mean of S centered at
0. This unsupervised loss is formulated as:

L =

( 1
Nl PIk ∈Slef t

ϕ(xk))2

( 1
N PIk ∈S
ϕ(xk) − 1

Nr PIk ∈Sright

ϕ(xk))2 ,

(2)

where N , Nl, Nr denote the number of samples in each set.
However, in practice, minizing Equ. 2 might not lead to
a satisfactory solution. Firstly, the loss can be minimized by
increasing the norm of either v or x, which is a trivial solu-
tion. Secondly, even when the norms of v, x are constrained,
Equ. 2 is affected by the density of data S and can be sensi-
tive to the outliers. In other words, the zero expectation of
ϕ(x) does not necessarily result in a balanced partition of
data S. Local minima could be achieved when all data are
split to one side. In some cases, the tree may suffer from
collapsing to a few (even one) leaf nodes.

To better partition the data, we propose a novel routing
function and an unsupervised loss. Regardless of τ , the dot
product between xT and v can be regarded as projecting x to
the direction of v. We design v such that we can observe the
largest variation after projection. Inspired by the concept
of PCA, the optimal solution naturally becomes the largest
PCA basis of data S. To achieve this, we ﬁrst constrain v to

4682

256×256×6
(RGB+HSV)

CRU

TRU

%

(

CRU

TRU

CRU

TRU

'

Feature Space

(b)

CRU

TRU

CRU

TRU

CRU

TRU

CRU

TRU

CRU

CRU

CRU

CRU

CRU

CRU

CRU

CRU

SFL

SFL

SFL

SFL

SFL

SFL

SFL

SFL

Tree
Nodes

Leaf
Nodes

)

&

SFL

ℱ

Leaf Node
32×32×40

(a)

(d)

CRU

v
n
o
c

40

(c)

v
n
o
c

40

v
n
o
c

40

l

o
o
p
x
a
m

/2

1

v
n
o
c

Mask Map
32×32×1

M

e
z
i
r
o
t
c
e
v

v
n
o
c

v
n
o
c

40

40

c
f

c
f

0/1

500

2

Figure 2: The proposed Deep Tree Network (DTN) architecture. (a) the overall structure of DTN. A tree node consists of a Convolutional
Residual Unit (CRU) and a Tree Routing Unit (TRU), and a leaf node consists of a CRU and a Supervised Feature Learning (SFL) module.
(b) the concept of Tree Routing Unit (TRU): ﬁnding the base with largest variations; (c) the structure of each Convolutional Residual Unit
(CRU); (d) the structure of the Supervised Feature Learning (SFL) in the leaf nodes.

be norm 1 and reformulate Equ. 1 as:

ϕ(x) = (x − µ)T · v,

kvk = 1,

(3)

T
S

where µ is the mean of data S. Then, ﬁnding v is identical
to ﬁnding the largest eigenvector of the covariance matrix
¯X
¯XS , where ¯XS = XS − µ, and XS ∈ RN ×K is the data
matrix. Based on the deﬁnition of eigen-analysis ¯X
¯XS v =
λv, our optimization aims to maximize:

T
S

arg max

λ = arg max

v,θ

v,θ

vT ¯X

T
S

¯XS v.

(4)

The loss for learning the routing function is formulated as:

Lroute = exp(−αvT ¯X

T
S

¯XS v) + βTr(¯X

T
S

¯XS ),

(5)

where α, β are scalars, and set as 1e-3, 1e-2 in our experi-
ments. We apply the exponential function on the ﬁrst term
to make the maximization problem bounded. The second
term is introduced as a regularizer to prevent trivial solu-
tions by constraining the trace of covariance matrix of ¯XS .

Such imbalance would cause bias for supervised learning in
the next stage.

Hence, when we compute Equ. 5 to learn the routing
functions, we only consider the spoof samples to construct
XS . To have a balanced sub-group for each leaf, we sup-
press the responses of live data to zero, so that all live data
can be evenly partitioned to the child nodes. Meanwhile,
we also suppress the responses of the spoof data that do not
visit this node, so that every node models the distribution of
a unique spoof subset.

Formally, for each node, we maximize the routing func-
tion responses of spoof data that visit this node (denoted as
S), while minimizing the responses of other data (denoted
as S −), including all live data and spoof data that don’t visit
this node, i.e., that visit neighboring nodes. To achieve this
objective, we deﬁne the following loss:

Luniq = −

1
N X

Ik ∈S

k

(cid:13)(cid:13)¯xT

v(cid:13)(cid:13)

2

+

1
N − X

Ik ∈S−

2

.

k

(cid:13)(cid:13)¯xT

v(cid:13)(cid:13)

(6)

3.1.2 Tree of Known Spoofs

3.2. Supervised Feature Learning

With the routing function, we can build the entire binary
tree. Fig. 2 shows a binary tree of depth of 4, with 8 leaf
nodes. As mentioned early in Sec. 3, the tree is designed
to ﬁnd the semantic sub-groups from all known spoofs,
and is termed as spoof tree. Similarly, we may also train
live tree with live faces only, as well as general data tree
with both live and spoof data. Compared to spoof tree,
live and general data tree have some drawbacks. Live tree
does not convey semantic meaning for the spoof, and the
attributes learned at each node cannot help to route and bet-
ter detect spoof; General data tree may result in imbalanced
sub-groups, where samples of one class outnumber another.

Given the routing functions, a data sample Ik will be as-
signed to one of the leaf nodes. Let’s ﬁrst deﬁne the feature
output of leaf node as F(Ik | θ), shortened as Fk for sim-
plicity. At each leaf node, we deﬁne two node-wise super-
vised tasks to learn discriminative features: 1) binary clas-
siﬁcation drives the learning of a high-level understanding
of live vs. spoof faces, 2) pixel-wise mask regression draws
CNN’s attention to low-level local feature learning.
Classiﬁcation supervision To learn a binary classiﬁer, as
shown in Fig. 2(d), we apply two additional convolution
layers and two fully connected layers on Fk to generate a
feature vector ck ∈ R500. We supervise the learning via the

4683

&

(), +, ,, -)

1×1 conv

(), 16,16,20)

(), +, ,, 20)

resize

(), 16×16×20)

reshape

batch norm
w/o scale

(), 16×16×20)

TRU

(

#

$(&)

(), 1)

Figure 3: The structure of the Tree Routing Unit (TRU).

softmax cross entropy loss:

Lclass =

1
N X

Ik ∈S

n(1 − yk)log(1 − pk) − yklogpko (7)

pk =

exp(w0

T ck)

exp(w1
T ck) + exp(w1

,

T ck)

(8)

where S represents all the data samples that arrive this leaf
node, N denotes the number of samples in S, {w0, w1} are
the parameters in the last fully connected layer, and yk is
the label of data sample k (1 denotes spoof, and 0 live).
Pixel-wise supervision We also concatenate another con-
volution layer to Fk to generate a map response Mk ∈
R32×32. Inspired by the prior work [32], we leverage the
semantic prior knowledge of face shapes and spoof attack
position to provide a pixel-wise supervision. Using the
dense face alignment model [33], we provide a binary mask
Dk ∈ R32×32, shown in Fig. 4, to indicate the pixels of
spoof mediums. Thus, for a leaf node, the loss function for
the pixel-wise supervision is:

Lmask =

1
N X

Ik ∈S

kMk − Dkk1 .

(9)

Overall loss Finally, we apply the supervised losses on p
leaf nodes, the unsupervised losses on q TRU nodes, and
formulate our training loss as:

L =

p

X

i=1

(α1Li

class+α2Li

mask)+

q

X

j=1

(α3Lj

route+α4Lj

uniq),

(10)
where α1,α2,α3,α4 are the regularization coefﬁcients for
each term, and are set as 0.001, 1.0, 2.0, 0.001 respectively.
For a 4-layer DTN, p = 8 and q = 7.

3.3. Network Architecture

Deep Tree Network (DTN) DTN is the main framework
It takes I ∈ R256×256×6 as in-
of the proposed model.
put, where the 6 channels are RGB+HSV color spaces. We

concatenate three 3 × 3 convolution layers with 40 chan-
nels and 1 max-pooling layer, and group them as one Con-
volutional Residual Unit (CRU). Each convolution layer is
equipped with ReLU and group normalization layer [43],
due to the dynamic batch size in the network. We also ap-
ply a shortcut connection for each convolution layer. For
each tree node, we deploy one CRU before the TRU. At the
leaf node, DTN produces the feature representation of input
I as F(I | θ) ∈ R32×32×40, then uses one 1 × 1 convolution
layer to generate the binary mask map M.
Tree Routing Unit (TRU) TRU is the module routing the
data sample to one of the child CRUs. As shown in Fig. 3,
it ﬁrst compresses the feature by using an 1 × 1 convolu-
tion layer, and resizing the response spatially. For the root
node, we compress the CRU feature to x ∈ R32×32×10,
and for later tree node, we compress the CRU feature to
x ∈ R16×16×20. Compressing the input feature to a smaller
size helps to reduce the burden of computating and saving
the covariance matrix in Equ. 5. E.g., the vectorized fea-
ture for the ﬁrst CRU is x ∈ R655,360, and the covariance
matrix of x can take ∼ 400GB in memory. However, after
compression the vectorized feature is x ∈ R10,240, and the
covariance matrix of x only needs ∼ 0.1GB of memory.

After that, we vectorize the output and apply the routing
function ϕ(x). To compute µ in Equ. 3, instead of opti-
mizing it as a variable of the network, we simply apply a
batch normalization layer without scaling to save the mov-
ing average of each mini-batch. In the end, we project the
compressed CRU response to the largest basis v and obtain
the projection coefﬁcient. Then we assign the samples with
negative coefﬁcient to the left child CRU and the samples
with positive coefﬁcient to the right child CRU.
Implementation details With the overall loss in Equ. 10,
our proposed network is trained in an end-to-end fashion.
All losses are computed based on each mini-batch. DTN
modules and TRU modules are optimized alternately. While
optimizing DTN, we keep the parameters of TRUs ﬁxed and
vice versa.

4. Spoof in the Wild Database with Multiple

Attack Types

To benchmark face anti-spooﬁng methods speciﬁcally
for unknown attacks, we collect the Spoof in the Wild
database with Multiple Attack Types (SiW-M). Compared
with the previous databases in Tab. 1, SiW-M shows a great
diversity in spoof attacks, subject identities, environments
and other factors.

For spoof data collection, we consider two spooﬁng sce-
narios: impersonation, which entails the use of spoof to be
recognized as someone else, and obfuscation, which entails
the use to remove the attacker’s own identity. In total, we
collect 968 videos of 13 types of spoof attacks listed hierat-
ically in Fig 4. For all 5 mask attacks, 3 partial attacks, ob-

4684

s

Live

(493 / 660)

Replay
(21 / 99)

Print

(60 / 118)

Half Mask
(12 / 72)

Silicone
(12 / 27)

Transparent

Papercraft

Mannequin

Obfuscation

(88 / 88)

(6 / 17)

(12 / 40)

(23 / 23)

Imperson.
(61 / 61)

Cosmetic
(37 / 50)

Funny Eye
(160 / 160)

Paperglasses
(122 / 127)

Partial Paper

(86 / 86)

3D Mask Attacks

Makeup Attacks

Partial Attacks

Figure 4: The examples of the live faces and 13 types of spoof attacks. The second row shows the ground truth masks for the pixel-wise
supervision Dk. For (m, n) in the third row, m/n denotes the number of subjects/videos for each type of data.

fuscation makeup and cosmetic makeup, we record 1080P
HD videos. For impersonation makeup, we collect 720P
videos from Youtube due to the lack of special makeup
artists. For print and replay attacks, we intend to collect
videos from harder cases where the existing system fails.
Hence, we deploy an off-the-shelf face anti-spooﬁng algo-
rithm [32] and record spoof videos when the algorithm pre-
dicts live.

For live data, we include 660 videos from 493 subjects.
In comparison, the number of subjects in SiW-M is 9 times
larger than Oulu-NPU [9] and CASIA-FASD [50], and 3
times larger than SiW [32].
In addition, subjects are di-
verse in ethnicity and age. The live videos are collected in
3 sessions: 1) a room environment where the subjects are
recorded with few variations such as pose, lighting and ex-
pression (PIE). 2) a different and much larger room where
the subjects are also recorded with PIE variations. 3) a
mobile phone mode, where the subjects are moving while
the phone camera is recording. Extreme pose angles and
lighting conditions are introduced. Similar to print and re-
play videos, we deploy the face anti-spooﬁng algorithm [32]
to ﬁnd out the videos where the algorithm predicts spoof.
Hence, this third session is a harder scenario.

In total, we collect 1, 630 videos and each lasts 5-7 sec-
onds. The 1080P videos are recorded by Logitech C920 we-
bcam and Canon EOS T6. To use SiW-M for the study of
ZSFA, we deﬁne the leave-one-out testing protocols. Each
time we train a model with 12 types of spoof attacks plus
the 80% of the live videos, and test on the left 1 attack type
plus the 20% of live videos. There is no overlapping sub-
jects between the training and testing sets of live videos.

5. Experimental Results
5.1. Experimental Setup

Databases We evaluate our proposed method on multiple
databases. We deploy the leave-one-out testing protocols
on SiW-M and report the results of 13 experiments. Also,
we test on previous face anti-spooﬁng databases, including
CASIA [50], Replay-Attack [15], and MSU-MFSD [42]),
compare with the state of the art.

Evaluation metrics We evaluate with the following
metrics: Attack Presentation Classiﬁcation Error Rate

(APCER) [1], Bona Fide Presentation Classiﬁcation Error
Rate (BPCER) [1], the average of APCER and BPCER,
Average Classiﬁcation Error Rate (ACER) [1], Equal Er-
ror Rate (EER), and Area Under Curve (AUC). Note that,
in the evaluation of unknown attacks, we assume there is no
validation set to tune the model and thresholds while calcu-
lating the metrics. Hence, we determine the threshold based
on the training set and ﬁx it for all testing protocols. A sin-
gle test sample is one video frame, instead of one video.

Parameter setting The proposed method is implemented
in Tensorﬂow, and trained with a constant learning rate of
0.001 with a batch size of 32. It takes 15 epochs to con-
verge. We randomly initialize all the weights using a normal
distribution of 0 mean and 0.02 standard deviation.

5.2. Experimental Comparison
5.2.1 Ablation Study

All ablation studies use the Funny Eye protocol.
Different fusion methods In the proposed model, both the
norm of the mask maps and binary spoof scores could be
utilized for the ﬁnal classiﬁcation. To ﬁnd the best fusion
method, we compute ACER from using map norm, softmax
score, the maximum of map norm and softmax score, and
the average of two values, and obtain 31.7%, 20.5%, 21.0%,
and 19.3% respectively. Since the average score of the mask
norm and binary spoof score performs the best, we use it
for the remaining experiments. Moreover, we set 0.2 as the
ﬁnal threshold to compute APCER, BPCER and ACER for
all the experiments.
Different routing methods Routing is a crucial step to ﬁnd
the best subgroup to detect spoofness of a testing sample.
To show the effect of proper routing, we evaluate 2 alter-
native routing strategies: random routing and pick-one-leaf.
Random routing denotes randomly selecting one leaf node
for a testing sample to produce prediction; Pick-one-leaf de-
notes constantly selecting one particular leaf node to pro-
duce results, for which we report the mean score and stan-
dard deviation of 8 selections. Shown in Tab. 3, both strate-
gies perform worse than the proposed routing function. In
addition, the large standard deviation of pick-one-leaf strat-
egy shows the large performance difference of 8 subgroups
on the same type of unknown attacks, and demonstrates the
necessity of a proper routing.

4685

Table 2: AUC (%) of the model testing on CASIA, Replay, and MSU-MFSD.

Methods

CASIA [50]

Replay-Attack [15]

MSU [42]

Video Cut Photo Warped Photo Video Digital Photo

Printed Photo

Printed Photo HR Video Mobile Video

OC-SVMRBF +BSIF [3]
SVMRBF +LBP [9]
NN+LBP [45]

Ours

70.7
91.5
94.2
90.0

60.7
91.7
88.4
97.3

95.9
84.5
79.9
97.5

84.3
99.1
99.8
99.9

88.1
98.2
95.2
99.9

Overall

78.7 ± 11.7
88.6 ± 16.3
86.7 ± 15.6
95.9 ± 6.2

Table 3: Compare models with different routing strategies.
EER

Strategies

APCER

BPCER

ACER

Random routing

Pick-one-leaf

Proposed routing function

37.1

16.1

26.6

24.7

51.2 ± 20.0

17.0

18.1 ± 4.9

21.5

34.7 ± 8.8

19.3

24.1 ± 3.1

19.8

Table 4: Compare models with different tree losses and
strategies. The ﬁrst two terms of row 2-5 refer to using live
or spoof data in tree learning. The last row is our method.

Methods

APCER BPCER ACER

EER

MPT [44]

Live data √, Spoof data √, Unique Loss ×
Live data ×, Spoof data √, Unique Loss ×
Live data √, Spoof data √, Unique Loss √
Live data ×, Spoof data √, Unique Loss √

31.4
1.4
70.0
54.2
17.0

24.2
73.3
12.7
12.5
21.5

27.8
37.3
41.3
33.4
19.3

27.3
31.2
44.8
36.2
19.8

Advantage of each loss function We have three important
designs in our unsupervised tree learning: route loss Lroute,
data used to compute the route loss, and the unique loss
Luniq. To show the effect of each loss and the training strat-
egy, we train and compare networks with each loss excluded
and alternative strategies. First, we train a network with the
routing function proposed in [44], and then 4 models with
different modules on and off, shown in Tab. 4. The model
with MPT [44] routes data only to 2 leaf nodes out of 8 (i.e.
tree collapse issue), which limits the performance. Models
without the unique loss exhibit the imbalance routing issue
where sub-groups cannot be trained properly . Models using
all data to learn the tree show worse performances than us-
ing spoof data only. Finally, the proposed method performs
the best among all options.

5.2.2 Testing on existing databases

Following the protocol proposed in [3], we use CASIA [50],
Replay-Attack [15] and MSU-MFSD [42] to perform ZSFA
testing between replay and print attacks. Tab. 2 compares
the proposed method with top three methods selected from
over 20 methods in [3, 9, 45]. Our proposed method outper-
forms the prior state of the art by a convincing margin of
7.3%, and our smaller standard deviation further indicates a
consistently good performance among unknown attacks.

5.2.3 Testing on SiW-M

We execute 13 leave-one-out testing protocols on SiW-
M. We compare with two of the most recent face anti-
spooﬁng methods [9,32], and set [32] as the baseline, which
has demonstrated its SOTA performance on various bench-
marks. For a fair comparison with the baseline, we provide
the same pixel-wise labeling (as in Fig. 4), and set the same

73.7
87.3
78.9
99.6

s

64.8
47.7
50.6
81.6

87.4
99.5
99.9
99.9

74.7
97.6
93.5
97.5

N1

N2

N3

N4

N5

N6

N7

−

0

+

Figure 5: Visulization of the Tree Routing.

threshold of 0.2 to compute APCER, BPCER, and ACER.
As shown in Tab. 5, our method achieves an overall bet-
ter APCER, ACER and EER, with the improvement of base-
line by 55%, 29%, and 5%. Speciﬁcally, we reduce the
ACERs of transparent mask, funny eye, and paper glasses
by 31%, 61%, and 51%, where the baseline models can be
considered as total failures since they recognize most of the
attacks as live. Note that, ACER is more valuable in the
context of ZSFA: no evaluation data for setting threshold
and considerably varied thresholds for obtaining the EER
performance. For instance, EERs of paper glasses model
are similar between the baseline and our method, but with a
preset threshold, our method offers a much better ACER.

Moreover,

the proposed method is a more compact
model than [32]. Given the input size of 256 × 256 × 6,
the baseline requires 87 GFlops to compute the result while
our method only needs 6 GFlops (×15 smaller). More anal-
ysis are shown with visualization in Sec. 5.2.4.

5.2.4 Visualization and Analysis

To provide a better understanding of the tree learning and
ZSFA, we visualize the results in several ways. First, we
illustrate the tree routing results.
In Fig. 5, we rank the
spoof data based on the routing function values ϕ(x), and
provide 8 examples with responses from the smallest to the
largest. This offers us an intuitive understanding of what
are learned at each tree node. We observe an obvious spoof
style transfer: for the ﬁrst two-layer nodes N1, N2 and N3,

4686

Table 5: The evaluation and comparison of the testing on SiW-M.

Mask Attacks

Makeup Attacks

Silicone

Trans.

Paper Manne. Obfusc.

Imperson. Cosmetic

Funny Eye

Partial Attacks
Paper Glasses

Partial Paper

Methods

Metrics (%) Replay

Print

SVMRBF +LBP [9]

Auxiliary [32]

Ours

APCER
BPCER
ACER
EER

APCER
BPCER
ACER
EER

APCER
BPCER
ACER
EER

19.1
22.1
20.6
20.8
23.7
10.1
16.8
14.0

1.0
18.6
9.8
10.0

15.4
21.5
18.4
18.6
7.3
6.5
6.9
4.3
0.0
11.9
6.0
2.1

Half

40.8
21.9
31.3
36.3
27.7
10.9
19.3
11.6
0.7
29.3
15.0
14.4

20.3
21.4
21.4
21.4
18.2
11.6
14.9
12.4
24.5
12.8
18.7
18.6

70.3
20.7
45.5
37.2
97.8
6.2
52.1
24.6
58.6
13.4
36.0
26.5

Live

Replay

Print

Half Mask

Silicone Mask

Trans. Mask

Paper Mask

9

0

0

3

0

0

0

9

0

3

6

3

0

0

Manne

11

16

Ob. Makeup

Im. Makeup

Co. Makeup

Funny Eye

Paper Glasses

Partial Paper

Live (Test)

0

0

8

2

3

91

8

4

73

0

0

1

0

7

1

45

11

24

20

0

51

18

14

6

8

0

0

0

3

11

33

78

4

17

0

0

5

0

0

10

1

1

0

13

16

0

0

0

0

0

0

0

0

0

4

34

45

8

9

28

20

6

21

54

43

49

47

79

14

59

0

0

0

13

13

Live

35

32

1

2

0

Replay

0

Print

42

Half Mask

0

Silicone Mask

5

0

57
Trans. (Test)

0

0

Paper Mask

0

4

0

Manne

0

0

46

44

56

1

1

Ob. Makeup
3

0

96

Im. Makeup
6

0

10

Co. Makeup

1

27

Funny Eye

36

Paper Glasses

41

9

Partial Paper
0

0

1

17

23

11

1

2

3

0

0

40

0

1

0

0

1

40

74

0

34

19

Live (Test)

7

44

29

9

15

6

0

0

0

0

0

0

0

0

31

7

7

3

4

0

0

19

3

2

46

56

0

52

56

1

0

0

1

7

35

61

0

0

0

0

0

0

2

0

1

2

1

8

7

47

28

20

24

0

38

15

4

5

12

1

1

2

8

2

0

2

12

29

2

15

27

0

41

15

1

2

4

1

0

2

1

1

0

1

0

0

0

3

3

25

63

2

6

a f  1

a f  2

e

L

e

L

e

L

a f  3

e

L

e

a f  6

a f  5

a f  5
a f  4
(a)                                                                         (b)

a f  7

a f  8

a f  1

a f  2

a f  3

a f  4

L

L

e

L

e

L

e

L

e

L

e

L

e

L

e

L

e

a f  6

a f  7

e

L

e

L

e

L

a f  8

4.6
22.9
13.8
14.1
16.2
9.3
12.8
10.0
3.8
23.0
7.7
9.6

96.9
21.7
59.3
51.2
100.0
11.6
55.8
72.3
73.2
11.5
48.1
50.2

35.3
12.5
23.9
19.8
18.0
9.3
13.7
10.1
13.2
9.6
11.4
10.1

11.3
22.2
16.7
16.1
16.3
7.1
11.7
9.4
12.4
16.0
14.2
13.2

53.3
18.4
35.9
34.4
91.8
6.2
49.0
21.4
17.0
21.5
19.3
19.8

58.5
20.0
39.2
33.0
72.2
8.8
40.5
18.6
17.0
22.6
19.8
20.5

0.6
22.9
11.7
7.9
0.4
10.3
5.3
4.0
0.2
16.8
8.5
8.8

co. makeup
im. makeup
ob. makeup
half mask
manne
paper mask
silicone mask
trans. mask

replay
funny eye
paperglasses
partial paper

0.0
23.1
11.6
7.5
8.3
7.8
8.0
7.8
0.5
8.5
4.5
5.7

90

80

70

60

50

40

30

20

10

0

Average

32.8 ± 29.8
21.0 ± 2.9
26.9 ± 14.5
24.5 ± 12.9
38.3 ± 37.4
8.9 ± 2.0
23.6 ± 18.5
17.0 ± 17.7
17.1 ± 23.3
16.6 ± 6.2
16.8 ± 11.1
16.1 ± 12.2

live
co. makeup
im. makeup
ob. makeup
half mask
manne
paper mask
silicone mask
trans. mask
print
replay
funny eye
paperglasses
partial paper

Figure 6: Tree routing distribution of live/spoof data. X-axis de-
notes 8 leaf nodes, and y-axis denotes 15 types of data. The num-
ber in each cell represents the percentage (%) of data that fall in
that leaf node. Each row is sum to 1. (a) Print Protocol. (b) Trans-
parent Mask Protocol. Yellow box denotes the unknown attacks.

the transfer captures the change of general spoof attributes
such as image quality and color temperature; for the third-
layer tree nodes N4, N5, N6, and N7, the transfer involves
more spoof type speciﬁc changes. E.g., N7 transfers from
eye portion spoofs to full face 3D mask spoofs.

Further, Fig. 6 quantitatively analyzes the tree routing
distributions of all types of data. We utilize two models,
Print and Trans. Mask, to generate the distributions. It can
be observed that live samples are relatively more spread out
to 8 leaf nodes while the spoof attacks are routed to fewer
speciﬁc leaf nodes. Two distributions in Fig. 6 (a)&(b) share
similar semantic sub-groups, which demonstrates the suc-
cess of the proposed method on learning a tree. E.g., in
both models, about half of trans. mask samples share the
same leaf node as ob. makeup. By comparing two distri-
butions, most testing unknown spoofs in both models are
successfully routed to the most similar sub-groups.

In addition, we use t-SNE [34] to visualize the feature
space of Print model. The t-SNE is able to project the out-
put of the leaf node F(I | θ) ∈ R32×32×40 to 2D by preserv-
ing the KL divergence distance. Fig. 7 shows the features
of different types of spoof attacks are well-clustered into 8
semantic sub-groups even though we don’t provide any aux-
iliary labels. Based on these sub-groups, the features of un-
known print attacks are well lied in the sub-group of replay
and silicone mask, and thus are recognized as spoof. More-
over, with the visualization, we can explain the performance

Figure 7: t-SNE Visualization of the DTN leaf features.

variation among different spoof attacks, shown in Tab. 5.
Among all, the performance of trans. mask, funny eye, pa-
per glasses and ob. makeup are worse than other protocols.
The feature space shows that the live samples lies much
closer to those attacks than others (“→” places), and hence
it’s harder to distinguish them with the live samples. This
demonstrates the diverse property of different unknown at-
tacks and the necessity of such a wide range evaluation.

6. Conclusions

This paper tackles the zero-shot face antispooﬁng prob-
lem among 13 types of spoof attacks. The proposed method
leverages a deep tree network to route the unknown attacks
to the most proper leaf node for spoof detection. The tree is
trained in an unsupervised fashion to ﬁnd the feature base
with the largest variation to split the spoof data. We collect
SiW-M that contains more subjects and spoof types than
any previous databases. Finally, we experimentally show
superior performance of the proposed method.
Acknowledgment This research is based upon work sup-
ported by the Ofﬁce of the Director of National Intelli-
gence (ODNI), Intelligence Advanced Research Projects
Activity (IARPA), via IARPA R&D Contract No. 2017-
17020200004. The views and conclusions contained herein
are those of the authors and should not be interpreted as nec-
essarily representing the ofﬁcial policies or endorsements,
either expressed or implied, of the ODNI, IARPA, or the
U.S. Government. The U.S. Government is authorized to re-
produce and distribute reprints for Governmental purposes
notwithstanding any copyright annotation thereon.

4687

References

[1] ISO/IEC JTC 1/SC 37 Biometrics. information technol-
ogy biometric presentation attack detection part 1: Frame-
work. international organization for standardization, 2016.
https://www.iso.org/obp/ui/iso. 6

[2] A. Agarwal, R. Singh, and M. Vatsa. Face anti-spooﬁng us-

ing Haralick features. In BTAS, 2016. 2

[3] S. R. Arashloo, J. Kittler, and W. Christmas. An anomaly de-
tection approach to face spooﬁng detection: a new formula-
tion and evaluation protocol. IEEE Access, 5:13868–13882,
2017. 2, 7

[4] Y. Atoum, Y. Liu, A. Jourabloo, and X. Liu. Face anti-
spooﬁng using patch and depth-based CNNs. In IJCB, 2017.
1, 2

[5] W. Bao, H. Li, N. Li, and W. Jiang. A liveness detection
method for face recognition based on optical ﬂow ﬁeld. In
IEEE International Conference on Image Analysis and Sig-
nal Processing (IASP), 2009. 2

[6] S. Bharadwaj, T. I Dhamecha, M. Vatsa, and R. Singh.
Face anti-spooﬁng via motion magniﬁcation and multifea-
ture videolet aggregation. Technical report, 2014. 2

[7] Z. Boulkenafet, J. Komulainen, and A. Hadid. Face anti-
spooﬁng based on color texture analysis. In ICIP, 2015. 1,
2

[8] Z. Boulkenafet, J. Komulainen, and A. Hadid. Face anti-
spooﬁng using speeded-up robust features and ﬁsher vector
encoding. IEEE Signal Processing Letters, 2017. 2

[9] Z. Boulkenafet, J. Komulainen, L. Li, X. Feng, and A. Hadid.
OULU-NPU: A mobile face presentation attack database
with real-world variations. In FG, 2017. 3, 6, 7, 8

[10] Q. Cao, X. Liang, B. Li, G. Li, and L. Lin. Visual question

reasoning on general dependency tree. In CVPR, 2018. 3

[11] H. Chang, J. Lu, F. Yu, and A. Finkelstein. PairedCycle-
GAN: Asymmetric style transfer for applying and removing
makeup. In CVPR, 2018. 1

[12] C. Chen, A. Dantcheva, and A. Ross. Automatic facial
In

makeup detection with application in face recognition.
ICB, 2013. 1

[13] C. Chen, A. Dantcheva, and A. Ross. Impact of facial cos-
metics on automatic gender and age estimation algorithms.
In IEEE International Conference on Computer Vision The-
ory and Applications (VISAPP), 2014. 1

[14] X. Chen, C. Liu, and D. Song. Tree-to-tree neural networks
for program translation. arXiv preprint arXiv:1802.03691,
2018. 3

[15] I. Chingovska, A. Anjos, and S. Marcel. On the effectiveness
In BIOSIG,

of local binary patterns in face anti-spooﬁng.
2012. 3, 6, 7

[16] T. de Freitas Pereira, A. Anjos, J. M. De Martino, and S. Mar-
cel. LBP-TOP based countermeasure against face spooﬁng
attacks. In ACCV, 2012. 2

[17] T. de Freitas Pereira, A. Anjos, J. M. De Martino, and S.
Marcel. Can face anti-spooﬁng countermeasures work in a
real world scenario? In ICB, 2013. 2

[18] L. Feng, L. Po, Y. Li, X. Xu, F. Yuan, T. C. Cheung, and K.
Integration of image quality and motion cues for

Cheung.

face anti-spooﬁng: A neural network approach. Journal of
Visual Communication and Image Representation, 2016. 1,
2

[19] A. Frome, G. S. Corrado, J. Shlens, S. Bengio, J. Dean, T.
Mikolov, et al. Devise: A deep visual-semantic embedding
model. In NIPS, 2013. 2

[20] A. Jourabloo, Y. Liu, and X. Liu. Face de-spooﬁng: Anti-

spooﬁng via noise modeling. In ECCV, 2018. 1, 2

[21] T. Kaneko, K. Hiramatsu, and K. Kashino. Generative ad-
versarial image synthesis with decision tree latent controller.
In CVPR, 2018. 3

[22] N. Karessli, Z. Akata, B. Schiele, A. Bulling, et al. Gaze em-
beddings for zero-shot image classiﬁcation. In CVPR, 2017.
2

[23] V. Kazemi and J. Sullivan. One millisecond face alignment

with an ensemble of regression trees. In CVPR, 2014. 3

[24] K. Kollreider, H. Fronthaler, M. I. Faraj, and J. Bigun. Real-
time face detection and motion analysis with application in
liveness assessment. In TIFS, 2007. 2

[25] J. Komulainen, A. Hadid, and M. Pietikainen. Context based

face anti-spooﬁng. In BTAS, 2013. 2

[26] C. H. Lampert, H. Nickisch, and S. Harmeling. Learning to
detect unseen object classes by between-class attribute trans-
fer. In CVPR, 2009. 2

[27] L. Li, X. Feng, Z. Boulkenafet, Z. Xia, M. Li, and A. Hadid.
An original face anti-spooﬁng approach using partial convo-
lutional neural network. In IEEE International Conference
on Image Processing Theory Tools and Applications (IPTA),
2016. 2

[28] X. Li, J. Komulainen, G. Zhao, P. C. Yuen, and M.
Pietik¨ainen. Generalized face anti-spooﬁng by detecting
pulse from face videos. In ICPR, 2016. 2

[29] S. Liu, X. Lan, and P. C. Yuen. Remote photoplethysmog-
raphy correspondence feature for 3D mask face presentation
attack detection. In ECCV, 2018. 1

[30] S. Liu, B. Yang, P. C. Yuen, and Guoying Zhao. A 3D mask
In

face anti-spooﬁng database with real world variations.
CVPRW, 2016. 1, 2, 3

[31] S. Liu, P. C. Yuen, S. Zhang, and G. Zhao. 3D mask face
anti-spooﬁng with remote photoplethysmography. In ECCV,
2016. 1

[32] Y. Liu, A. Jourabloo, and X. Liu. Learning deep models
In

for face anti-spooﬁng: Binary or auxiliary supervision.
CVPR, 2018. 1, 2, 3, 5, 6, 7, 8

[33] Y. Liu, A. Jourabloo, W. Ren, and X. Liu. Dense face align-

ment. In ICCVW, 2017. 5

[34] L. Maaten and G. Hinton. Visualizing data using t-SNE.
Journal of machine learning research, 9(Nov):2579–2605,
2008. 8

[35] J. M¨a¨att¨a, A. Hadid, and M. Pietik¨ainen. Face spooﬁng de-
tection from single images using micro-texture analysis. In
IJCB, 2011. 1, 2

[36] G. Pan, L. Sun, Z. Wu, and S. Lao. Eyeblink-based anti-
spooﬁng in face recognition from a generic webcamera. In
ICCV, 2007. 2

[37] K. Patel, H. Han, and A. K. Jain. Cross-database face anti-
spooﬁng with robust feature representation. In CCBR, 2016.
2

4688

[38] K. Patel, H. Han, and A. K. Jain. Secure face unlock: Spoof

detection on smartphones. In TIFS, 2016. 1, 2

[39] R. Shao, X. Lan, and P. C. Yuen.

Deep convolu-
tional dynamic texture learning with adaptive channel-
discriminability for 3D mask face anti-spooﬁng.
In IJCB,
2017. 2

[40] R. Socher, M. Ganjoo, C. D. Manning, and A. Ng. Zero-shot

learning through cross-modal transfer. In NIPS, 2013. 2

[41] R. Valle and M. Jos´e. A deeply-initialized coarse-to-ﬁne
ensemble of regression trees for face alignment. In ECCV,
2018. 3

[42] D. Wen, H. Han, and A. K. Jain. Face spoof detection with

image distortion analysis. In TIFS, 2015. 6, 7

[43] Y. Wu and K. He. Group normalization. In ECCV, 2018. 5
[44] C. Xiong, X. Zhao, D. Tang, K. Jayashree, S. Yan, and
Conditional convolutional neural network for

T. Kim.
modality-aware face recognition. In ICCV, 2015. 3, 7

[45] F. Xiong and W. Abdalmageed. Unknown presentation at-
In BTAS, 2018. 2,

tack detection with face RGB images.
7

[46] Z. Xu, S. Li, and W. Deng. Learning temporal features using
In ACPR,

LSTM-CNN architecture for face anti-spooﬁng.
2015. 2

[47] J. Yang, Z. Lei, S. Liao, and S. Z. Li. Face liveness detection

with component dependent descriptor. In ICB, 2013. 2

[48] Z. Yang, J.and Lei and S. Z. Li.

neural network for face anti-spooﬁng.
arXiv:1408.5601, 2014. 2

Learn convolutional
arXiv preprint

[49] L. Zhang, T. Xiang, and S. Gong. Learning a deep embed-

ding model for zero-shot learning. In CVPR, 2017. 2

[50] Z. Zhang, J. Yan, S. Liu, Z. Lei, D. Yi, and S. Z. Li. A face
antispooﬁng database with diverse attacks. In ICB, 2012. 3,
6, 7

4689

