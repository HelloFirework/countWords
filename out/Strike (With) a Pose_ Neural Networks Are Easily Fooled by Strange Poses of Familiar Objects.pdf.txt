Strike (with) a Pose: Neural Networks Are Easily Fooled

by Strange Poses of Familiar Objects

Michael A. Alcorn
alcorma@auburn.edu

Qi Li

Zhitao Gong

Chengfei Wang

qzl0019@auburn.edu

gong@auburn.edu

czw0078@auburn.edu

Long Mai

Wei-Shinn Ku

Anh Nguyen

malong@adobe.com

weishinn@auburn.edu

anhnguyen@auburn.edu

Auburn University

Adobe Inc.

Abstract

(a)

(b)

(c)

(d)

Despite excellent performance on stationary test sets,
deep neural networks (DNNs) can fail to generalize to
out-of-distribution (OoD) inputs, including natural, non-
adversarial ones, which are common in real-world settings.
In this paper, we present a framework for discovering DNN
failures that harnesses 3D renderers and 3D models. That
is, we estimate the parameters of a 3D renderer that cause
a target DNN to misbehave in response to the rendered im-
age. Using our framework and a self-assembled dataset of
3D objects, we investigate the vulnerability of DNNs to OoD
poses of well-known objects in ImageNet. For objects that
are readily recognized by DNNs in their canonical poses,
DNNs incorrectly classify 97% of their pose space. In addi-
tion, DNNs are highly sensitive to slight pose perturbations.
Importantly, adversarial poses transfer across models and
datasets. We ﬁnd that 99.9% and 99.4% of the poses mis-
classiﬁed by Inception-v3 also transfer to the AlexNet and
ResNet-50 image classiﬁers trained on the same ImageNet
dataset, respectively, and 75.5% transfer to the YOLOv3 ob-
ject detector trained on MS COCO.

1. Introduction

For

such as

real-world technologies,

self-driving
cars [10], autonomous drones [14], and search-and-rescue
robots [37], the test distribution may be non-stationary, and
new observations will often be out-of-distribution (OoD),
i.e., not from the training distribution [42]. However, ma-
chine learning (ML) models frequently assign wrong labels
with high conﬁdence to OoD examples, such as adversarial
examples [46, 29]—inputs specially crafted by an adver-
sary to cause a target model to misbehave. But ML models
are also vulnerable to natural OoD examples [21, 2, 48, 3].
For example, when a Tesla autopilot car failed to recog-

school bus 1.0

garbage truck 0.99 punching bag 1.0

snowplow 0.92

motor scooter 0.99

parachute 1.0

bobsled 1.0

parachute 0.54

fire truck 0.99

school bus 0.98

fireboat 0.98

bobsled 0.79

Figure 1: The Google Inception-v3 classiﬁer [44] correctly
labels the canonical poses of objects (a), but fails to recog-
nize out-of-distribution images of objects in unusual poses
(b–d), including real photographs retrieved from the Inter-
net (d). The left 3 × 3 images (a–c) are found by our frame-
work and rendered via a 3D renderer. Below each image are
its top-1 predicted label and conﬁdence score.

nize a white truck against a bright-lit sky—an unusual view
that might be OoD—it crashed into the truck, killing the
driver [3].

Previous research has successfully used 3D graphics as
a diagnostic tool for computer vision systems [7, 31, 47,
32, 50]. To understand natural Type II classiﬁcation errors
in DNNs, we searched for misclassiﬁed 6D poses (i.e., 3D
translations and 3D rotations) of 3D objects. Our results re-

4845

veal that state-of-the-art image classiﬁers and object detec-
tors trained on large-scale image datasets [36, 22] misclas-
sify most poses for many familiar training-set objects. For
example, DNNs predict the front view of a school bus—
an object in the ImageNet dataset [36]—extremely well
(Fig. 1a) but fail to recognize the same object when it is too
close or ﬂipped over, i.e., in poses that are OoD yet exist in
the real world (Fig. 1d). However, a self-driving car needs
to correctly estimate at least some attributes of an incoming,
unknown object (instead of simply rejecting it [17, 38]) to
handle the situation gracefully and minimize damage. Be-
cause road environments are highly variable [3, 2], address-
ing this type of OoD error is a non-trivial challenge.

In this paper, we propose a framework for ﬁnding OoD
errors in computer vision models in which iterative opti-
mization in the parameter space of a 3D renderer is used
to estimate changes (e.g., in object geometry and appear-
ance, lighting, background, or camera settings) that cause
a target DNN to misbehave (Fig. 2). With our framework,
we generated unrestricted 6D poses of 3D objects and stud-
ied how DNNs respond to 3D translations and 3D rotations
of objects. For our study, we built a dataset of 3D ob-
jects corresponding to 30 ImageNet classes relevant to the
self-driving car application. The code for our framework
is available at https://github.com/airalcorn2/
strike-with-a-pose. In addition, we built a simple
GUI tool that allows users to generate their own adversarial
renders of an object. Our main ﬁndings are:

• ImageNet classiﬁers only correctly label 3.09% of the
entire 6D pose space of a 3D object, and misclassify
many generated adversarial examples (AXs) that are
human-recognizable (Fig. 1b–c). A misclassiﬁcation
can be found via a change as small as 10.31◦, 8.02◦,
and 9.17◦ to the yaw, pitch, and roll, respectively.

• 99.9% and 99.4% of AXs generated against Inception-
v3 transfer to the AlexNet and ResNet-50 image classi-
ﬁers, respectively, and 75.5% transfer to the YOLOv3
object detector.

• Training on adversarial poses generated by the 30 ob-
jects (in addition to the original ImageNet data) did
not help DNNs generalize well to held-out objects in
the same class.

In sum, our work shows that state-of-the-art DNNs per-
form image classiﬁcation well but are still far from true
object recognition. While it might be possible to improve
DNN robustness through adversarial training with many
more 3D objects, we hypothesize that future ML models
capable of visual reasoning may instead beneﬁt from better
incorporation of 3D information.

2. Framework

2.1. Problem formulation

Let f be an image classiﬁer that maps an image x ∈
RH×W ×C onto a softmax probability distribution over
1,000 output classes [44]. Let R be a 3D renderer that takes
as input a set of parameters φ and outputs a render, i.e., a 2D
image R(φ) ∈ RH×W ×C (see Fig. 2). Typically, φ is fac-
tored into mesh vertices V , texture images T , a background
image B, camera parameters C, and lighting parameters L,
i.e., φ = {V, T, B, C, L} [19]. To change the 6D pose of
a given 3D object, we apply a 3D rotation and 3D transla-
tion, parameterized by w ∈ R6, to the original vertices V
yielding a new set of vertices V ∗.

Here, we wish to estimate only the pose transformation
parameters w (while keeping all parameters in φ ﬁxed) such
that the rendered image R(w; φ) causes the classiﬁer f to
assign the highest probability (among all outputs) to an in-
correct target output at index t. Formally, we attempt to
solve the below optimization problem:

w

∗ = arg max

(ft(R(w; φ)))

w

(1)

In practice, we minimize the cross-entropy loss L for the
target class. Eq. 1 may be solved efﬁciently via backpropa-
gation if both f and R are differentiable, i.e., we are able to
compute ∂L/∂w. However, standard 3D renderers, e.g.,
OpenGL [51], typically include many non-differentiable
operations and cannot be inverted [27]. Therefore, we at-
tempted two approaches:
(1) harnessing a recently pro-
posed differentiable renderer and performing gradient de-
scent using its analytical gradients; and (2) harnessing a
non-differentiable renderer and approximating the gradient
via ﬁnite differences.

We will next describe the target classiﬁer (Sec. 2.2), the
renderers (Sec. 2.3), and our dataset of 3D objects (Sec. 2.4)
before discussing the optimization methods (Sec. 3).

2.2. Classiﬁcation networks

We chose the well-known, pre-trained Google Inception-
v3 [45] DNN from the PyTorch model zoo [33] as the main
image classiﬁer for our study (the default DNN if not other-
wise stated). The DNN has a 77.45% top-1 accuracy on the
ImageNet ILSVRC 2012 dataset [36] of 1.2 million images
corresponding to 1,000 categories.

2.3. 3D renderers

Non-differentiable renderer. We chose ModernGL [1]
as our non-differentiable renderer. ModernGL is a simple
Python interface for the widely used OpenGL graphics en-
gine. ModernGL supports fast, GPU-accelerated rendering.
Differentiable renderer.
To enable backpropagation
through the non-differentiable rasterization process, Kato et

4846

background

light	source

objects	(shapes,	textures)

target	network

forward pass

backward pass

error vs. desired output
������������

(a) 3D scene

camera

3D

renderer

(b)  2D image

image

classifier

Figure 2: To test a target DNN, we build a 3D scene (a) that consists of 3D objects (here, a school bus and a pedestrian),
lighting, a background scene, and camera parameters. Our 3D renderer renders the scene into a 2D image, which the image
classiﬁer labels school bus. We can estimate the pose changes of the school bus that cause the classiﬁer to misclassify by
(1) approximating gradients via ﬁnite differences; or (2) backpropagating (red dashed line) through a differentiable renderer.

al. [19] replaced the discrete pixel color sampling step with
a linear interpolation sampling scheme that admits non-zero
gradients. While the approximation enables gradients to
ﬂow from the output image back to the renderer param-
eters φ, the render quality is lower than that of our non-
differentiable renderer (see Fig. S1 for a comparison). Here-
after, we refer to the two renderers as NR and DR.

2.4. 3D object dataset

Construction. Our main dataset consists of 30 unique 3D
object models (purchased from many 3D model market-
places) corresponding to 30 ImageNet classes relevant to
a trafﬁc environment (Fig. S2). The 30 classes include 20
vehicles (e.g., school bus and cab) and 10 street-related
items (e.g., traffic light). See Sec. S1 for more details.
Each 3D object is represented as a mesh, i.e., a list of
triangular faces, each deﬁned by three vertices [27]. The 30
meshes have on average 9,908 triangles (Table S1). To max-
imize the realism of the rendered images, we used only 3D
models that have high-quality 2D image textures. We did
not choose 3D models from public datasets, e.g., Object-
Net3D [52], because most of them do not have high-quality
image textures. That is, the renders of such models may be
correctly classiﬁed by DNNs but still have poor realism.
Evaluation. We recognize that a reality gap will often exist
between a render and a real photo. Therefore, we rigorously
evaluated our renders to make sure the reality gap was ac-
ceptable for our study. From ∼100 initially-purchased 3D
models, we selected the 30 highest-quality models using the
evaluation method below.

First, we quantitatively evaluated DNN predictions on
the renders. For each object, we sampled 36 unique views
(common in ImageNet) evenly divided into three sets. For
each set, we set the object at the origin, the up direction
to (0, 1, 0), and the camera position to (0, 0, −z) where

z = {4, 6, 8}. We sampled 12 views per set by start-
ing the object at a 10◦ yaw and generating a render at ev-
ery 30◦ yaw-rotation. Across all objects and all renders,
the Inception-v3 top-1 accuracy was 83.23% (compared to
77.45% on ImageNet images [44]) with a mean top-1 conﬁ-
dence score of 0.78 (Table S2). See Sec. S1 for more details.
Second, we qualitatively evaluated the renders by com-
paring them to real photos. We produced 116 (real photo,
render) pairs via three steps: (1) we retrieved real photos of
an object (e.g., a car) from the Internet; (2) we replaced the
object with matching background content in Adobe Photo-
shop; and (3) we manually rendered the 3D object on the
background such that its pose closely matched that in the
reference photo. Fig. S3 shows example (real photo, render)
pairs. While discrepancies can be spotted in our side-by-
side comparisons, we found that most of the renders passed
our human visual Turing test if presented alone.

2.5. Background images

Previous studies have shown that image classiﬁers may
be able to correctly label an image when foreground ob-
jects are removed (i.e., based on only the background con-
tent) [57]. Because the purpose of our study was to under-
stand how DNNs recognize an object itself, a non-empty
background would have hindered our interpretation of the
results. Therefore, we rendered all images against a plain
background with RGB values of (0.485, 0.456, 0.406), i.e.,
the mean pixel of ImageNet images. Note that the presence
of a non-empty background should not alter our main quali-
tative ﬁndings in this paper—adversarial poses can be easily
found against real background photos (Fig. 1).

3. Methods

We will describe the common pose transformations
(Sec. 3.1) used in the main experiments. We were able to ex-

4847

periment with non-gradient methods because: (1) the pose
transformation space R6 that we optimize in is fairly low-
dimensional; and (2) although the NR is non-differentiable,
its rendering speed is several orders of magnitude faster than
that of DR. In addition, our preliminary results showed that
the objective function considered in Eq. 1 is highly non-
convex (see Fig. 4), therefore, it is interesting to compare
(1) random search vs.
(2) gradient descent using ﬁnite-
difference (FD) approximated gradients vs. (3) gradient de-
scent using the DR gradients.

3.1. Pose transformations

We used standard computer graphics transformation ma-
trices to change the pose of 3D objects [27]. Speciﬁcally, to
rotate an object with geometry deﬁned by a set of vertices
V = {vi}, we applied the linear transformations in Eq. 2 to
each vertex vi ∈ R3:

vR
i = RyRpRrvi

(2)

where Ry, Rp, and Rr are the 3 × 3 rotation matrices for
yaw, pitch, and roll, respectively (the matrices can be found
in Sec. S6). We then translated the rotated object by adding
a vector T = �xδ

to each vertex:

zδ��

yδ

vR,T
i = T + vR

i

(3)

In all experiments, the center c ∈ R3 of the object was
constrained to be inside a sub-volume of the camera view-
ing frustum. That is, the x-, y-, and z-coordinates of c were
within [−s, s], [−s, s], and [−28, 0], respectively, with s be-
ing the maximum value that would keep c within the camera
frame. Speciﬁcally, s is deﬁned as:

s = d · tan(θv)

(4)

where θv is one half the camera’s angle of view (i.e., 8.213◦
in our experiments) and d is the absolute value of the differ-
ence between the camera’s z-coordinate and zδ.

3.2. Random search

In reinforcement learning problems, random search (RS)
can be surprisingly effective compared to more sophisti-
cated methods [41]. For our RS procedure, instead of it-
eratively following some approximated gradient to solve
the optimization problem in Eq. 1, we simply randomly se-
lected a new pose in each iteration. The rotation angles for
the matrices in Eq. 2 were uniformly sampled from (0, 2π).
xδ, yδ, and zδ were also uniformly sampled from the ranges
deﬁned in Sec. 3.1.

3.3. zδ-constrained random search

Our preliminary RS results suggest the value of zδ
(which is a proxy for the object’s size in the rendered image)

has a large inﬂuence on a DNN’s predictions. Based on this
observation, we used a zδ-constrained random search (ZRS)
procedure both as an initializer for our gradient-based meth-
ods and as a naive performance baseline (for comparisons
in Sec. 4.4). The ZRS procedure consisted of generating 10
random samples of (xδ, yδ, θy, θp, θr) at each of 30 evenly
spaced zδ from −28 to 0.

When using ZRS for initialization, the parameter set with
the maximum target probability was selected as the starting
point. When using the procedure as an attack method, we
ﬁrst gathered the maximum target probabilities for each zδ,
and then selected the best two zδ to serve as the new range
for RS.

3.4. Gradient descent with ﬁnite-difference

We calculated the ﬁrst-order derivatives via ﬁnite central
differences and performed vanilla gradient descent to itera-
tively minimize the cross-entropy loss L for a target class.
That is, for each parameter wi, the partial derivative is ap-
proximated by:

∂L
∂wi

=

L(wi + h

2 ) − L(wi − h
2 )

h

(5)

Although we used an h of 0.001 for all parameters, a dif-
ferent step size can be used per parameter. Because radians
have a circular topology (i.e., a rotation of 0 radians is the
same as a rotation of 2π radians, 4π radians, etc.), we pa-
rameterized each rotation angle θi as (cos(θi), sin(θi))—a
technique commonly used for pose estimation [30] and in-
verse kinematics [11]—which maps the Cartesian plane to
angles via the atan2 function. Therefore, we optimized in
a space of 3 + 2 × 3 = 9 parameters.

The approximate gradient ∇L obtained from Equa-
tion (5) served as the gradient in our gradient descent. We
used the vanilla gradient descent update rule:

w := w − γ∇L(w)

(6)

with a learning rate γ of 0.001 for all parameters and opti-
mized for 100 steps (no other stopping criteria).

4. Experiments and results

4.1. Neural networks are easily confused by object

rotations and translations

Experiment. To test DNN robustness to object rotations
and translations, we used RS to generate samples for ev-
ery 3D object in our dataset.
In addition, to explore the
impact of lighting on DNN performance, we considered
three different lighting settings: bright, medium, and dark
(example renders in Fig. S10).
In all three settings, both
the directional light and the ambient light were white in
color, i.e., had RGB values of (1.0, 1.0, 1.0), and the direc-
tional light was oriented at (0, −1, 0) (i.e., pointing straight

4848

�������

�������

���

���

���

���

�������

����

����

����

����

����

�

�

�

�

�

�

��

�

���

�����

����

����

����

����

����

����

����

����

����

���

���

���

���

���

���

���

���

���

(a) Incorrect classiﬁcations

�������

�������

�������

���

���

���

���

����

����

����

����

����

�

�

�

�

�

�

��

�

���

�����

����

���

���

���

���

����

����

����

����

����

����

���

���

���

���

����

����

����

����

���

���

���

���

����

����

����

����

���

���

���

���

���

���

���

���

���

(b) Correct classiﬁcations

Figure 3: The distributions of individual pose parameters
for (a) high-conﬁdence (p ≥ 0.7) incorrect classiﬁcations
and (b) correct classiﬁcations obtained from the random
sampling procedure described in Sec. 3.2. xδ and yδ have
been normalized w.r.t. their corresponding s from Eq. 4.

down). The directional light intensities and ambient light
intensities were (1.2, 1.6), (0.4, 1.0), and (0.2, 0.5) for the
bright, medium, and dark settings, respectively. All other
experiments used the medium lighting setting.

Misclassiﬁcations uniformly cover the pose space. For
each object, we calculated the DNN accuracy (i.e., percent
of correctly classiﬁed samples) across all three lighting set-
tings (Table S5). The DNN was wrong for the vast majority
of samples, i.e., the median percent of correct classiﬁcations
for all 30 objects was only 3.09%. We veriﬁed the discov-
ered adversarial poses transfer to the real world by using the
3D objects to reproduce natural, misclassiﬁed poses found
on the Internet (see Sec. S3). High-conﬁdence misclassiﬁ-

cations (p ≥ 0.7) are largely uniformly distributed across
every pose parameter (Fig. 3a), i.e., AXs can be found
throughout the parameter landscape (see Fig. S15 for exam-
ples). In contrast, correctly classiﬁed examples are highly
multimodal w.r.t. the rotation axis angles and heavily biased
towards zδ values that are closer to the camera (Fig. 3b; also
compare Fig. S4 vs. Fig. S6). Intriguingly, for ball-like ob-
jects (not included in our main trafﬁc dataset), the DNN was
far more accurate across the pose space (see Sec. S8).
An object can be misclassiﬁed as many different labels.
Previous research has shown that it is relatively easy to pro-
duce AXs corresponding to many different classes when
optimizing input images [46] or 3D object textures [5],
which are very high-dimensional. When ﬁnding adversarial
poses, one might expect—because all renderer parameters,
including the original object geometry and textures, are held
constant—the success rate to depend largely on the similari-
ties between a given 3D object and examples of the target in
ImageNet. Interestingly, across our 30 objects, RS discov-
ered 990/1000 different ImageNet classes (132 of which
were shared between all objects). When only considering
high-conﬁdence (p ≥ 0.7) misclassiﬁcations, our 30 objects
were still misclassiﬁed into 797 different classes with a me-
dian number of 240 incorrect labels found per object (see
Fig. S16 and Fig. S6 for examples). Across all adversarial
poses and objects, DNNs tend to be more conﬁdent when
correct than when wrong (the median of median probabili-
ties were 0.41 vs. 0.21, respectively).

4.2. Common object classiﬁcations are shared

across different lighting settings

Here, we analyze how our results generalize across dif-
ferent lighting conditions.
From the data produced in
Sec. 4.1, for each object, we calculated the DNN accuracy
under each lighting setting. Then, for each object, we took
the absolute difference of the accuracies for all three light-
ing combinations (i.e., bright vs. medium, bright vs. dark,
and medium vs. dark) and recorded the maximum of those
values. The median “maximum absolute difference” of ac-
curacies for all objects was 2.29% (compared to the me-
dian accuracy of 3.09% across all lighting settings). That is,
DNN accuracy is consistently low across all lighting condi-
tions. Lighting changes would not alter the fact that DNNs
are vulnerable to adversarial poses.

We also recorded the 50 most frequent classes for each
object under the different lighting settings (Sb, Sm, and Sd).
Then, for each object, we computed the intersection over
union score oS for these sets:

oS = 100 ·

|Sb ∩ Sm ∩ Sd|
|Sb ∪ Sm ∪ Sd|

(7)

The median oS for all objects was 47.10%. That is, for 15
out of 30 objects, 47.10% of the 50 most frequent classes
were shared across lighting settings. While lighting does

4849

�
�
�
�
�

�����
�����
�����
�����
�����
�����
�����
�����
�����
�����
�����
�����
�����
����
����
����
����
����
����
����
����
����
����
����
����
����

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�
�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

�
�

�

�

��

��

��

��

��

��

�

�

�

�

�

�

�

�

�

�

����

(a)

(b)

Figure 4: Inception-v3’s ability to correctly classify images
is highly localized in the rotation and translation parameter
space. (a) The classiﬁcation landscape for 15 vehicle ob-
jects when altering θr and θp and holding (xδ, yδ, zδ, θy)
at (0, 0, −3, π
4 ). Lighter regions correspond to poses with
a greater number of correctly classiﬁed vehicle objects.
Green and red circles indicate correct and incorrect classiﬁ-
cations, respectively, corresponding to the ﬁre truck object
poses found in (b).

have an impact on DNN misclassiﬁcations (as expected),
the large number of shared labels across lighting settings
suggests ImageNet classes are strongly associated with cer-
tain adversarial poses regardless of lighting.

4.3. Correct classiﬁcations are highly localized in

the rotation and translation landscape

(e.g., Fig. 4; pitch vs. roll) while holding the other param-
eters constant. We qualitatively observed that the DNN’s
ability to recognize an object (e.g., a ﬁre truck) in an image
varies radically as the object is rotated in the world (Fig. 4).
Further, adversarial poses often generalize across similar
objects (e.g., 83% of the sampled poses were misclassiﬁed
for all 15 four-wheeled vehicle objects).
Experiment. To quantitatively evaluate the DNN’s sen-
sitivity to rotations and translations, we tested how it re-
sponded to single parameter disturbances. For each object,
we randomly selected 100 distinct starting poses that the
DNN had correctly classiﬁed in our random sampling runs.
Then, for each parameter (e.g., yaw rotation angle), we ran-
domly sampled 100 new values1 while holding the others
constant. For each sample, we recorded whether or not the
object remained correctly classiﬁed, and then computed the
failure (i.e., misclassiﬁcation) rate for a given (object, pa-
rameter) pair. Plots of the failure rates for all (object, pa-
rameter) combinations can be found in Fig. S18.

Additionally, for each parameter, we calculated the me-
dian of the median failure rates. That is, for each parameter,
we ﬁrst calculated the median failure rate for all objects, and
then calculated the median of those medians for each pa-
rameter. Further, for each (object, starting pose, parameter)
triple, we recorded the magnitude of the smallest parameter
change that resulted in a misclassiﬁcation. Then, for each
(object, parameter) pair, we recorded the median of these
minimum values. Finally, we again calculated the median
of these medians across objects (Table 1).
Results. As can be seen in Table 1, the DNN is highly
sensitive to all single parameter disturbances, but it is espe-
cially sensitive to disturbances along the depth (zδ), pitch
(θp), and roll (θr). To aid in the interpretation of these re-
sults, we converted the raw disturbance values in Table 1 to
image units. For xδ and yδ, the interpretable units are the
number of pixels the object shifted in the x or y directions of
the image (however, note that 3D translations are not equiv-
alent to 2D translations due to the perspective projection).

We found that a change in rotation as small as 8.02◦ can
cause an object to be misclassiﬁed (Table 1). Along the spa-
tial dimensions, a translation resulting in the object moving
as few as 2 px horizontally or 4.5 px vertically also caused
the DNN to misclassify.2 Lastly, along the z-axis, a change
in “size” (i.e., the area of the object’s bounding box) of only
5.4% can cause an object to be misclassiﬁed.

4.4. Optimization methods can effectively generate

targeted adversarial poses

Given a challenging, highly non-convex objective land-
scape (Fig. 4), we wish to evaluate the effectiveness of two

To gain some intuition for how Inception-v3 responds to
rotations and translations of an object, we plotted the prob-
ability and classiﬁcation landscapes for paired parameters

1using the random sampling procedure described in Sec. 3.2
2Note that the sensitivity of classiﬁers and object detectors to 2D trans-

lations has been observed in concurrent work [35, 12, 56, 6].

4850

Parameter

Fail Rate (%) Min. ∆ Int. ∆

Hit Rate (%) Target Prob.

xδ
yδ
zδ
θy
θp
θr

42
49
81
69
83
81

0.09
0.10
0.77
0.18
0.14
0.16

2.0 px
4.5 px
5.4%
10.31◦
8.02◦
9.17◦

Table 1: The median of the median failure rates and the me-
dian of the median minimum disturbances (Min. ∆) for the
single parameter sensitivity tests described in Section 4.3.
Int. ∆ converts the values in Min. ∆ to more interpretable
units. For xδ and yδ, the interpretable units are pixels. For
zδ, the interpretable unit is the percent change in the area of
the bounding box containing the object. See main text and
Fig. S18 for additional information.

different types of approximate gradients at targeted attacks,
i.e., ﬁnding adversarial examples misclassiﬁed as a target
class [46]. Here, we compare (1) random search; (2) gra-
dient descent with ﬁnite-difference gradients (FD-G); and
(3) gradient descent with analytical, approximate gradients
provided by a differentiable renderer (DR-G) [19].
Experiment. Because our adversarial pose attacks are in-
herently constrained by the ﬁxed geometry and appearances
of a given 3D object (see Sec. 4.1), we deﬁned the targets to
be the 50 most frequent incorrect classes found by our RS
procedure for each object. For each (object, target) pair, we
ran 50 optimization trials using ZRS, FD-G, and DR-G. All
treatments were initialized with a pose found by the ZRS
procedure and then allowed to optimize for 100 iterations.
Results. For each of the 50 optimization trials, we recorded
both whether or not the target was hit and the maximum
target probability obtained during the run. For each (ob-
ject, target) pair, we calculated the percent of target hits and
the median maximum conﬁdence score of the target labels
(see Table 2). As shown in Table 2, FD-G is substantially
more effective than ZRS at generating targeted adversarial
poses, having both higher median hit rates and conﬁdence
scores.
In addition, we found the approximate gradients
from DR to be surprisingly noisy, and DR-G largely under-
performed even non-gradient methods (ZRS) (see Sec. S5).

ZRS
random search
FD-G gradient-based
DR-G† gradient-based

78
92
32

0.29
0.41
0.22

Table 2: The median percent of target hits and the median
of the median target probabilities for random search (ZRS),
gradient descent with ﬁnite difference gradients (FD-G),
and DR gradients (DR-G). All attacks are targeted and ini-
tialized with zδ-constrained random search. †DR-G is not
directly comparable to FD-G and ZRS (details in Sec. S4).

trained on the MS COCO dataset [22].

For each object, we randomly selected 1,350 AXs that
were misclassiﬁed by Inception-v3 with high conﬁdence
(p ≥ 0.9) from our untargeted RS experiments in Sec. 4.1.
We exposed the AXs to AlexNet and ResNet-50 and cal-
culated their misclassiﬁcation rates. We found that al-
most all AXs transfer with median misclassiﬁcation rates
of 99.9% and 99.4% for AlexNet and ResNet-50, respec-
tively. In addition, 10.1% of AlexNet misclassiﬁcations and
27.7% of ResNet-50 misclassiﬁcations were identical to the
Inception-v3 predicted labels.

There are two orthogonal hypotheses for this result.
First, the ImageNet training-set images themselves may
contain a strong bias towards common poses, omitting un-
common poses (Sec. S7 shows supporting evidence from a
nearest-neighbor test). Second, the models themselves may
not be robust to even slight disturbances of the known, in-
distribution poses.
Object detectors. Previous research has shown that ob-
ject detectors can be more robust to adversarial attacks
than image classiﬁers [25]. Here, we investigate how
well our AXs transfer to a state-of-the-art object detector—
YOLOv3. YOLOv3 was trained on MS COCO, a dataset
of bounding boxes corresponding to 80 different object
classes. We only considered the 13 objects that belong
to classes present in both the ImageNet and MS COCO
datasets. We found that 75.5% of adversarial poses gen-
erated for Inception-v3 are also misclassiﬁed by YOLOv3
(see Sec. S2 for more details). These results suggest the
adversarial pose problem transfers across datasets, models,
and tasks.

4.5. Adversarial poses transfer to different image

4.6. Adversarial training

classiﬁers and object detectors

The most important property of previously documented
AXs is that they transfer across ML models, enabling black-
box attacks [55]. Here, we investigate the transferability of
our adversarial poses to (a) two different image classiﬁers,
AlexNet [20] and ResNet-50 [16], trained on the same Im-
ageNet dataset; and (b) an object detector YOLOv3 [34]

One of the most effective methods for defending against
OoD examples has been adversarial training [15], i.e. aug-
menting the training set with AXs—also a common ap-
proach in anomaly detection [9]. We tested whether adver-
sarial training can improve DNN robustness to new poses
generated for (1) our 30 training-set 3D objects; and (2)
seven held-out 3D objects (see Sec. S9 for details). Fol-

4851

lowing adversarial training, the accuracy of the DNN sub-
stantially increased for known objects (Table 3; 99.67% vs.
6.7%). However, the model (AT) still misclassiﬁed the ad-
versarial poses of held-out objects at an 89.2% error rate.

Error (T)
Error (H)

High-conﬁdence Error (T)
High-conﬁdence Error (H)

PT

AT

99.67
99.81

87.8
48.2

6.7
89.2

1.9
33.3

Table 3: The median percent of misclassiﬁcations (Error)
and high-conﬁdence (i.e., p > 0.7) misclassiﬁcations by
the pre-trained AlexNet (PT) and our AlexNet trained with
adversarial examples (AT) on random poses of training-set
objects (T) and held-out objects (H).

5. Related work

Out-of-distribution detection. OoD classes, i.e., classes
not found in the training set, present a signiﬁcant challenge
for computer vision technologies in real-world settings [38].
Here, we study an orthogonal problem—correctly classify-
ing OoD poses of objects from known classes. While re-
jecting to classify is a common approach for handling OoD
examples [17, 38], the OoD poses in our work come from
known classes and thus should be assigned correct labels.
2D adversarial examples. Numerous techniques for craft-
ing AXs that fool image classiﬁers have been discov-
ered [55]. However, previous work has typically optimized
in the 2D input space [55], e.g., by synthesizing an entire
image [29], a small patch [18, 13], a few pixels [8], or
only a single pixel [40]. But pixel-wise changes are uncor-
related [28], so pixel-based attacks may not transfer well
to the real world [24, 26] because there is an inﬁnitesimal
chance that such speciﬁcally crafted, uncorrelated pixels
will be encountered in the vast physical space of camera,
lighting, trafﬁc, and weather conﬁgurations. [54] generated
spatially transformed adversarial examples that are percep-
tually realistic and more difﬁcult to defend against, but the
technique still directly operates on pixels.
3D adversarial examples. Athalye et al. [5] used a 3D
renderer to synthesize textures for a 3D object such that,
under a wide range of camera views, the object was still
rendered into an effective AX. We also used 3D renderers,
but instead of optimizing textures, we optimized the poses
of known objects to cause DNNs to misclassify (i.e., we
kept the textures, lighting, camera settings, and background
image constant).
Concurrent work. We describe below two concurrent at-
tempts that are closely related to ours. First, Liu et al. [23]

proposed a differentiable 3D renderer and used it to perturb
both an object’s geometry and the scene’s lighting to cause a
DNN to misbehave. However, their geometry perturbations
were constrained to be inﬁnitesimal so that the visibility of
the vertices would not change. Therefore, their result of
minutely perturbing the geometry is effectively similar to
that of perturbing textures [5]. In contrast, we performed
3D rotations and 3D translations to move an object inside a
3D space (i.e., the viewing frustum of the camera).

Second, Engstrom et al. [12] showed how simple 2D im-
age rotations and translations can cause DNNs to misclas-
sify. However, these 2D transformations still do not reveal
the type of adversarial poses discovered by rotating 3D ob-
jects (e.g., a ﬂipped-over school bus; Fig. 1d).

To the best of our knowledge, our work is the ﬁrst at-
tempt to harness 3D objects to study the OoD poses of well-
known training-set objects that cause state-of-the-art Ima-
geNet classiﬁers and MS COCO detectors to misclassify.

6. Discussion and conclusion

In this paper, we revealed how DNNs’ understanding of
objects like “school bus” and “ﬁre truck” is quite naive—
they can correctly label only a small subset of the entire
pose space for 3D objects. Note that we can also ﬁnd real-
world OoD poses by simply taking photos of real objects
(Sec. S3). We believe classifying an arbitrary pose into one
of the object classes is an ill-posed task, and that the adver-
sarial pose problem might be alleviated via multiple orthog-
onal approaches. The ﬁrst is addressing biased data [49].
Because ImageNet and MS COCO datasets are constructed
from photographs taken by people, the datasets reﬂect the
aesthetic tendencies of their captors. Such biases can be
somewhat alleviated through data augmentation, speciﬁ-
cally, by harnessing images generated from 3D renderers
[39, 4]. From the modeling view, we believe DNNs would
beneﬁt from the incorporation of 3D information, e.g., [4].
Finally, our work introduced a new promising method
(Fig. 2) for testing computer vision DNNs by harnessing
3D renderers and 3D models. While we only optimize a sin-
gle object here, the framework could be extended to jointly
optimize lighting, background image, and multiple objects,
all in one “adversarial world”. Not only does our frame-
work enable us to enumerate test cases for DNNs, but it
also serves as an interpretability tool for extracting useful
insights about these black-box models’ inner functions.

Acknowledgements

We thank Hiroharu Kato and Nikos Kolotouros for their
valuable discussions and help with the differentiable ren-
derer. We also thank Rodrigo Sardinas for his help with
some GPU servers used in the project. AN is supported
by multiple funds from Auburn University, a donation from
Adobe Inc., and computing credits from Amazon AWS.

4852

References

[1] Moderngl moderngl 5.4.1 documentation.

https:

//moderngl.readthedocs.io/en/stable/
index.html. (Accessed on 11/14/2018).

[2] The self-driving uber that killed a pedestrian didn’t brake.
https://slate.com/technology/

here’s why.
2018/05/uber-car-in-fatal-arizona-
crash-perceived-pedestrian-1-3-seconds-
before-impact.html. (Accessed on 07/13/2018).

[3] Tesla car on autopilot crashes, killing driver, united
states news & top stories - the straits times. https:
//www.straitstimes.com/world/united-
states/tesla-car-on-autopilot-crashes-
killing-driver. (Accessed on 06/14/2018).

[4] H. A. Alhaija, S. K. Mustikovela, A. Geiger,

and
arXiv preprint

C. Rother. Geometric image synthesis.
arXiv:1809.04696, 2018.

[5] A. Athalye, L. Engstrom, A. Ilyas, and K. Kwok. Synthe-
sizing robust adversarial examples.
In 2018 Proceedings
of the 35th International Conference on Machine Learning
(ICML), pages 284–293, 2018.

[6] A. Azulay and Y. Weiss. Why do deep convolutional net-
works generalize so poorly to small image transformations?
arXiv preprint arXiv:1805.12177, 2018.

[7] A. Borji, S. Izadi, and L. Itti. ilab-20m: A large-scale con-
trolled object dataset to investigate deep learning.
In Pro-
ceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, pages 2221–2230, 2016.

[8] N. Carlini and D. Wagner. Towards Evaluating the Robust-
ness of Neural Networks. In 2017 IEEE Symposium on Se-
curity and Privacy (SP), 2017.

[9] V. Chandola, A. Banerjee, and V. Kumar. Anomaly detec-
tion: A survey. ACM computing surveys (CSUR), 41(3):15,
2009.

[10] C. Chen, A. Seff, A. Kornhauser, and J. Xiao. Deepdriving:
Learning affordance for direct perception in autonomous
driving. In Proceedings of the IEEE International Confer-
ence on Computer Vision, pages 2722–2730, 2015.

[11] B. B. Choi and C. Lawrence. Inverse Kinematics Problem
in Robotics Using Neural Networks. NASA Technical Mem-
orandum, 105869:1–23, 1992.

[12] L. Engstrom, B. Tran, D. Tsipras, L. Schmidt, and A. Madry.
A rotation and a translation sufﬁce: Fooling CNNs with sim-
ple transformations, 2019.

[13] I. Evtimov, K. Eykholt, E. Fernandes, T. Kohno, B. Li,
A. Prakash, A. Rahmati, and D. Song. Robust physical-
world attacks on machine learning models. arXiv preprint
arXiv:1707.08945, 2017.

[14] D. Gandhi, L. Pinto, and A. Gupta. Learning to ﬂy by
crashing.
In Intelligent Robots and Systems (IROS), 2017
IEEE/RSJ International Conference on, pages 3948–3955.
IEEE, 2017.

[15] I. Goodfellow, J. Shlens, and C. Szegedy. Explaining and
In International Confer-

harnessing adversarial examples.
ence on Learning Representations, 2015.

[16] K. He, X. Zhang, S. Ren, and J. Sun. Deep Residual Learning
for Image Recognition. In 2016 IEEE Conference on Com-
puter Vision and Pattern Recognition (CVPR), pages 770–
778, 2016.

[17] D. Hendrycks and K. Gimpel. A baseline for detecting
misclassiﬁed and out-of-distribution examples in neural net-
works.
In Proceedings of International Conference on
Learning Representations, 2017.

[18] D. Karmon, D. Zoran, and Y. Goldberg.

calized and visible adversarial noise.
arXiv:1801.02608, 2018.

Lavan: Lo-
arXiv preprint

[19] H. Kato, Y. Ushiku, and T. Harada. Neural 3D Mesh Ren-
derer. In The IEEE Conference on Computer Vision and Pat-
tern Recognition (CVPR), 2018.

[20] A. Krizhevsky, I. Sutskever, and G. E. Hinton.

ImageNet
Classiﬁcation with Deep Convolutional Neural Networks. In
Advances in Neural Information Processing Systems (NIPS
2012), pages 1097–1105, 2012.

[21] F. Lambert. Understanding the fatal tesla accident on autopi-

lot and the nhtsa probe. Electrek, July, 2016.

[22] T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Perona, D. Ra-
manan, P. Doll´ar, and C. L. Zitnick. Microsoft coco: Com-
mon objects in context. In European conference on computer
vision, pages 740–755. Springer, 2014.

[23] H.-T. D. Liu, M. Tao, C.-L. Li, D. Nowrouzezahrai, and
A. Jacobson. Adversarial Geometry and Lighting using a
Differentiable Renderer. arXiv preprint, 8 2018.

[24] J. Lu, H. Sibai, E. Fabry, and D. Forsyth. NO Need to
Worry about Adversarial Examples in Object Detection in
Autonomous Vehicles. arXiv preprint, 7 2017.

[25] J. Lu, H. Sibai, E. Fabry, and D. A. Forsyth. Standard de-
tectors aren’t (currently) fooled by physical adversarial stop
signs. CoRR, abs/1710.03337, 2017.

[26] Y. Luo, X. Boix, G. Roig, T. Poggio, and Q. Zhao. Foveation-
based Mechanisms Alleviate Adversarial Examples. arXiv
preprint, 11 2015.

[27] S. Marschner and P. Shirley. Fundamentals of computer

graphics. CRC Press, 2015.

[28] A. Nguyen, J. Clune, Y. Bengio, A. Dosovitskiy, and
J. Yosinski. Plug & play generative networks: Conditional
iterative generation of images in latent space. In CVPR, vol-
ume 2, page 7, 2017.

[29] A. Nguyen, J. Yosinski, and J. Clune. Deep neural networks
are easily fooled: High conﬁdence predictions for unrec-
ognizable images.
In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 427–436,
2015.

[30] M. Osadchy, M. L. Miller, and Y. LeCun. Synergistic Face
Detection and Pose Estimation with Energy-Based Mod-
els. In Advances in Neural Information Processing Systems,
pages 1017–1024, 2005.

[31] M. Ozuysal, V. Lepetit, and P. Fua. Pose estimation for cate-
gory speciﬁc multiview object localization.
In 2009 IEEE
Conference on Computer Vision and Pattern Recognition,
pages 778–785. IEEE, 2009.

[32] N. Pinto, J. J. DiCarlo, and D. D. Cox. How far can you
get with a modern face recognition test set using only simple

4853

features? In 2009 IEEE Conference on Computer Vision and
Pattern Recognition, pages 2591–2598. IEEE, 2009.

[33] PyTorch.

torchvision.models
pytorch master documen-
https://pytorch.org/docs/stable/
on

(Accessed

tation.
torchvision/models.html.
11/14/2018).

[34] J. Redmon and A. Farhadi. YOLOv3: An Incremental Im-

provement. 2018.

[35] A. Rosenfeld, R. Zemel, and J. K. Tsotsos. The elephant in

the room. arXiv preprint arXiv:1808.03305, 2018.

[36] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh,
S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein,
et al.
Imagenet large scale visual recognition challenge.
International Journal of Computer Vision, 115(3):211–252,
2015.

[37] C. Sampedro, A. Rodriguez-Ramos, H. Bavle, A. Carrio,
P. de la Puente, and P. Campoy. A fully-autonomous aerial
robot for search and rescue applications in indoor environ-
ments using learning-based techniques. Journal of Intelligent
& Robotic Systems, pages 1–27, 2018.

[38] W. J. Scheirer, A. de Rezende Rocha, A. Sapkota, and T. E.
Boult. Toward open set recognition. IEEE transactions on
pattern analysis and machine intelligence, 35(7):1757–1772,
2013.

[39] A. Shrivastava, T. Pﬁster, O. Tuzel, J. Susskind, W. Wang,
and R. Webb. Learning from simulated and unsupervised
images through adversarial training.
In CVPR, volume 2,
page 5, 2017.

[48] Y. Tian, K. Pei, S. Jana, and B. Ray. Deeptest: Automated
testing of deep-neural-network-driven autonomous cars. In
Proceedings of the 40th International Conference on Soft-
ware Engineering, pages 303–314. ACM, 2018.

[49] A. Torralba and A. A. Efros. Unbiased look at dataset bias.
In Computer Vision and Pattern Recognition (CVPR), 2011
IEEE Conference on, pages 1521–1528. IEEE, 2011.

[50] Y. Z. S. Q. Z. X. T. S. K. Y. W. A. Y. Weichao Qiu, Fang-
wei Zhong. Unrealcv: Virtual worlds for computer vision.
ACM Multimedia Open Source Software Competition, 2017.
[51] M. Woo, J. Neider, T. Davis, and D. Shreiner. OpenGL pro-
gramming guide: the ofﬁcial guide to learning OpenGL, ver-
sion 1.2. Addison-Wesley Longman Publishing Co., Inc.,
1999.

[52] Y. Xiang, W. Kim, W. Chen, J. Ji, C. Choy, H. Su, R. Mot-
taghi, L. Guibas, and S. Savarese. Objectnet3d: A large scale
database for 3d object recognition. In European Conference
on Computer Vision, pages 160–176. Springer, 2016.

[53] Y. Xiang, T. Schmidt, V. Narayanan, and D. Fox. Posecnn:
A convolutional neural network for 6d object pose estimation
in cluttered scenes. arXiv preprint arXiv:1711.00199, 2017.
[54] C. Xiao, J.-Y. Zhu, B. Li, W. He, M. Liu, and D. Song.
Spatially transformed adversarial examples. In International
Conference on Learning Representations, 2018.

[55] X. Yuan, P. He, Q. Zhu, and X. Li. Adversarial Examples:
Attacks and Defenses for Deep Learning. arXiv preprint,
2017.

[56] R. Zhang. Making convolutional networks shift-invariant

[40] J. Su, D. V. Vargas, and S. Kouichi. One Pixel Attack for

again, 2019.

Fooling Deep Neural Networks. arXiv preprint, 2017.

[57] Z. Zhu, L. Xie, and A. L. Yuille. Object recognition with and

without objects. arXiv preprint arXiv:1611.06596, 2016.

[41] F. P. Such, V. Madhavan, E. Conti, J. Lehman, K. O. Stanley,
and J. Clune. Deep neuroevolution: genetic algorithms are a
competitive alternative for training deep neural networks for
reinforcement learning. arXiv preprint arXiv:1712.06567,
2017.

[42] M. Sugiyama, N. D. Lawrence, A. Schwaighofer, et al.

Dataset shift in machine learning. The MIT Press, 2017.

[43] X. Sun, J. Wu, X. Zhang, Z. Zhang, C. Zhang, T. Xue, J. B.
Tenenbaum, and W. T. Freeman. Pix3d: Dataset and methods
for single-image 3d shape modeling. In IEEE Conference on
Computer Vision and Pattern Recognition (CVPR), 2018.

[44] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the inception architecture for computer vision. In
Proceedings of the IEEE conference on computer vision and
pattern recognition, pages 2818–2826, 2016.

[45] C. Szegedy, V. Vanhoucke, S. Ioffe, J. Shlens, and Z. Wojna.
Rethinking the Inception Architecture for Computer Vision.
In The IEEE Conference on Computer Vision and Pattern
Recognition (CVPR), pages 2818–2826, 12 2016.

[46] C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan,
I. Goodfellow, and R. Fergus. Intriguing properties of neural
networks. In International Conference on Learning Repre-
sentations, 2014.

[47] G. R. Taylor, A. J. Chosak, and P. C. Brewer. Ovvv: Using
virtual worlds to design and evaluate surveillance systems.
In 2007 IEEE conference on computer vision and pattern
recognition, pages 1–8. IEEE, 2007.

4854

